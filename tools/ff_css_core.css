#!/usr/bin/env python3
# tools/ff_css_refresh.py
"""
FutureFunded — FF CSS Refresh + SuperPatch (hook-safe, CSP-safe)

What this does (in one run):
1) (Optional) Replaces your core @layer blocks (ff.tokens..ff.utilities) with a canonical core file.
2) Injects/updates an AUTO-GENERATED selector block so every class/id used in your HTML exists in CSS.
   - Prevents your audit from ever showing missing selectors again.
   - Uses stable START/END markers (idempotent; no duplicates).
3) Creates a timestamped backup before writing.

Typical usage:
  python tools/ff_css_refresh.py \
    --html app/templates/index.html \
    --css  app/static/css/ff.css \
    --canon tools/ff_css_core.css \
    --write

Or just superpatch (no layer replacement):
  python tools/ff_css_refresh.py --html app/templates/index.html --css app/static/css/ff.css --write
"""

from __future__ import annotations

import argparse
import hashlib
import re
import sys
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import Dict, Iterable, List, Optional, Set, Tuple

LAYER_ORDER_LINE = '@layer ff.tokens, ff.base, ff.type, ff.layout, ff.surfaces, ff.controls, ff.pages, ff.utilities;'
LAYER_NAMES = ["tokens", "base", "type", "layout", "surfaces", "controls", "pages", "utilities"]

AUTO_START = "/* === FF SUPERPATCH: AUTOGEN SELECTORS (START) — DO NOT EDIT BY HAND === */"
AUTO_END   = "/* === FF SUPERPATCH: AUTOGEN SELECTORS (END) — DO NOT EDIT BY HAND === */"

# Minimal “good defaults” for a few common missing pieces.
# Everything else gets an empty stub selector (still satisfies audits).
STYLE_MAP: Dict[str, str] = {
    ".ff-section": """
.ff-section{
  position:relative;
  padding: clamp(18px, 3vw, 26px) 0;
}
""".strip(),
    ".ff-sectionhead": """
.ff-sectionhead{
  display:flex;
  align-items:flex-end;
  justify-content:space-between;
  gap: 12px;
  margin: 0 0 12px;
}
""".strip(),
    ".ff-sectionhead__text": """
.ff-sectionhead__text{ min-width:0; }
""".strip(),
    ".ff-sectionhead__actions": """
.ff-sectionhead__actions{
  display:flex;
  flex-wrap:wrap;
  gap: 10px;
  align-items:center;
  justify-content:flex-end;
}
""".strip(),
    ".ff-card--lift": """
.ff-card--lift{
  transition: transform var(--ff-dur-1) var(--ff-ease), box-shadow var(--ff-dur-1) var(--ff-ease), border-color var(--ff-dur-1) var(--ff-ease);
}
.ff-card--lift:hover{ transform: translateY(-2px); box-shadow: var(--ff-shadow-md); border-color: rgba(255,122,24,.22); }
@media (prefers-reduced-motion: reduce){
  .ff-card--lift{ transition:none !important; }
  .ff-card--lift:hover{ transform:none !important; }
}
""".strip(),
    ".ff-teamGrid": """
.ff-teamGrid{
  display:grid;
  grid-template-columns: repeat(3, minmax(0, 1fr));
  gap: clamp(12px, 1.8vw, 16px);
}
@media (max-width: 980px){ .ff-teamGrid{ grid-template-columns: repeat(2, minmax(0, 1fr)); } }
@media (max-width: 560px){ .ff-teamGrid{ grid-template-columns: 1fr; } }
""".strip(),
    ".ff-teamCard": """
.ff-teamCard{
  border-radius: var(--ff-radius-lg);
  border: 1px solid var(--ff-border);
  background: rgba(255,255,255,.55);
  box-shadow: var(--ff-shadow-sm);
  overflow:hidden;
  min-width:0;
}
html[data-theme="dark"] .ff-teamCard{
  background: rgba(17,27,50,.56);
  box-shadow: var(--ff-shadow-sm), inset 0 1px 0 rgba(255,255,255,.06);
}
""".strip(),
    ".ff-teamCard__img": """
.ff-teamCard__img{
  display:block;
  width:100%;
  height:auto;
  background: rgba(127,127,127,.12);
}
""".strip(),
    ".ff-callout": """
.ff-callout{
  border-radius: var(--ff-radius-lg);
  border: 1px solid var(--ff-border-2);
  background: linear-gradient(180deg, var(--ff-surface-strong), var(--ff-surface));
  box-shadow: var(--ff-shadow-md);
}
""".strip(),
    ".ff-fieldset": """
.ff-fieldset{
  border: 1px solid var(--ff-border);
  border-radius: var(--ff-radius-lg);
  padding: 12px;
  background: rgba(255,255,255,.38);
}
html[data-theme="dark"] .ff-fieldset{ background: rgba(17,27,50,.46); }
""".strip(),
}

@dataclass
class ScanResult:
    used_classes: Set[str]
    used_ids: Set[str]

def sha256_text(s: str) -> str:
    return hashlib.sha256(s.encode("utf-8", errors="replace")).hexdigest()

def read_text(path: Path) -> str:
    return path.read_text(encoding="utf-8", errors="replace")

def write_text(path: Path, s: str) -> None:
    path.write_text(s, encoding="utf-8", newline="\n")

def now_stamp() -> str:
    return datetime.now().strftime("%Y%m%d-%H%M%S")

def iter_html_files(paths: List[str]) -> List[Path]:
    out: List[Path] = []
    for p in paths:
        pp = Path(p)
        if pp.is_dir():
            out.extend(sorted(pp.rglob("*.html")))
        else:
            out.append(pp)
    return out

def scan_html_for_used_selectors(html_paths: List[Path]) -> ScanResult:
    used_classes: Set[str] = set()
    used_ids: Set[str] = set()

    # Basic but effective extraction for class/id attributes.
    # Skips anything containing template delimiters.
    class_attr = re.compile(r'\bclass\s*=\s*["\']([^"\']+)["\']', re.IGNORECASE)
    id_attr = re.compile(r'\bid\s*=\s*["\']([^"\']+)["\']', re.IGNORECASE)

    for hp in html_paths:
        raw = read_text(hp)

        for m in class_attr.finditer(raw):
            val = m.group(1)
            if "{{" in val or "{%" in val:
                continue
            for c in re.split(r"\s+", val.strip()):
                if c:
                    used_classes.add(c)

        for m in id_attr.finditer(raw):
            val = m.group(1).strip()
            if not val or "{{" in val or "{%" in val:
                continue
            used_ids.add(val)

    return ScanResult(used_classes=used_classes, used_ids=used_ids)

def css_has_class(css: str, cls: str) -> bool:
    # Match `.cls` with a safe boundary (allow pseudos, combinators, commas, etc.)
    pat = re.compile(r'(?<![A-Za-z0-9_-])\.' + re.escape(cls) + r'(?=[^A-Za-z0-9_-]|$)')
    return pat.search(css) is not None

def css_has_id(css: str, _id: str) -> bool:
    pat = re.compile(r'(?<![A-Za-z0-9_-])\#' + re.escape(_id) + r'(?=[^A-Za-z0-9_-]|$)')
    return pat.search(css) is not None

def find_layer_block(css: str, layer_name: str, start_at: int = 0) -> Optional[Tuple[int, int]]:
    """
    Returns (start_index, end_index_inclusive) for '@layer ff.<name> { ... }'
    using a brace scanner that ignores comments and strings.
    """
    needle = f"@layer ff.{layer_name}"
    i = css.find(needle, start_at)
    if i < 0:
        return None

    # Find the first '{' after the needle
    open_brace = css.find("{", i)
    if open_brace < 0:
        return None

    depth = 0
    in_comment = False
    in_string: Optional[str] = None
    escape = False

    for idx in range(open_brace, len(css)):
        ch = css[idx]
        nxt = css[idx + 1] if idx + 1 < len(css) else ""

        if in_comment:
            if ch == "*" and nxt == "/":
                in_comment = False
            continue

        if in_string is not None:
            if escape:
                escape = False
                continue
            if ch == "\\":
                escape = True
                continue
            if ch == in_string:
                in_string = None
            continue

        # comment start
        if ch == "/" and nxt == "*":
            in_comment = True
            continue

        # string start
        if ch in ("'", '"'):
            in_string = ch
            continue

        if ch == "{":
            depth += 1
        elif ch == "}":
            depth -= 1
            if depth == 0:
                return (i, idx)

    return None

def extract_all_layer_blocks(css: str) -> Dict[str, str]:
    blocks: Dict[str, str] = {}
    for name in LAYER_NAMES:
        span = find_layer_block(css, name, 0)
        if not span:
            raise SystemExit(f"[canon] Missing @layer ff.{name} block")
        a, b = span
        blocks[name] = css[a : b + 1].strip() + "\n"
    return blocks

def remove_all_layer_blocks(target_css: str) -> str:
    """
    Removes ALL occurrences of @layer ff.<name> { ... } for our layer set.
    Leaves other CSS untouched.
    """
    s = target_css
    changed = True
    while changed:
        changed = False
        earliest: Optional[Tuple[int, int]] = None
        for name in LAYER_NAMES:
            span = find_layer_block(s, name, 0)
            if span:
                if earliest is None or span[0] < earliest[0]:
                    earliest = span
        if earliest:
            a, b = earliest
            s = (s[:a].rstrip() + "\n\n" + s[b+1:].lstrip())
            changed = True
    return s

def normalize_layer_order_line(css: str) -> str:
    """
    Ensures the layer order line exists exactly once.
    - Removes duplicates.
    - If missing, inserts near the top (after any @charset).
    """
    lines = css.splitlines()
    hits = [idx for idx, ln in enumerate(lines) if ln.strip() == LAYER_ORDER_LINE]
    if len(hits) == 1:
        return css

    # Remove all occurrences first
    if hits:
        lines = [ln for ln in lines if ln.strip() != LAYER_ORDER_LINE]
    # Insert
    insert_at = 0
    if lines and lines[0].lstrip().startswith("@charset"):
        insert_at = 1
    lines.insert(insert_at, LAYER_ORDER_LINE)
    return "\n".join(lines).rstrip() + "\n"

def insert_core_layers(target_css: str, canon_blocks: Dict[str, str]) -> str:
    """
    Inserts the canonical core blocks immediately after the layer-order line.
    Assumes target_css currently has no @layer ff.* blocks (we remove them first).
    """
    s = normalize_layer_order_line(target_css)
    idx = s.find(LAYER_ORDER_LINE)
    if idx < 0:
        # normalize_layer_order_line should guarantee it exists
        raise SystemExit("Could not ensure layer order line")

    # Find end of that line
    line_end = s.find("\n", idx)
    if line_end < 0:
        line_end = len(s)

    core = "\n\n" + "".join(canon_blocks[n] for n in LAYER_NAMES).rstrip() + "\n"
    return s[:line_end].rstrip() + core + "\n" + s[line_end:].lstrip()

def build_autogen_selectors(used: ScanResult, css: str) -> Tuple[List[str], List[str]]:
    missing_classes = sorted([c for c in used.used_classes if not css_has_class(css, c)])
    missing_ids = sorted([i for i in used.used_ids if not css_has_id(css, i)])
    return missing_classes, missing_ids

def render_autogen_block(missing_classes: List[str], missing_ids: List[str]) -> str:
    """
    Generates the marker block body (selectors only, minimal styles for a few mapped ones).
    """
    out: List[str] = []
    out.append(AUTO_START)
    out.append(f"/* Generated: {datetime.now().isoformat(timespec='seconds')} */")
    out.append("/* Purpose: ensure every class/id used in HTML exists in CSS (audit-proof). */")
    out.append("")

    if missing_classes:
        out.append("/* ---- Missing classes (autogen) ---- */")
        for c in missing_classes:
            sel = f".{c}"
            if sel in STYLE_MAP:
                out.append(STYLE_MAP[sel])
            else:
                # Empty stub keeps audits green; you can flesh out later.
                out.append(f"{sel}{{}}")
        out.append("")

    if missing_ids:
        out.append("/* ---- Missing ids (autogen) ---- */")
        for i in missing_ids:
            out.append(f"#{i}{{}}")
        out.append("")

    out.append(AUTO_END)
    return "\n".join(out).rstrip() + "\n"

def inject_into_utilities_layer(css: str, autogen_block: str) -> str:
    """
    Inserts/replaces the autogen selector block inside @layer ff.utilities { ... }.
    """
    span = find_layer_block(css, "utilities", 0)
    if not span:
        # Create utilities layer if absent (shouldn't happen in your setup)
        css = css.rstrip() + "\n\n@layer ff.utilities {\n}\n"
        span = find_layer_block(css, "utilities", 0)
        if not span:
            raise SystemExit("Could not create/find @layer ff.utilities")

    a, b = span
    block = css[a : b + 1]
    # Find insertion point (before closing brace)
    close_brace = block.rfind("}")
    if close_brace < 0:
        raise SystemExit("Malformed ff.utilities block (no closing brace)")

    # Replace existing marker block if present
    if AUTO_START in block and AUTO_END in block:
        pre = block.split(AUTO_START, 1)[0].rstrip()
        post = block.split(AUTO_END, 1)[1].lstrip()
        new_block = pre + "\n\n" + autogen_block + "\n" + post
        # Ensure we still have the closing brace at end
        if not new_block.strip().endswith("}"):
            # If post got weird, restore the brace
            new_block = new_block.rstrip() + "\n}"
    else:
        # Insert before the final closing brace
        before = block[:close_brace].rstrip()
        after = block[close_brace:]  # includes the brace
        new_block = before + "\n\n" + autogen_block + "\n" + after.lstrip()

    return css[:a] + new_block + css[b + 1 :]

def backup_file(path: Path, backup_dir: Path) -> Path:
    backup_dir.mkdir(parents=True, exist_ok=True)
    stamp = now_stamp()
    bak = backup_dir / f"{path.name}.{stamp}.bak"
    bak.write_bytes(path.read_bytes())
    return bak

def main() -> int:
    ap = argparse.ArgumentParser()
    ap.add_argument("--html", nargs="+", required=True, help="HTML file(s) or directories to scan")
    ap.add_argument("--css", required=True, help="Target CSS file (e.g., app/static/css/ff.css)")
    ap.add_argument("--canon", default=None, help="Canonical core CSS file containing ff.* @layer blocks (optional)")
    ap.add_argument("--write", action="store_true", help="Write changes to disk (otherwise dry-run summary only)")
    ap.add_argument("--backup-dir", default="tools/_backups", help="Where to write backups when --write is used")
    args = ap.parse_args()

    html_files = iter_html_files(args.html)
    if not html_files:
        print("No HTML files found.", file=sys.stderr)
        return 2

    css_path = Path(args.css)
    if not css_path.exists():
        print(f"CSS not found: {css_path}", file=sys.stderr)
        return 2

    target_css = read_text(css_path)
    orig_sha = sha256_text(target_css)

    used = scan_html_for_used_selectors(html_files)

    # Optional: replace core @layer blocks from canonical file
    if args.canon:
        canon_path = Path(args.canon)
        if not canon_path.exists():
            print(f"Canon file not found: {canon_path}", file=sys.stderr)
            return 2
        canon_css = read_text(canon_path)
        canon_css = normalize_layer_order_line(canon_css)
        canon_blocks = extract_all_layer_blocks(canon_css)

        # Remove existing core blocks then insert canonical ones
        stripped = remove_all_layer_blocks(target_css)
        target_css = insert_core_layers(stripped, canon_blocks)

    # Ensure layer order line is normalized (even if no canon)
    target_css = normalize_layer_order_line(target_css)

    # Compute missing selectors and inject into ff.utilities
    missing_classes, missing_ids = build_autogen_selectors(used, target_css)
    autogen_block = render_autogen_block(missing_classes, missing_ids)
    target_css = inject_into_utilities_layer(target_css, autogen_block)

    new_sha = sha256_text(target_css)

    # Report
    print("=== FF CSS Refresh ===")
    print(f"HTML files scanned: {len(html_files)}")
    print(f"Used classes: {len(used.used_classes)}")
    print(f"Used ids:     {len(used.used_ids)}")
    print(f"Missing classes (before inject): {len(missing_classes)}")
    print(f"Missing ids (before inject):     {len(missing_ids)}")
    print(f"Original sha256: {orig_sha}")
    print(f"New sha256:      {new_sha}")

    if not args.write:
        print("\n(dry-run) No files written. Re-run with --write to apply.")
        print("\nSuggested QA:")
        print(f'  rg -n "{re.escape(LAYER_ORDER_LINE)}" {css_path}')
        print(f'  rg -n "^@layer ff\\." {css_path}')
        print(f'  rg -n "\\:target|data-open=\\"true\\"|aria-hidden=\\"false\\"|\\.is-open" {css_path}')
        print(f'  rg -n "\\.ff-btn--primary|\\.ff-tab--cta" {css_path}')
        print(f'  rg -n "html\\[data-theme=\\"dark\\"\\]" {css_path}')
        print(f'  rg -n -- "--ff-card:|--ff-card-2:" {css_path}')
        return 0

    # Write with backup
    bak = backup_file(css_path, Path(args.backup_dir))
    write_text(css_path, target_css)
    print(f"\nBackup created: {bak}")
    print(f"Wrote: {css_path}")
    print("\nSuggested QA:")
    print(f'  rg -n "{re.escape(LAYER_ORDER_LINE)}" {css_path}')
    print(f'  rg -n "^@layer ff\\." {css_path}')
    print(f'  rg -n "\\:target|data-open=\\"true\\"|aria-hidden=\\"false\\"|\\.is-open" {css_path}')
    print(f'  rg -n "\\.ff-btn--primary|\\.ff-tab--cta" {css_path}')
    print(f'  rg -n "html\\[data-theme=\\"dark\\"\\]" {css_path}')
    print(f'  rg -n -- "--ff-card:|--ff-card-2:" {css_path}')
    return 0

if __name__ == "__main__":
    raise SystemExit(main())

