#!/usr/bin/env python3
"""
Stripe-only Payments blueprint (drop-in, contract-tight)

Mount: /payments

Endpoints:
  GET  /payments/health
  GET  /payments/config
  GET  /payments/donations/<int:donation_id>
  POST /payments/stripe/intent
  POST /payments/stripe/webhook

Contract:
- Request accepts: amount_cents, currency, donor{name,email}, coverFees/cover_fees, roundUp/round_up, anonymous, message/note
- Response includes: ok, donation_id, id, status, client_secret, publishable_key, mode
  + back-compat: clientSecret, publishableKey
"""

from __future__ import annotations

import hashlib
import json
import os
from dataclasses import dataclass
from datetime import datetime, timezone
from decimal import Decimal, ROUND_HALF_UP
from typing import Any, Dict, Optional, Tuple, cast

import stripe
from flask import Blueprint, current_app, jsonify, request
from sqlalchemy.exc import IntegrityError

from app.extensions import db
from app.models import Donation, Org
from app.models.stripe_event import StripeEvent

bp = Blueprint("payments", __name__)

# CSRF exempt (API-style JSON)
try:
    from app.extensions import csrf  # type: ignore

    if csrf:
        csrf.exempt(bp)  # type: ignore[attr-defined]
except Exception:
    pass


# ----------------------------
# Small utilities
# ----------------------------
def _cfg(key: str, default: str = "") -> str:
    v = current_app.config.get(key)
    if isinstance(v, str) and v.strip():
        return v.strip()
    resp = (os.getenv(key, default) or "").strip()
    # --- FF schema normalization (hotfix v3) ---
    try:
        _d = resp
        if isinstance(_d, dict):
            _d['clientSecret'] = _d.get('clientSecret') or _d.get('client_secret')
            _d['publishableKey'] = _d.get('publishableKey') or _d.get('publishable_key')
            _d['donationId'] = _d.get('donationId') or _d.get('donation_id')
            _d['amountCents'] = _d.get('amountCents') or _d.get('amount_cents')
            _d['feeCents'] = _d.get('feeCents') or _d.get('fee_cents')
            for _k in ('client_secret','publishable_key','donation_id','amount_cents','fee_cents'):
                _d.pop(_k, None)
    except Exception:
        pass
    # --- /FF schema normalization (hotfix v3) ---
    return resp


def _cfg_bool(key: str, default: bool = False) -> bool:
    v = current_app.config.get(key)
    if isinstance(v, bool):
        return v
    raw = (os.getenv(key, "") or "").strip()
    if not raw:
        return default
    return raw.lower() in {"1", "true", "yes", "on"}


def _json_ok(payload: Dict[str, Any], status: int = 200):
    payload.setdefault("ok", True)
    return jsonify(payload), status


def _json_error(message: str, status: int, extra: Optional[Dict[str, Any]] = None):
    # Keep stable shape: error is an object with message; also include top-level message for convenience
    body: Dict[str, Any] = {"ok": False, "message": message, "error": {"message": message}}
    if extra:
        body["error"].update(extra)
        # Also flatten useful extras where prior versions returned strings
        for k, v in extra.items():
            if k not in body:
                body[k] = v
    return jsonify(body), status


def _request_payload() -> Dict[str, Any]:
    data = request.get_json(silent=True)
    if isinstance(data, dict) and data:
        return cast(Dict[str, Any], data)
    if request.form:
        return cast(Dict[str, Any], request.form.to_dict(flat=True))
    return {}


def _truthy(v: Any) -> bool:
    if isinstance(v, bool):
        return v
    if v is None:
        return False
    s = str(v).strip().lower()
    return s in {"1", "true", "yes", "on", "y"}


def _is_email(s: str) -> bool:
    s = (s or "").strip()
    return ("@" in s) and ("." in s.split("@")[-1])


def _safe_currency(raw: Any, default: str = "usd") -> str:
    c = str(raw or "").lower().strip()
    if len(c) == 3 and c.isalpha():
        return c
    return default


def _iso(dt: Optional[datetime]) -> Optional[str]:
    return dt.isoformat() if dt else None


def _tx_commit():
    try:
        db.session.commit()
    except Exception:
        db.session.rollback()
        raise


# ----------------------------
# Fee + rounding math
# ----------------------------
def _round_up_add_cents(base_cents: int, step_dollars: int = 5) -> int:
    """
    Adds cents needed to round the total up to the next step (default: $5).
    Example: base 7300 -> next 7500 => add 200.
    """
    if base_cents <= 0:
        return 0
    step_cents = max(100, step_dollars * 100)
    next_cents = ((base_cents + step_cents - 1) // step_cents) * step_cents
    return max(0, next_cents - base_cents)


def _gross_up_cover_fees(base_cents: int, fee_pct: Decimal, fee_flat: Decimal) -> Tuple[int, int]:
    """
    Gross-up amount so donor covers fees.
    Returns (total_cents, fee_cents).
    """
    if base_cents <= 0:
        return (base_cents, 0)

    base = (Decimal(base_cents) / Decimal("100"))
    total = (base + fee_flat) / (Decimal("1") - fee_pct)
    total = total.quantize(Decimal("0.01"), rounding=ROUND_HALF_UP)
    fee = (total - base).quantize(Decimal("0.01"), rounding=ROUND_HALF_UP)

    total_cents = int((total * Decimal("100")).quantize(Decimal("1"), rounding=ROUND_HALF_UP))
    fee_cents = int((fee * Decimal("100")).quantize(Decimal("1"), rounding=ROUND_HALF_UP))
    return (total_cents, fee_cents)


# ----------------------------
# Settings
# ----------------------------
@dataclass(frozen=True)
class Settings:
    env: str
    platform: str
    currency: str
    min_amount_cents: int
    max_amount_cents: int

    # fees
    fees_enabled: bool
    fee_pct: Decimal
    fee_flat: Decimal

    # stripe
    stripe_sk: str
    stripe_pk: str
    stripe_whsec: str
    stripe_force_card: bool
    stripe_allow_redirects: bool
    stripe_max_network_retries: int

    @property
    def stripe_mode(self) -> str:
        k = (self.stripe_sk or self.stripe_pk or "").strip()
        if k.startswith(("sk_live_", "pk_live_")):
            return "live"
        if k.startswith(("sk_test_", "pk_test_")):
            return "test"
        return "unknown"

    @classmethod
    def load(cls) -> "Settings":
        env = (_cfg("ENV") or os.getenv("FLASK_ENV") or os.getenv("APP_ENV") or "development").strip().lower()
        if env in {"prod", "production"}:
            env = "production"
        elif env in {"dev", "development", "local", "staging", "stage", "test", "testing"}:
            env = "development"
        else:
            env = "unknown"

        return cls(
            env=env,
            platform=(_cfg("PLATFORM_NAME") or _cfg("BRAND_NAME") or "FutureFunded").strip(),
            currency=_safe_currency(_cfg("DEFAULT_CURRENCY") or _cfg("CURRENCY") or "usd", "usd"),
            min_amount_cents=int(_cfg("MIN_DONATION_CENTS", "50") or "50"),
            max_amount_cents=int(_cfg("MAX_DONATION_CENTS", str(50_000 * 100)) or str(50_000 * 100)),
            fees_enabled=_cfg_bool("FF_FEES_ENABLED", True),
            fee_pct=Decimal(str(current_app.config.get("FF_FEES_PCT", "0.029"))),
            fee_flat=Decimal(str(current_app.config.get("FF_FEES_FLAT", "0.30"))),
            stripe_sk=_cfg("STRIPE_SECRET_KEY") or _cfg("STRIPE_API_KEY") or _cfg("FF_STRIPE_SECRET_KEY"),
            stripe_pk=_cfg("STRIPE_PUBLISHABLE_KEY") or _cfg("STRIPE_PUBLIC_KEY") or _cfg("FF_STRIPE_PUBLISHABLE_KEY"),
            stripe_whsec=_cfg("STRIPE_WEBHOOK_SECRET") or _cfg("FF_STRIPE_WEBHOOK_SECRET"),
            stripe_force_card=_cfg_bool("FF_STRIPE_FORCE_CARD", False),
            stripe_allow_redirects=_cfg_bool("FF_STRIPE_ALLOW_REDIRECTS", False),
            stripe_max_network_retries=int(_cfg("STRIPE_MAX_NETWORK_RETRIES", "2") or "2"),
        )

    def init_stripe(self) -> None:
        if not (self.stripe_sk.startswith("sk_") and self.stripe_pk.startswith("pk_")):
            raise RuntimeError("Stripe keys missing or malformed (expected sk_ / pk_)")
        stripe.api_key = self.stripe_sk
        stripe.max_network_retries = self.stripe_max_network_retries
        try:
            stripe.set_app_info(self.platform, version=_cfg("APP_VERSION", "dev"))
        except Exception:
            pass


# ----------------------------
# Normalized request model
# ----------------------------
@dataclass(frozen=True)
class Donor:
    name: str
    email: str


@dataclass(frozen=True)
class IntentRequest:
    amount_cents_raw: Any
    currency: str
    donor: Donor
    cover_fees: bool
    round_up: bool
    anonymous: bool
    note: Optional[str]
    description: str
    org_id: Optional[int]
    org_slug: str

    @classmethod
    def from_payload(cls, s: Settings, data: Dict[str, Any]) -> "IntentRequest":
        donor_obj = data.get("donor") if isinstance(data.get("donor"), dict) else {}
        donor_name = str(donor_obj.get("name") or data.get("name") or "").strip()
        donor_email = str(donor_obj.get("email") or data.get("email") or "").strip().lower()

        note = str(data.get("note") or data.get("message") or "").strip()
        note = note[:500] if note else ""
        note_out = note or None

        return cls(
            amount_cents_raw=(data.get("amount_cents") if data.get("amount_cents") is not None else data.get("amountCents")),
            currency=_safe_currency(data.get("currency") or s.currency, s.currency),
            donor=Donor(name=donor_name[:160], email=donor_email[:160]),
            cover_fees=_truthy(data.get("cover_fees") or data.get("coverFees") or False),
            round_up=_truthy(data.get("round_up") or data.get("roundUp") or False),
            anonymous=_truthy(data.get("anonymous") or data.get("is_anonymous") or False),
            note=note_out,
            description=str(data.get("description") or f"Donation via {s.platform}").strip()[:250],
            org_id=_safe_int_opt(data.get("org_id")),
            org_slug=str(data.get("org_slug") or "").strip(),
        )


def _safe_int_opt(v: Any) -> Optional[int]:
    if v is None:
        return None
    try:
        s = str(v).strip()
        if not s:
            return None
        return int(s)
    except Exception:
        return None


def _parse_amount_cents(raw: Any) -> Tuple[Optional[int], Optional[str]]:
    """
    Returns (amount_cents, error_message).
    Distinguishes missing vs invalid vs <=0.
    """
    if raw is None:
        return None, "amount_cents required"
    s = str(raw).strip()
    if not s:
        return None, "amount_cents required"
    try:
        n = int(s)
    except Exception:
        return None, "amount_cents must be an integer"
    if n <= 0:
        return None, "amount_cents must be > 0"
    return n, None


@dataclass(frozen=True)
class AmountBreakdown:
    base_cents: int
    round_up_add_cents: int
    fee_cents: int
    total_cents: int


def _compute_amounts(s: Settings, base_cents: int, cover_fees: bool, round_up: bool) -> AmountBreakdown:
    round_add = _round_up_add_cents(base_cents, step_dollars=5) if round_up else 0
    base_plus_round = base_cents + round_add

    fee_cents = 0
    total_cents = base_plus_round
    if cover_fees and s.fees_enabled:
        total_cents, fee_cents = _gross_up_cover_fees(base_plus_round, s.fee_pct, s.fee_flat)

    # clamp
    total_cents = min(int(total_cents), int(s.max_amount_cents))
    return AmountBreakdown(
        base_cents=int(base_cents),
        round_up_add_cents=int(round_add),
        fee_cents=int(fee_cents),
        total_cents=int(total_cents),
    )


# ----------------------------
# Idempotency (server-generated, contract-safe)
# ----------------------------
def _server_idempotency_key(*, donation_id: int, amount_cents: int, currency: str, cover_fees: bool, round_up: bool) -> str:
    raw = f"ff|don:{donation_id}|amt:{amount_cents}|cur:{currency}|cf:{int(cover_fees)}|ru:{int(round_up)}"
    digest = hashlib.sha256(raw.encode("utf-8")).hexdigest()[:48]
    return f"ff_pi_{digest}"


# ----------------------------
# Donation helpers
# ----------------------------
def _resolve_org(org_id: Optional[int], org_slug: str) -> Optional[Org]:
    if org_id:
        try:
            return db.session.get(Org, int(org_id))
        except Exception:
            return None
    slug = (org_slug or "").strip()
    if slug:
        try:
            return db.session.query(Org).filter(Org.slug == slug).first()
        except Exception:
            return None
    return None


def _create_donation(*, req: IntentRequest, amount_cents: int, currency: str) -> int:
    name = (req.donor.name or "").strip()
    email = (req.donor.email or "").strip().lower()
    anonymous = bool(req.anonymous)

    if email and not _is_email(email):
        raise ValueError("valid email required")

    # If user doesn't provide a name, keep UX consistent: record as Anonymous.
    if not name:
        name = "Anonymous"

    org = _resolve_org(req.org_id, req.org_slug)

    d = Donation(
        name=name[:160] if name else "Anonymous",
        email=email[:160] if email else "",
        amount_cents=int(amount_cents),
        currency=currency,
        provider="stripe",
        provider_status="pending_intent",
        note=req.note,
        org_id=(org.id if org else None),
    )
    db.session.add(d)
    db.session.flush()
    if not getattr(d, "id", None):
        raise RuntimeError("Donation id missing after insert")
    return int(d.id)


# ----------------------------
# Routes
# ----------------------------
@bp.get("/health")
def payments_health():
    s = Settings.load()
    return _json_ok(
        {
            "platform": s.platform,
            "env": s.env,
            "stripe_mode": s.stripe_mode,
            "stripe_secret_loaded": bool(s.stripe_sk and s.stripe_sk.startswith("sk_")),
            "stripe_publishable_loaded": bool(s.stripe_pk and s.stripe_pk.startswith("pk_")),
            "webhook_secret_loaded": bool(s.stripe_whsec),
        }
    )


@bp.get("/config")
def payments_config():
    s = Settings.load()
    return _json_ok(
        {
            "platform": s.platform,
            "stripe_publishable_key": s.stripe_pk,
            "publishable_key": s.stripe_pk,
            "publishableKey": s.stripe_pk,  # back-compat
            "currency": s.currency,
            "mode": s.stripe_mode,
        }
    )


@bp.get("/donations/<int:donation_id>")
def get_donation(donation_id: int):
    d = db.session.get(Donation, donation_id)
    if not d or getattr(d, "deleted", False):
        return jsonify({"ok": False, "error": {"code": 404, "message": "Donation not found"}}), 404

    pi = (getattr(d, "provider_intent_id", "") or "").strip()
    events = []
    if pi:
        events = (
            db.session.query(StripeEvent)
            .filter(StripeEvent.object_id == pi)
            .order_by(StripeEvent.id.desc())
            .limit(50)
            .all()
        )

    return jsonify(
        {
            "ok": True,
            "donation": {
                "id": d.id,
                "name": d.name,
                "email": d.email,
                "amount_cents": d.amount_cents,
                "currency": d.currency,
                "provider": d.provider,
                "provider_intent_id": d.provider_intent_id,
                "provider_status": d.provider_status,
                "paid_at": _iso(d.paid_at),
                "created_at": _iso(getattr(d, "created_at", None)),
                "updated_at": _iso(getattr(d, "updated_at", None)),
            },
            "events": [
                {
                    "id": e.id,
                    "event_id": e.event_id,
                    "type": e.type,
                    "livemode": bool(e.livemode),
                    "object_id": e.object_id,
                    "created_at": _iso(e.created_at),
                    "updated_at": _iso(e.updated_at),
                }
                for e in events
            ],
        }
    )


@bp.post("/stripe/intent")
def stripe_intent():
    s = Settings.load()
    data = _request_payload()
    req = IntentRequest.from_payload(s, data)

    # Validate amount
    amount_cents, err = _parse_amount_cents(req.amount_cents_raw)
    if err:
        return _json_error(err, 400)

    assert amount_cents is not None
    if amount_cents < s.min_amount_cents:
        return _json_error(f"Amount too small (min {s.min_amount_cents} cents)", 400)

    breakdown = _compute_amounts(
        s,
        base_cents=int(amount_cents),
        cover_fees=bool(req.cover_fees),
        round_up=bool(req.round_up),
    )

    # Create donation record first (persist even if Stripe fails, for audit/debug)
    try:
        donation_id = _create_donation(req=req, amount_cents=breakdown.total_cents, currency=req.currency)
        _tx_commit()
    except ValueError as ve:
        db.session.rollback()
        return _json_error(str(ve), 400)
    except Exception:
        db.session.rollback()
        current_app.logger.exception("payments: failed to initialize donation")
        return _json_error("Failed to initialize donation", 500)

    # Initialize Stripe
    try:
        s.init_stripe()
    except Exception as e:
        current_app.logger.error("payments: Stripe misconfigured: %s", str(e))
        return _json_error(
            f"Server misconfigured: {str(e)}",
            500,
            extra={
                "publishable_key": getattr(s, "stripe_pk", None),
                "publishableKey": getattr(s, "stripe_pk", None),
                "mode": getattr(s, "stripe_mode", None),
            },
        )

    receipt_email = req.donor.email if (req.donor.email and _is_email(req.donor.email)) else ""

    params: Dict[str, Any] = {
        "amount": int(breakdown.total_cents),
        "currency": req.currency,
        "description": req.description,
        "metadata": {
            "donation_id": str(donation_id),
            "base_amount_cents": str(int(breakdown.base_cents)),
            "round_up_add_cents": str(int(breakdown.round_up_add_cents)),
            "fee_cents": str(int(breakdown.fee_cents)),
            "cover_fees": "1" if req.cover_fees else "0",
            "round_up": "1" if req.round_up else "0",
        },
    }
    if receipt_email:
        params["receipt_email"] = receipt_email

    if s.stripe_force_card:
        params["payment_method_types"] = ["card"]
    else:
        params["automatic_payment_methods"] = {
            "enabled": True,
            "allow_redirects": "always" if s.stripe_allow_redirects else "never",
        }

    idem_key = _server_idempotency_key(
        donation_id=donation_id,
        amount_cents=int(breakdown.total_cents),
        currency=req.currency,
        cover_fees=bool(req.cover_fees),
        round_up=bool(req.round_up),
    )

    try:
        pi = stripe.PaymentIntent.create(**params, idempotency_key=idem_key)

        # Save PI info
        try:
            d = db.session.get(Donation, donation_id)
            if d:
                d.provider_intent_id = str(pi.id or "")[:255]
                d.provider_status = str(pi.status or "created")[:60]
            _tx_commit()
        except Exception:
            db.session.rollback()
            current_app.logger.exception("payments: failed updating donation with PI id/status")

        return jsonify(
            {
                "ok": True,
                "donation_id": int(donation_id),
                "id": pi.id,
                "status": pi.status,
                "client_secret": pi.client_secret,
                "clientSecret": pi.client_secret,  # back-compat
                "publishable_key": s.stripe_pk,
                "publishableKey": s.stripe_pk,  # back-compat
                "mode": s.stripe_mode,
                "amount_cents": int(breakdown.total_cents),
                "fee_cents": int(breakdown.fee_cents),
                "round_up_add_cents": int(breakdown.round_up_add_cents),
            }
        )
    except stripe.error.StripeError as e:
        msg = getattr(e, "user_message", None) or str(e)
        current_app.logger.error("payments: Stripe error creating intent: %s", msg, exc_info=True)
        try:
            d = db.session.get(Donation, donation_id)
            if d:
                d.provider_status = "intent_failed"
            _tx_commit()
        except Exception:
            db.session.rollback()
        return _json_error(
            msg,
            400,
            extra={
                "publishable_key": s.stripe_pk,
                "publishableKey": s.stripe_pk,
                "mode": s.stripe_mode,
            },
        )
    except Exception as e:
        current_app.logger.exception("payments: unexpected error creating Stripe intent")
        try:
            d = db.session.get(Donation, donation_id)
            if d:
                d.provider_status = "intent_failed"
            _tx_commit()
        except Exception:
            db.session.rollback()
        return _json_error(
            "Failed to create payment intent",
            500,
            extra={
                "exception": str(e),
                "publishable_key": s.stripe_pk,
                "publishableKey": s.stripe_pk,
                "mode": s.stripe_mode,
            },
        )


@bp.route("/stripe/webhook", methods=["POST", "OPTIONS"])
def stripe_webhook():
    if request.method == "OPTIONS":
        return ("", 200)

    s = Settings.load()
    try:
        s.init_stripe()
    except Exception:
        # avoid endless retries if running locally misconfigured
        return ("", 200)

    payload = request.get_data(cache=False, as_text=False)
    sig = (request.headers.get("Stripe-Signature") or "").strip()
    endpoint_secret = (s.stripe_whsec or os.getenv("STRIPE_WEBHOOK_SECRET") or os.getenv("STRIPE_WHSEC") or "").strip()  # FF_PATCH_WEBHOOK_SECRET_FALLBACK
    try:
        if not endpoint_secret:
            # In production, require verification.
            if s.env == "production":
                return ("", 400)
            ev = json.loads(payload.decode("utf-8"))
        else:
            event = stripe.Webhook.construct_event(payload, sig, endpoint_secret)
            ev = event.to_dict_recursive()  # type: ignore[attr-defined]
    except Exception:
        return ("", 400)

    event_id = str(ev.get("id") or "")
    etype = str(ev.get("type") or "").lower()
    livemode = bool(ev.get("livemode") or False)
    obj = ((ev.get("data") or {}).get("object")) or {}
    obj_id = str(obj.get("id") or "")[:120] if isinstance(obj, dict) else ""

    # Store event idempotently
    try:
        db.session.add(
            StripeEvent(
                event_id=event_id,
                type=etype[:120],
                livemode=livemode,
                object_id=obj_id or None,
            )
        )
        _tx_commit()
    except IntegrityError:
        db.session.rollback()
        return ("", 200)
    except Exception:
        db.session.rollback()
        return ("", 200)


    # FF_PATCH_WEBHOOK_DONATION_UPDATE_V3

    # Purpose: ensure Donation rows get updated even if ORM path fails.

    try:

        from sqlalchemy import update as sa_update  # type: ignore

        now = datetime.now(timezone.utc).replace(tzinfo=None)


        if isinstance(obj, dict):

            # 1) PaymentIntent events (authoritative for success/failure)

            if etype.startswith("payment_intent."):

                pi_id = str(obj.get("id") or "")

                status = str(obj.get("status") or "")[:60]

                md = obj.get("metadata") if isinstance(obj.get("metadata"), dict) else {}

                donation_id_raw = str((md or {}).get("donation_id") or "").strip()


                where = None

                if donation_id_raw.isdigit():

                    where = (Donation.id == int(donation_id_raw))

                elif pi_id:

                    where = (Donation.provider_intent_id == pi_id)


                if where is not None and status:

                    vals = {"provider_status": status, "updated_at": now}

                    if pi_id:

                        vals["provider_intent_id"] = pi_id[:255]

                    if status == "succeeded":

                        vals["paid_at"] = now


                    res = db.session.execute(sa_update(Donation).where(where).values(**vals))

                    if getattr(res, "rowcount", 0):

                        _tx_commit()


            # 2) Charge events (fallback): mark succeeded if paid/succeeded

            elif etype in ("charge.succeeded", "charge.updated"):

                ch_status = str(obj.get("status") or "").lower()

                ch_paid = bool(obj.get("paid") or False)

                if ch_status == "succeeded" or ch_paid:

                    pi_id = str(obj.get("payment_intent") or "")

                    if pi_id:

                        res = db.session.execute(

                            sa_update(Donation)

                            .where(Donation.provider_intent_id == pi_id)

                            .values(provider_status="succeeded", paid_at=now, updated_at=now)

                        )

                        if getattr(res, "rowcount", 0):

                            _tx_commit()


    except Exception:

        db.session.rollback()

    # Handle PI updates

    # FF_PATCH_WEBHOOK_DONATION_UPDATE_V4

    # Goal: ensure Donation gets updated on succeeded events; retry on SQLITE_BUSY/locked.

    def _ff_sqlite_busy_timeout():

        try:

            from sqlalchemy import text  # type: ignore

            # Only matters for SQLite; harmless elsewhere

            db.session.execute(text("PRAGMA busy_timeout=5000"))

        except Exception:

            pass


    def _ff_update_donation(*, where_clause, status: str, pi_id: str = "", paid: bool = False) -> bool:

        try:

            from sqlalchemy import update as sa_update  # type: ignore

            from sqlalchemy.exc import OperationalError  # type: ignore

            now = datetime.now(timezone.utc).replace(tzinfo=None)

            _ff_sqlite_busy_timeout()


            vals = {"provider_status": status[:60], "updated_at": now}

            if pi_id:

                vals["provider_intent_id"] = pi_id[:255]

            if paid:

                vals["paid_at"] = now


            # Retry a few times if SQLite is locked/busy

            for attempt in range(6):

                try:

                    res = db.session.execute(sa_update(Donation).where(where_clause).values(**vals))

                    if getattr(res, "rowcount", 0):

                        db.session.commit()

                        return True

                    db.session.rollback()

                    return False

                except OperationalError as e:

                    msg = str(e).lower()

                    db.session.rollback()

                    if ("database is locked" in msg) or ("sqlite_busy" in msg) or ("locked" in msg):

                        import time

                        time.sleep(0.05 * (attempt + 1))

                        continue

                    raise

            return False

        except Exception as e:

            try:

                db.session.rollback()

            except Exception:

                pass

            try:

                current_app.logger.exception("FF webhook donation update failed", extra={"etype": etype, "obj_id": obj_id})

            except Exception:

                pass

            return False


    # Fast-path updates (before the older ORM logic below)

    try:

        if isinstance(obj, dict):

            if etype.startswith("payment_intent."):

                pi_id = str(obj.get("id") or "")

                status = str(obj.get("status") or "")

                md = obj.get("metadata") if isinstance(obj.get("metadata"), dict) else {}

                donation_id_raw = str((md or {}).get("donation_id") or "").strip()


                if donation_id_raw.isdigit():

                    _ff_update_donation(where_clause=(Donation.id == int(donation_id_raw)),

                                       status=status, pi_id=pi_id, paid=(status == "succeeded"))

                elif pi_id:

                    _ff_update_donation(where_clause=(Donation.provider_intent_id == pi_id),

                                       status=status, pi_id=pi_id, paid=(status == "succeeded"))


            elif etype in ("charge.succeeded", "charge.updated"):

                ch_status = str(obj.get("status") or "").lower()

                ch_paid = bool(obj.get("paid") or False)

                if ch_status == "succeeded" or ch_paid:

                    pi_id = str(obj.get("payment_intent") or "")

                    if pi_id:

                        _ff_update_donation(where_clause=(Donation.provider_intent_id == pi_id),

                                           status="succeeded", pi_id=pi_id, paid=True)

    except Exception:

        # never break webhook delivery

        try:

            db.session.rollback()

        except Exception:

            pass

        try:

            current_app.logger.exception("FF webhook fast-path update crashed", extra={"etype": etype, "obj_id": obj_id})

        except Exception:

            pass

    try:
        if isinstance(obj, dict) and etype.startswith("payment_intent."):
            pi_id = str(obj.get("id") or "")
            status = str(obj.get("status") or "")[:60]
            md = obj.get("metadata") if isinstance(obj.get("metadata"), dict) else {}
            donation_id_raw = str((md or {}).get("donation_id") or "").strip()

            donation = None
            if donation_id_raw.isdigit():
                donation = db.session.get(Donation, int(donation_id_raw))
            if donation is None and pi_id:
                donation = db.session.query(Donation).filter(Donation.provider_intent_id == pi_id).first()

            if donation:
                if pi_id:
                    donation.provider_intent_id = pi_id[:255]
                if status:
                    donation.provider_status = status

                if status == "succeeded" and donation.paid_at is None:
                    donation.paid_at = datetime.now(timezone.utc).replace(tzinfo=None)

                _tx_commit()

        if isinstance(obj, dict) and etype in ("charge.succeeded", "charge.updated"):
            # FF_PATCH_CHARGE_SUCCEEDED
            # FF_PATCH_CHARGE_STATUS_GUARD
            ch_status = str(obj.get("status") or "").lower()
            ch_paid = bool(obj.get("paid") or False)
            if ch_status and ch_status != "succeeded" and not ch_paid:
                # charge.updated can fire for non-success changes; ignore those
                return ("", 200)

            pi_id = str(obj.get("payment_intent") or "")
            if pi_id:
                donation = db.session.query(Donation).filter(Donation.provider_intent_id == pi_id).first()
                if donation:
                    donation.provider_status = "succeeded"
                    if donation.paid_at is None:
                        donation.paid_at = datetime.now(timezone.utc).replace(tzinfo=None)
                    _tx_commit()

        return ("", 200)
    except Exception:
        db.session.rollback()
        return ("", 200)

