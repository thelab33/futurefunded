/*! ff-app.js — FutureFunded Flagship v14.2 (drop-in replacement)
  Contract (compat-first):
    - UI/content config from #ffConfig (application/json) ONLY
    - Org/campaign/tier/env/version from ONE [data-ff-shell] element
    - Payments/endpoints ONLY from <meta> tags (csrf/stripe/paypal/qr)
    - Exposes: window.FF.toast / buildShareUrl / setShareFields / scrollToDonate
    - Payload shaping lock (optional):
        <meta name="ff-payments-payload-shape" content="nested_donor_v1|flat_donor_v1" />
        <meta name="ff-payments-extra-json" content='{"source":"web"}' /> (or base64 JSON)

  Notes:
    - Safe if elements are missing (no hard dependency on optional sections/modals)
    - v13/v14 selector compatibility
    - Reduced-motion respectful
*/
(() => {
  "use strict";

  // Prevent double-init if included twice (v13/v14 compat)
  if (window.__FF_APP_V14_2_LOADED || window.__FF_APP_V14_LOADED || window.__FF_APP_V13_LOADED) return;
  window.__FF_APP_V14_2_LOADED = true;
  window.__FF_APP_V14_LOADED = true;
  window.__FF_APP_V13_LOADED = true;

  /* ---------------------------------------------
   * Utilities
   * -------------------------------------------*/
  const qs = (sel, root = document) => root.querySelector(sel);
  const qsa = (sel, root = document) => Array.from(root.querySelectorAll(sel));
  const on = (el, ev, fn, opt) => el && el.addEventListener(ev, fn, opt);
  const clamp = (n, a, b) => Math.min(b, Math.max(a, n));
  const safeText = (v) => (v == null ? "" : String(v));
  const toInt = (v, def = 0) => {
    const n = Number.parseInt(String(v ?? ""), 10);
    return Number.isFinite(n) ? n : def;
  };
  const toNum = (v, def = 0) => {
    const n = Number(v);
    return Number.isFinite(n) ? n : def;
  };
  const now = () => Date.now();

  const parseJSON = (txt, fallback) => {
    try {
      return JSON.parse(txt);
    } catch {
      return fallback;
    }
  };

  const decodeMaybeBase64Json = (txt, fallback) => {
    const s = safeText(txt).trim();
    if (!s) return fallback;
    if (s.startsWith("{") || s.startsWith("[")) return parseJSON(s, fallback);
    try {
      const decoded = atob(s);
      return parseJSON(decoded, fallback);
    } catch {
      return fallback;
    }
  };

  const debounce = (fn, ms = 150) => {
    let t = null;
    return (...args) => {
      clearTimeout(t);
      t = setTimeout(() => fn(...args), ms);
    };
  };

  const escapeHTML = (s) =>
    safeText(s).replace(/[&<>"']/g, (m) => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }[m]));

  // Allow only safe URL protocols for outbound links
  const safeUrl = (raw) => {
    const s = safeText(raw).trim();
    if (!s) return "";
    try {
      const u = new URL(s, window.location.origin);
      const p = (u.protocol || "").toLowerCase();
      if (p === "http:" || p === "https:" || p === "mailto:" || p === "tel:") return u.toString();
      return "";
    } catch {
      return "";
    }
  };

  const setHidden = (el, v) => {
    if (!el) return;
    el.hidden = !!v;
    el.setAttribute("aria-hidden", v ? "true" : "false");
  };

  const setAriaPressed = (el, v) => el && el.setAttribute("aria-pressed", v ? "true" : "false");

  const parseMoneyToCents = (raw) => {
    const s = safeText(raw).trim();
    if (!s) return 0;
    const cleaned = s.replace(/[^\d.]/g, "");
    if (!cleaned) return 0;
    const parts = cleaned.split(".");
    const whole = parts[0] || "0";
    const frac = (parts[1] || "").slice(0, 2).padEnd(2, "0");
    const cents = toInt(whole, 0) * 100 + toInt(frac, 0);
    return Math.max(0, cents);
  };

  const formatCurrency = (cents, currency = "USD", locale = "en-US", exact = false) => {
    const n = (toNum(cents, 0) / 100) || 0;
    try {
      return new Intl.NumberFormat(locale, {
        style: "currency",
        currency,
        minimumFractionDigits: exact ? 2 : 0,
        maximumFractionDigits: exact ? 2 : 0,
      }).format(n);
    } catch {
      return `$${exact ? n.toFixed(2) : Math.round(n).toLocaleString("en-US")}`;
    }
  };

  const parseISO = (iso) => {
    if (!iso) return null;
    const d = new Date(iso);
    return Number.isFinite(d.getTime()) ? d : null;
  };

  const humanCountdown = (ms) => {
    const s = Math.max(0, Math.floor(ms / 1000));
    const d = Math.floor(s / 86400);
    const h = Math.floor((s % 86400) / 3600);
    const m = Math.floor((s % 3600) / 60);
    if (d >= 7) return `${d}d`;
    if (d > 0) return `${d}d ${h}h`;
    if (h > 0) return `${h}h ${m}m`;
    if (m > 0) return `${m}m`;
    return "soon";
  };

  const deepMerge = (a, b) => {
    if (!b || typeof b !== "object") return a;
    const out = Array.isArray(a) ? [...a] : { ...(a || {}) };
    for (const [k, v] of Object.entries(b)) {
      if (v && typeof v === "object" && !Array.isArray(v) && out[k] && typeof out[k] === "object" && !Array.isArray(out[k])) {
        out[k] = deepMerge(out[k], v);
      } else {
        out[k] = v;
      }
    }
    return out;
  };

  const prefersReducedMotion = () => {
    try {
      return window.matchMedia && window.matchMedia("(prefers-reduced-motion: reduce)").matches;
    } catch {
      return false;
    }
  };

  const fetchJson = async (url, { method = "GET", headers = {}, body = null, credentials = "same-origin" } = {}) => {
    const res = await fetch(url, { method, headers, body, credentials });
    const data = await res.json().catch(() => ({}));
    if (!res.ok) throw new Error(data?.error || data?.message || `HTTP ${res.status}`);
    return data;
  };

  const cssEscape = (s) => {
    if (window.CSS && typeof window.CSS.escape === "function") return window.CSS.escape(s);
    return safeText(s).replace(/[^a-zA-Z0-9_\-]/g, "\\$&");
  };

  const copyToClipboard = async (txt) => {
    const s = safeText(txt);
    try {
      if (navigator.clipboard && navigator.clipboard.writeText) {
        await navigator.clipboard.writeText(s);
        return true;
      }
    } catch {}
    try {
      const ta = document.createElement("textarea");
      ta.value = s;
      ta.style.position = "fixed";
      ta.style.opacity = "0";
      document.body.appendChild(ta);
      ta.focus();
      ta.select();
      const ok = document.execCommand("copy");
      document.body.removeChild(ta);
      return !!ok;
    } catch {
      return false;
    }
  };

  /* ---------------------------------------------
   * Meta tags (payments/endpoints only)
   * -------------------------------------------*/
  const meta = (name) => (qs(`meta[name="${name}"]`)?.content || "").trim();

  const captureMode = document.documentElement.getAttribute("data-ff-capture") === "true";
  const csrfToken = meta("ff-csrf-token") || meta("csrf-token") || "";

  const stripePk = meta("ff-stripe-pk");
  const stripeJsSrc = meta("ff-stripe-js") || "https://js.stripe.com/v3/";
  const stripeIntentEndpoint = meta("ff-stripe-intent-endpoint") || meta("ff-checkout-endpoint") || "/payments/stripe/intent";
  const stripeReturnUrl = meta("ff-stripe-return-url") || window.location.href;
  const stripeThemeMeta = meta("ff-stripe-theme") || "";

  const paypalClientId = meta("ff-paypal-client-id");
  const paypalCurrency = meta("ff-paypal-currency") || "USD";
  const paypalIntent = meta("ff-paypal-intent") || "capture";
  const paypalCreateEndpoint = meta("ff-paypal-create-endpoint") || "/payments/paypal/order";
  const paypalCaptureEndpoint = meta("ff-paypal-capture-endpoint") || "/payments/paypal/capture";

  const qrEndpoint = meta("ff-qr-endpoint") || "https://api.qrserver.com/v1/create-qr-code/";

  // Optional payload lock (to match payments.py exactly)
  const payloadShape = meta("ff-payments-payload-shape") || "nested_donor_v1";
  const payloadExtra = decodeMaybeBase64Json(meta("ff-payments-extra-json") || "", {});

  /* ---------------------------------------------
   * Shell env (from [data-ff-shell])
   * -------------------------------------------*/
  const pickShellEl = () => {
    const els = qsa("[data-ff-shell]");
    if (!els.length) return null;
    let best = els[0];
    let bestScore = -1;
    for (const el of els) {
      const d = el.dataset || {};
      const score =
        (d.ffOrg ? 1 : 0) +
        (d.ffCampaign ? 1 : 0) +
        (d.ffTier ? 1 : 0) +
        (d.ffEnv ? 1 : 0) +
        (d.ffVersion ? 1 : 0) +
        (d.ffEmbed ? 1 : 0) +
        (d.ffWhitelabel ? 1 : 0) +
        (d.ffPage ? 1 : 0);
      if (score > bestScore) {
        bestScore = score;
        best = el;
      }
    }
    return best;
  };

  const shellEl = pickShellEl();
  const shellEnv = {
    orgId: safeText(shellEl?.dataset?.ffOrg || "default"),
    campaignId: safeText(shellEl?.dataset?.ffCampaign || "season"),
    tier: safeText(shellEl?.dataset?.ffTier || "standard"),
    env: safeText(shellEl?.dataset?.ffEnv || "prod"),
    version: safeText(shellEl?.dataset?.ffVersion || "14.2.0"),
    embed: safeText(shellEl?.dataset?.ffEmbed || "false") === "true",
    whiteLabel: safeText(shellEl?.dataset?.ffWhitelabel || "false") === "true",
    page: safeText(shellEl?.dataset?.ffPage || "fundraiser"),
  };

  /* ---------------------------------------------
   * Config (UI/content only) from #ffConfig
   * -------------------------------------------*/
  const readConfigFromScript = () => {
    const scripts = qsa('script#ffConfig[type="application/json"]');
    if (!scripts.length) return {};
    for (let i = scripts.length - 1; i >= 0; i--) {
      const raw = (scripts[i].textContent || "").trim();
      if (!raw) continue;
      const parsed = parseJSON(raw, null);
      if (parsed && typeof parsed === "object") return parsed;
    }
    return {};
  };

  const DEFAULTS = {
    org: {
      name: "Organization",
      meta: "City • State",
      seasonPill: "Season Fund",
      sportPill: "Youth program",
      heroAccentLine: "Keep kids playing.",
      footerTagline: "Fuel the season. Fund the future.",
      announcement: "",
    },
    fundraiser: {
      goalAmount: 25000,
      raisedAmount: null,
      deadlineISO: "",
      updatedISO: "",
      allocationUpdatedISO: "",
      match: null,
      allocation: [
        { label: "Gym time + training", pct: 35 },
        { label: "Tournaments + fees", pct: 30 },
        { label: "Travel support", pct: 25 },
        { label: "Scholarships", pct: 10 },
      ],
      impact: [
        { id: "gear_uniforms", cat: "gear", title: "Uniform set", desc: "Jerseys + shorts for a player", amount: 150 },
        { id: "travel_gas", cat: "travel", title: "Travel fuel", desc: "Gas for tournament weekend", amount: 75 },
        { id: "fees_entry", cat: "fees", title: "Entry fee help", desc: "Support tournament entry", amount: 250 },
        { id: "scholarship_partial", cat: "scholarship", title: "Scholarship assist", desc: "Support a family in need", amount: 200 },
      ],
      sponsorTiers: [
        { id: "bronze", title: "Bronze Sponsor", amount: 250, perk: "Name listed + wall placement" },
        { id: "silver", title: "Silver Sponsor", amount: 500, perk: "Logo wall + leaderboard" },
        { id: "gold", title: "Gold Sponsor", amount: 1000, perk: "Top leaderboard + proof kit" },
        { id: "platinum", title: "Platinum Sponsor", amount: 2500, perk: "Match option + spotlight" },
      ],
      sponsors: [],
      recentGifts: [],
      popularAmountCents: 7500,
      fees: {
        enabledCoverFees: true,
        percent: 0.029,
        fixedCents: 30,
        maxCents: 0,
      },
    },
    teams: [],
    gallery: { enabled: false, items: [] },
    flagship: {
      features: {
        shareAttribution: true,
        monthlyGivingPlaceholder: true,
        gallery: true,
      },
      defaults: { currency: "USD", locale: "en-US", timezone: "America/Chicago" },
      analytics: { utm: { enabled: true, sourceParam: "src", campaignParam: "cmp" } },
      accessibility: { reducedMotionRespect: true, focusRestore: true, ariaLiveToasts: true },
    },
  };

  const C = deepMerge(DEFAULTS, readConfigFromScript() || {});
  const locale = safeText(C?.flagship?.defaults?.locale || "en-US");
  const currency = safeText(C?.flagship?.defaults?.currency || "USD");

  /* ---------------------------------------------
   * DOM cache (IDs + data-ff-* hooks)
   * -------------------------------------------*/
  const ensureToastsHost = () => {
    let host = qs("[data-ff-toasts]");
    if (host) return host;
    // if markup omits it, create one to keep toast API working
    host = document.createElement("div");
    host.className = "ff-toasts";
    host.setAttribute("data-ff-toasts", "true");
    document.body.appendChild(host);
    return host;
  };

  const cacheDom = () => ({
    // Branding
    orgName: qs("#orgName"),
    orgMeta: qs("#orgMeta"),
    footerOrgName: qs("#footerOrgName"),
    footerOrgMeta: qs("#footerOrgMeta"),
    seasonPill: qs("#seasonPill"),
    sportPill: qs("#sportPill"),
    heroAccentLine: qs("#heroAccentLine"),
    heroOrgLine: qs("#heroOrgLine"),

    // Topbar
    topbar: qs("[data-ff-topbar], #ffTopbar"),
    topbarRaised: qs("#topbarRaised"),
    topbarGoal: qs("#topbarGoal"),
    topbarDeadline: qs("#topbarDeadline"),
    topbarCountdown: qs("#topbarCountdown"),
    topbarMatchStrip: qs("[data-ff-match-strip]"),
    topbarMatchText: qs("#topbarMatchText"),
    topbarMatchRemaining: qs("#topbarMatchRemaining"),
    topbarDismiss: qs("[data-ff-topbar-dismiss]"),

    // Hero countdown + optional event pill
    heroCountdown: qs("#heroCountdown"),
    heroEventPill: qs("#heroEventPill, [data-ff-event-pill]"),

    // Progress
    raisedBig: qs("#raisedBig"),
    remainingText: qs("#remainingText"),
    deadlineText: qs("#deadlineText"),
    lastUpdatedText: qs("#lastUpdatedText"),
    goalPill: qs("#goalPill"),
    raisedRow: qs("#raisedRow"),
    goalRow: qs("#goalRow"),
    pctText: qs("#pctText"),
    overallBar: qs("#overallBar"),
    scrollProgressBar: qs("#scrollProgressBar"),

    // KPIs
    donorCount: qs("#donorCount"),
    avgGift: qs("#avgGift"),
    topGift: qs("#topGift"),

    // Match
    heroMatchPill: qs("#heroMatchPill"),
    matchDetailRow: qs("[data-ff-match-details]"),
    matchRemainingPill: qs("#matchRemainingPill"),
    matchEndsPill: qs("#matchEndsPill"),
    matchStatus: qs("#matchStatus"),
    sponsorMatchPill: qs("[data-ff-sponsor-match-pill]"),
    matchCallout: qs("[data-ff-match-callout]"),
    matchCalloutText: qs("[data-ff-match-callout-text]"),

    // Announcement
    announce: qs("[data-ff-announcement]"),
    announcementText: qs("#announcementText"),
    announceDismiss: qs("[data-ff-announcement-dismiss]"),

    // Share + QR
    shareLink: qs("#shareLink"),
    shareCopyBtns: qsa("[data-ff-copy-link], [data-ff-copy-share]"),
    shareNativeBtns: qsa("[data-ff-native-share]"),
    shareOpenBtns: qsa("[data-ff-share-open]"),
    qrImgs: qsa("[data-ff-qr]"),
    downloadQrBtns: qsa("[data-ff-download-qr]"),

    // Allocation
    allocationList: qs("[data-ff-allocation-list]"),
    allocationUpdated: qs("[data-ff-allocation-updated]"),
    allocationUpdatedText: qs("[data-ff-allocation-updated-text]"),

    // Impact
    impactGrid: qs("[data-ff-impact-grid]"),
    impactEmpty: qs("[data-ff-impact-empty]"),
    impactSearch: qs("[data-ff-impact-search]"),
    impactFilterBtns: qsa("[data-ff-impact-filter]"),

    // Sponsors
    sponsorTiersHost: qs("[data-ff-sponsor-tiers]"),
    sponsorPodium: qs("[data-ff-sponsor-podium]"),
    sponsorList: qs("[data-ff-sponsor-leaderboard]"),
    sponsorSortBtns: qsa("[data-ff-sponsor-sort] [data-ff-sort]"),
    sponsorWall: qs("[data-ff-sponsor-wall]"),
    sponsorWallViewBtns: qsa("[data-ff-sponsor-wall-view] [data-ff-wall]"),
    refreshSponsorsBtn: qs("[data-ff-refresh-sponsors]"),

    // Teams
    teamsGrid: qs("[data-ff-teams-grid], #teamsGrid"),
    teamsStatus: qs("[data-ff-teams-status]"),
    teamSearch: qs("[data-ff-team-search]"),
    teamSortBtns: qsa("[data-ff-team-sort] [data-ff-sort]"),
    attribBox: qs("[data-ff-attrib-box]"),
    attribTitle: qs("[data-ff-attrib-title]"),
    attribHelp: qs("[data-ff-attrib-help]"),
    attribClearBtns: qsa("[data-ff-attrib-clear]"),
    summaryTeamRow: qs("#summaryTeamRow"),
    summaryTeam: qs("#summaryTeam"),

    // Donate
    donationForm: qs("#donationForm"),
    amount: qs("#amount"),
    email: qs("#email"),
    fullName: qs("#fullName"),
    message: qs("#message"),
    anonymous: qs("#anonymous"),
    coverFees: qs("#coverFees"),
    payBtn: qs("#payBtn"),
    payError: qs("#payError"),
    payErrorText: qs("#payErrorText"),
    paySuccess: qs("#paySuccess"),
    paySuccessText: qs("#paySuccessText"),
    summaryAmount: qs("#summaryAmount"),
    summaryFees: qs("#summaryFees"),
    summaryTotal: qs("#summaryTotal"),
    receiptEmail: qs("#receiptEmail"),
    checkoutStatusText: qs("#checkoutStatusText"),
    checkoutMethodPill: qs("[data-ff-payment-method]"),
    checkoutMethodText: qs("#checkoutMethodText"),
    stripeMount: qs("#stripeMount"),
    paymentElementHost: qs("[data-ff-stripe-element], #stripeElement, #stripeMount [data-ff-stripe-element]"),
    paypalMount: qs("#paypalMount"),
    paypalButtonsHost: qs("[data-ff-paypal-buttons], #paypalButtons, #paypalButtonsHost"),
    paymentLive: qs("[data-ff-payment-live]"),

    // Recognition
    recognitionBtns: qsa("[data-ff-recognition]"),
    recognitionPreviewText: qs("#recognitionPreviewText"),

    // Chips / Prefills
    quickAmountBtns: qsa("[data-ff-quick-amount], [data-quick-amount]"),
    clearAmountBtn: qs("[data-ff-clear-amount]"),
    popularAmountPill: qs("[data-ff-popular-amount]"),
    popularAmountText: qs("#popularAmountText"),
    sponsorCtas: qsa("[data-ff-sponsor-cta]"),
    prefills: qsa("[data-ff-prefill]"),

    // Recent gifts
    recentGiftsHost: qs("[data-ff-recent-gifts]"),
    refreshBtns: qsa("[data-ff-refresh]"),

    // Nav / Back to top
    backToTopBtn: qs(".ff-backtotop, [data-ff-backtotop], #backToTop"),
    tabLinks: qsa('[data-ff-tab][href^="#"]'),
    anchorLinks: qsa('a[href^="#"]:not([href="#"])'),

    // Toast host
    toasts: ensureToastsHost(),

    // v14 UI controls
    themeToggle: qs("[data-ff-theme-toggle]"),
    drawer: qs("[data-ff-drawer], #mobileDrawer"),
    drawerPanel: qs("[data-ff-drawer-panel]"),
    drawerOpenBtns: qsa("[data-ff-drawer-open]"),
    drawerCloseBtns: qsa("[data-ff-drawer-close]"),

    proofOpenBtns: qsa("[data-ff-proof-open]"),
    policyOpenBtns: qsa("[data-ff-policy-open]"),

    // Gallery mounts
    galleryGrid: qs("[data-ff-gallery-grid]"),
    galleryAll: qs("[data-ff-gallery-all]"),
    galleryOpenBtns: qsa("[data-ff-gallery-open]"),
    galleryModal: qs("#ffGalleryModal, [data-ff-modal='gallery'], [data-ff-gallery-modal]"),

    // Sticky support bar
    stickySupport: qs('[data-ff-sticky="support"], .ff-sticky, #ffStickySupport'),
  });

  let D = cacheDom();

  /* ---------------------------------------------
   * Toasts
   * -------------------------------------------*/
  const toast = (msg, kind = "info") => {
    if (captureMode) return;
    D = D || cacheDom();
    const host = D.toasts;
    if (!host) return;

    const ariaLive = C?.flagship?.accessibility?.ariaLiveToasts !== false;

    const t = document.createElement("div");
    t.className = `ff-toast ff-toast--${kind}`;
    t.setAttribute("role", "status");
    if (ariaLive) t.setAttribute("aria-live", "polite");
    t.style.opacity = "0";
    t.style.transform = "translateY(6px)";
    t.innerHTML = `<div class="ff-kicker">${escapeHTML(kind)}</div><div class="ff-help">${escapeHTML(msg)}</div>`;
    host.appendChild(t);

    requestAnimationFrame(() => {
      t.style.opacity = "1";
      t.style.transform = "translateY(0)";
    });

    setTimeout(() => {
      t.style.opacity = "0";
      t.style.transform = "translateY(-2px)";
    }, 2400);

    setTimeout(() => {
      try {
        host.removeChild(t);
      } catch {}
    }, 2900);
  };

  /* ---------------------------------------------
   * State
   * -------------------------------------------*/
  const S = {
    org: {
      name: safeText(C.org?.name),
      meta: safeText(C.org?.meta),
      seasonPill: safeText(C.org?.seasonPill),
      sportPill: safeText(C.org?.sportPill),
      heroAccentLine: safeText(C.org?.heroAccentLine),
      footerTagline: safeText(C.org?.footerTagline),
    },
    fundraiser: {
      goalCents: toInt(C.fundraiser?.goalAmount, 0) * 100,
      deadlineISO: safeText(C.fundraiser?.deadlineISO || ""),
      updatedISO: safeText(C.fundraiser?.updatedISO || ""),
      allocationUpdatedISO: safeText(C.fundraiser?.allocationUpdatedISO || ""),
      match: C.fundraiser?.match || null,
      allocation: Array.isArray(C.fundraiser?.allocation) ? C.fundraiser.allocation : DEFAULTS.fundraiser.allocation,
      impact: Array.isArray(C.fundraiser?.impact) ? C.fundraiser.impact : DEFAULTS.fundraiser.impact,
      sponsorTiers: Array.isArray(C.fundraiser?.sponsorTiers) ? C.fundraiser.sponsorTiers : DEFAULTS.fundraiser.sponsorTiers,
      sponsors: Array.isArray(C.fundraiser?.sponsors) ? C.fundraiser.sponsors : [],
      recentGifts: Array.isArray(C.fundraiser?.recentGifts) ? C.fundraiser.recentGifts : [],
      popularAmountCents: toInt(C.fundraiser?.popularAmountCents, DEFAULTS.fundraiser.popularAmountCents),
      fees: deepMerge(DEFAULTS.fundraiser.fees, C.fundraiser?.fees || {}),
      raisedCents: 0,
    },
    teams: Array.isArray(C.teams) ? C.teams.slice() : [],
    gallery: deepMerge(DEFAULTS.gallery, C.gallery || {}),
    ui: {
      impactFilter: "all",
      impactQuery: "",
      sponsorSort: "rank",
      sponsorWall: "logos",
      teamSort: "featured",
      teamQuery: "",
      selectedTeamId: "",
      selectedTeamName: "",
      purpose: "donation",
      sku: "",
      impactId: "",
      giftType: "one-time",
      recognition: "public",
      amountCents: 0,
      coverFees: false,

      stripe: null,
      elements: null,
      paymentElement: null,
      clientSecret: "",
      stripeMounted: false,
      stripeReadyToPay: false,
      stripeBusy: false,

      paypalReady: false,

      __stripeKey: "",
      __lastActiveEl: null,
      __activeModal: null,
    },
    utm: {},
  };

  /* ---------------------------------------------
   * Normalize helpers
   * -------------------------------------------*/
  const normalizeTeams = () => {
    const raw = Array.isArray(S.teams) ? S.teams : [];
    return raw
      .filter((t) => t && t.id && t.name)
      .map((t) => {
        const goal = toInt(t.goal, 0) * 100;
        const raised = toInt(t.raised, 0) * 100;
        const pct = goal > 0 ? clamp(Math.round((raised / goal) * 100), 0, 999) : 0;
        return {
          id: safeText(t.id),
          name: safeText(t.name),
          meta: safeText(t.meta || ""),
          goalCents: goal,
          raisedCents: raised,
          pct,
          featured: !!t.featured,
          needs: !!t.needs,
          restricted: !!t.restricted,
          photo: safeText(t.photo || ""),
          ask: safeText(t.ask || ""),
          ts: parseISO(t.tsISO || t.timestamp || "")?.getTime() || 0,
        };
      });
  };

  const normalizeImpactList = () => {
    const impactCats = new Set(["gear", "travel", "fees", "scholarship"]);
    const items = Array.isArray(S.fundraiser.impact) ? S.fundraiser.impact : [];
    return items
      .filter((x) => x && x.id && x.title)
      .map((x) => ({
        id: safeText(x.id),
        cat: impactCats.has(safeText(x.cat)) ? safeText(x.cat) : "gear",
        title: safeText(x.title),
        desc: safeText(x.desc || ""),
        amountCents: toInt(x.amountCents ?? (toInt(x.amount, 0) * 100), 0),
      }));
  };

  const normalizeSponsors = () => {
    const raw = Array.isArray(S.fundraiser.sponsors) ? S.fundraiser.sponsors : [];
    return raw
      .map((s) => ({
        name: safeText(s.name || "Sponsor"),
        amountCents: toInt(s.amountCents ?? (toInt(s.amount, 0) * 100), 0),
        logo: safeText(s.logo || ""),
        url: safeUrl(s.url || ""),
        ts: parseISO(s.tsISO || s.timestamp || "")?.getTime() || 0,
      }))
      .filter((x) => x.amountCents > 0)
      .sort((a, b) => b.amountCents - a.amountCents);
  };

  const normalizeGifts = () => {
    const raw = Array.isArray(S.fundraiser.recentGifts) ? S.fundraiser.recentGifts : [];
    return raw
      .map((g) => ({
        name: safeText(g.name || "Supporter"),
        anon: !!g.anon || !!g.anonymous,
        amountCents: toInt(g.amountCents ?? (toInt(g.amount, 0) * 100), 0),
        ts: parseISO(g.tsISO || g.timestamp || "")?.getTime() || 0,
      }))
      .filter((x) => x.amountCents > 0)
      .sort((a, b) => (b.ts || 0) - (a.ts || 0))
      .slice(0, 8);
  };

  /* ---------------------------------------------
   * Attribution / UTM
   * -------------------------------------------*/
  const setSelectedTeam = (teamId, { silent } = { silent: false }) => {
    D = cacheDom();

    const id = safeText(teamId || "");
    S.ui.selectedTeamId = id;

    const team = normalizeTeams().find((t) => t.id === id);
    S.ui.selectedTeamName = team ? team.name : "";

    const has = !!S.ui.selectedTeamId;
    if (D.attribBox) setHidden(D.attribBox, !has);
    if (D.attribTitle) D.attribTitle.textContent = "Supporting a team";
    if (D.attribHelp) D.attribHelp.textContent = has ? `This donation will credit ${S.ui.selectedTeamName}.` : "This donation will credit the selected group.";

    if (D.summaryTeamRow) setHidden(D.summaryTeamRow, !has);
    if (D.summaryTeam) D.summaryTeam.textContent = has ? S.ui.selectedTeamName : "Team";

    setShareFields();
    renderTeams();

    if (!silent) toast(has ? `Team selected: ${S.ui.selectedTeamName}` : "Team cleared.", "info");
  };

  const setPrefill = (opts, { silent } = { silent: false }) => {
    D = cacheDom();

    const amountCents = toInt(opts?.amountCents, 0);
    const purpose = safeText(opts?.purpose || "donation");
    const sku = safeText(opts?.sku || "");
    const impactId = safeText(opts?.impactId || "");

    S.ui.amountCents = Math.max(0, amountCents);
    S.ui.purpose = purpose;
    S.ui.sku = sku;
    S.ui.impactId = impactId;

    if (D.amount) D.amount.value = amountCents > 0 ? String(Math.round(amountCents / 100)) : "";

    updateSummaryUI();
    if (!silent) toast("Prefilled.", "success");
  };

  const readUtm = () => {
    const url = new URL(window.location.href);
    const p = url.searchParams;

    const utm = {};
    for (const k of ["utm_source", "utm_medium", "utm_campaign", "utm_content", "utm_term"]) {
      if (p.has(k)) utm[k] = p.get(k) || "";
    }

    const srcParam = safeText(C?.flagship?.analytics?.utm?.sourceParam || "src");
    const cmpParam = safeText(C?.flagship?.analytics?.utm?.campaignParam || "cmp");
    if (p.has(srcParam)) utm[srcParam] = p.get(srcParam) || "";
    if (p.has(cmpParam)) utm[cmpParam] = p.get(cmpParam) || "";

    const teamId = p.get("team") || p.get("t") || "";
    if (teamId) utm.team = teamId;

    const needId = p.get("need") || "";
    if (needId) utm.need = needId;

    try {
      const ref = document.referrer || "";
      if (ref) utm.referrer = ref;
    } catch {}

    S.utm = utm;

    if (utm.team) setSelectedTeam(utm.team, { silent: true });
    if (utm.need) {
      const impact = normalizeImpactList().find((x) => x.id === utm.need);
      if (impact) setPrefill({ amountCents: impact.amountCents, purpose: "impact", impactId: impact.id }, { silent: true });
    }

    try {
      const key = `ff_attrib_${shellEnv.orgId}_${shellEnv.campaignId}`;
      localStorage.setItem(key, JSON.stringify({ ts: new Date().toISOString(), utm }));
    } catch {}
  };

  /* ---------------------------------------------
   * Share URL + QR
   * -------------------------------------------*/
  const buildShareUrl = (overrides = {}) => {
    const url = new URL(window.location.href);

    // strip Stripe redirect params
    for (const k of ["payment_intent", "payment_intent_client_secret", "redirect_status"]) url.searchParams.delete(k);

    const shareAttrib = !!C?.flagship?.features?.shareAttribution;
    if (shareAttrib && (overrides.teamId || S.ui.selectedTeamId)) {
      url.searchParams.set("team", overrides.teamId || S.ui.selectedTeamId);
    } else {
      url.searchParams.delete("team");
    }

    if (overrides.needId) url.searchParams.set("need", overrides.needId);
    else url.searchParams.delete("need");

    const srcParam = safeText(C?.flagship?.analytics?.utm?.sourceParam || "src");
    const cmpParam = safeText(C?.flagship?.analytics?.utm?.campaignParam || "cmp");
    if (S.utm[srcParam] && !url.searchParams.get(srcParam)) url.searchParams.set(srcParam, S.utm[srcParam]);
    if (S.utm[cmpParam] && !url.searchParams.get(cmpParam)) url.searchParams.set(cmpParam, S.utm[cmpParam]);

    return url.toString();
  };

  const buildQrSrc = (dataUrl, size = 180) => {
    const ep = qrEndpoint;
    if (ep.includes("?")) {
      return ep + (ep.endsWith("&") || ep.endsWith("?") ? "" : "&") + `size=${size}x${size}&data=${encodeURIComponent(dataUrl)}`;
    }
    const u = new URL(ep, window.location.origin);
    u.searchParams.set("size", `${size}x${size}`);
    u.searchParams.set("data", dataUrl);
    return u.toString();
  };

  const setShareFields = () => {
    D = cacheDom();
    const url = buildShareUrl();
    if (D.shareLink) D.shareLink.value = url;

    const src = buildQrSrc(url, 180);
    for (const img of D.qrImgs) {
      if (!img) continue;
      if (img.getAttribute("src") !== src) img.setAttribute("src", src);
    }
  };

  /* ---------------------------------------------
   * v14 Modal helper (share/policy/proof/gallery)
   * -------------------------------------------*/
  const findModal = (kind) => {
    const k = safeText(kind);
    const byId =
      qs(`#ff${k[0]?.toUpperCase() || ""}${k.slice(1)}Modal`) || // ffShareModal, ffGalleryModal
      qs(`#${k}Modal`) ||
      qs(`#ff-${k}-modal`) ||
      null;

    return byId || qs(`[data-ff-modal="${k}"]`) || qs(`[data-ff-${k}-modal]`) || null;
  };

  const getFocusable = (root) => {
    const sels = [
      "a[href]",
      "button:not([disabled])",
      "input:not([disabled])",
      "select:not([disabled])",
      "textarea:not([disabled])",
      "[tabindex]:not([tabindex='-1'])",
    ];
    return qsa(sels.join(","), root).filter((el) => !!(el.offsetWidth || el.offsetHeight || el.getClientRects().length));
  };

  const openModal = (el) => {
    if (!el || captureMode) return false;

    S.ui.__lastActiveEl = document.activeElement || null;
    S.ui.__activeModal = el;

    setHidden(el, false);
    el.setAttribute("aria-hidden", "false");

    try {
      if (el.id) qsa(`[aria-controls="${el.id}"]`).forEach((btn) => btn.setAttribute("aria-expanded", "true"));
    } catch {}

    const f = getFocusable(el)[0];
    try {
      (f || el).focus?.();
    } catch {}

    return true;
  };

  const closeModal = (el) => {
    if (!el) return;

    setHidden(el, true);
    el.setAttribute("aria-hidden", "true");

    try {
      if (el.id) qsa(`[aria-controls="${el.id}"]`).forEach((btn) => btn.setAttribute("aria-expanded", "false"));
    } catch {}

    if (C?.flagship?.accessibility?.focusRestore !== false) {
      try {
        S.ui.__lastActiveEl?.focus?.();
      } catch {}
    }

    if (S.ui.__activeModal === el) S.ui.__activeModal = null;
  };

  const bindModalCloseWiring = (modalEl) => {
    if (!modalEl || modalEl.__ffModalBound) return;
    modalEl.__ffModalBound = true;

    // backdrop + close buttons
    on(modalEl, "click", (e) => {
      const t = e.target;
      if (!t || !(t instanceof Element)) return;

      if (t.matches("[data-ff-modal-close], [data-ff-share-close], [data-ff-gallery-close], [data-ff-proof-close], [data-ff-policy-close]")) {
        e.preventDefault();
        closeModal(modalEl);
        return;
      }

      if (t.matches(".ff-modal__backdrop, .ff-drawer__backdrop, [data-ff-backdrop]")) {
        e.preventDefault();
        closeModal(modalEl);
      }
    });

    // Esc closes
    on(document, "keydown", (e) => {
      if (e.key !== "Escape") return;
      if (S.ui.__activeModal === modalEl && !modalEl.hidden) closeModal(modalEl);
    });

    // Basic focus trap while open
    on(modalEl, "keydown", (e) => {
      if (e.key !== "Tab") return;
      if (modalEl.hidden) return;

      const focusables = getFocusable(modalEl);
      if (!focusables.length) return;

      const first = focusables[0];
      const last = focusables[focusables.length - 1];
      const active = document.activeElement;

      if (e.shiftKey) {
        if (active === first || !modalEl.contains(active)) {
          e.preventDefault();
          last.focus?.();
        }
      } else {
        if (active === last) {
          e.preventDefault();
          first.focus?.();
        }
      }
    });
  };

  /* ---------------------------------------------
   * Rendering: Branding + Announcement
   * -------------------------------------------*/
  const applyBrand = () => {
    D = cacheDom();
    if (D.orgName) D.orgName.textContent = S.org.name;
    if (D.orgMeta) D.orgMeta.textContent = S.org.meta;
    if (D.footerOrgName) D.footerOrgName.textContent = S.org.name;
    if (D.footerOrgMeta) D.footerOrgMeta.textContent = S.org.meta;
    if (D.seasonPill) D.seasonPill.textContent = S.org.seasonPill;
    if (D.sportPill) D.sportPill.textContent = S.org.sportPill;
    if (D.heroAccentLine) D.heroAccentLine.textContent = S.org.heroAccentLine;
    if (D.heroOrgLine) D.heroOrgLine.textContent = `${S.org.name} • Fundraiser`;
  };

  const applyAnnouncement = () => {
    D = cacheDom();
    if (!D.announce || !D.announcementText) return;

    const ann = safeText(C?.org?.announcement || C?.fundraiser?.announcement || "");
    if (!ann) {
      setHidden(D.announce, true);
      return;
    }

    const key = `ff_announce_dismiss_${shellEnv.orgId}_${shellEnv.campaignId}`;
    try {
      if (localStorage.getItem(key)) {
        setHidden(D.announce, true);
        return;
      }
    } catch {}

    D.announcementText.textContent = ann;
    setHidden(D.announce, false);

    if (D.announceDismiss) {
      on(D.announceDismiss, "click", () => {
        setHidden(D.announce, true);
        try {
          localStorage.setItem(key, String(now()));
        } catch {}
      });
    }
  };

  /* ---------------------------------------------
   * Fundraising math + progress UI
   * -------------------------------------------*/
  const deriveRaisedCents = () => {
    const explicit = C?.fundraiser?.raisedAmount;
    if (explicit != null) return toInt(explicit, 0) * 100;

    if (Array.isArray(S.teams) && S.teams.length) {
      let sum = 0;
      for (const t of S.teams) sum += toInt(t.raised, 0) * 100;
      return sum;
    }

    let sum = 0;
    for (const s of S.fundraiser.sponsors || []) sum += toInt(s.amountCents ?? (toInt(s.amount, 0) * 100), 0);
    for (const g of S.fundraiser.recentGifts || []) sum += toInt(g.amountCents ?? (toInt(g.amount, 0) * 100), 0);
    return sum;
  };

  const applyUpdated = () => {
    D = cacheDom();
    if (!D.lastUpdatedText) return;
    const d = parseISO(S.fundraiser.updatedISO) || new Date();
    let label = "Updated — just now";
    try {
      const mins = Math.max(0, Math.round((now() - d.getTime()) / 60000));
      if (mins < 2) label = "Updated — just now";
      else if (mins < 60) label = `Updated — ${mins}m ago`;
      else {
        const hrs = Math.round(mins / 60);
        label = hrs < 24 ? `Updated — ${hrs}h ago` : `Updated — ${d.toLocaleDateString(locale, { month: "short", day: "numeric" })}`;
      }
    } catch {
      label = `Updated — ${d.toISOString().slice(0, 10)}`;
    }
    D.lastUpdatedText.textContent = label;
  };

  const setProgressUI = () => {
    D = cacheDom();

    const raised = toInt(S.fundraiser.raisedCents, 0);
    const goal = toInt(S.fundraiser.goalCents, 0);
    const pct = goal > 0 ? clamp(Math.round((raised / goal) * 100), 0, 999) : 0;
    const remaining = Math.max(0, goal - raised);

    const raisedTxt = formatCurrency(raised, currency, locale);
    const goalTxt = formatCurrency(goal, currency, locale);

    if (D.raisedBig) D.raisedBig.textContent = raisedTxt;
    if (D.raisedRow) D.raisedRow.textContent = raisedTxt;
    if (D.goalRow) D.goalRow.textContent = goalTxt;
    if (D.goalPill) D.goalPill.textContent = goalTxt;

    if (D.remainingText) D.remainingText.textContent = formatCurrency(remaining, currency, locale);
    if (D.pctText) D.pctText.textContent = String(pct);

    if (D.overallBar) {
      const w = clamp(goal > 0 ? (raised / goal) * 100 : 0, 0, 100);
      D.overallBar.style.width = `${w.toFixed(2)}%`;
      const meter = qs('[data-ff-meter="overall"]');
      if (meter) {
        meter.setAttribute("aria-valuenow", String(clamp(pct, 0, 100)));
        meter.setAttribute("aria-valuetext", `${clamp(pct, 0, 100)}% funded`);
      }
    }

    if (D.topbarRaised) D.topbarRaised.textContent = raisedTxt;
    if (D.topbarGoal) D.topbarGoal.textContent = goalTxt;
  };

  const applyKpis = () => {
    D = cacheDom();
    if (!D.donorCount && !D.avgGift && !D.topGift) return;

    const gifts = normalizeGifts();
    const sponsors = normalizeSponsors();
    const contribs = gifts.map((g) => g.amountCents).concat(sponsors.map((s) => s.amountCents));

    const count = contribs.length;
    const top = contribs.reduce((m, x) => Math.max(m, toInt(x, 0)), 0);
    const avg = count > 0 ? Math.round(contribs.reduce((a, x) => a + toInt(x, 0), 0) / count) : 0;

    if (D.donorCount) D.donorCount.textContent = String(count);
    if (D.topGift) D.topGift.textContent = formatCurrency(top, currency, locale);
    if (D.avgGift) D.avgGift.textContent = formatCurrency(avg, currency, locale);
  };

  /* ---------------------------------------------
   * Deadline / Countdown
   * -------------------------------------------*/
  let countdownTimer = null;

  const startDeadlineLoop = () => {
    D = cacheDom();
    const deadline = parseISO(S.fundraiser.deadlineISO);

    const deadlineLabel = (() => {
      if (!deadline) return "—";
      try {
        return deadline.toLocaleDateString(locale, { month: "short", day: "numeric", year: "numeric" });
      } catch {
        return deadline.toISOString().slice(0, 10);
      }
    })();

    if (D.deadlineText) D.deadlineText.textContent = deadline ? deadlineLabel : "No deadline";
    if (D.topbarDeadline) D.topbarDeadline.textContent = deadline ? deadlineLabel : "—";

    if (!deadline) return;

    const tick = () => {
      const ms = deadline.getTime() - now();
      const label = ms <= 0 ? "Ended" : humanCountdown(ms);
      if (D.heroCountdown) D.heroCountdown.textContent = label;
      if (D.topbarCountdown) D.topbarCountdown.textContent = label;
    };

    tick();
    clearInterval(countdownTimer);
    countdownTimer = setInterval(tick, 15000);
  };

  /* ---------------------------------------------
   * Optional: event pill countdown
   * -------------------------------------------*/
  const applyEventPill = () => {
    D = cacheDom();
    const pill = D.heroEventPill;
    if (!pill) return;

    const ev = C?.event || C?.fundraiser?.event || null;
    const starts = parseISO(ev?.startsISO || ev?.startISO || "");
    const title = safeText(ev?.title || ev?.name || "Next event");
    if (!starts) {
      setHidden(pill, true);
      return;
    }

    const tick = () => {
      const ms = starts.getTime() - now();
      const t = ms <= 0 ? "Now" : humanCountdown(ms);
      pill.textContent = `${title} • ${t}`;
      setHidden(pill, false);
    };
    tick();
    setInterval(tick, 15000);
  };

  /* ---------------------------------------------
   * Match UI
   * -------------------------------------------*/
  const applyMatch = () => {
    D = cacheDom();
    const m = S.fundraiser.match;
    const isActive = !!m?.active;

    if (D.heroMatchPill) setHidden(D.heroMatchPill, !isActive);
    if (D.sponsorMatchPill) setHidden(D.sponsorMatchPill, !isActive);
    if (D.matchDetailRow) setHidden(D.matchDetailRow, !isActive);
    if (D.matchStatus) D.matchStatus.textContent = isActive ? "On" : "Off";
    if (D.topbarMatchStrip) setHidden(D.topbarMatchStrip, !isActive);
    if (D.matchCallout) setHidden(D.matchCallout, !isActive);

    if (!isActive) return;

    const remainingCents = toInt(m.remainingCents ?? (toInt(m.remaining, 0) * 100), 0);
    const ends = parseISO(m.endsISO || "");

    if (D.matchRemainingPill) D.matchRemainingPill.textContent = `Remaining ${formatCurrency(remainingCents, currency, locale)}`;
    if (D.matchEndsPill) D.matchEndsPill.textContent = ends ? `Ends ${humanCountdown(ends.getTime() - now())}` : "Ends —";

    if (D.topbarMatchText) D.topbarMatchText.textContent = "Active";
    if (D.topbarMatchRemaining) D.topbarMatchRemaining.textContent = formatCurrency(remainingCents, currency, locale);

    if (D.matchCalloutText) {
      D.matchCalloutText.textContent = ends ? `until ${ends.toLocaleDateString(locale, { month: "short", day: "numeric" })}` : "doubling gifts";
    }
  };

  /* ---------------------------------------------
   * Allocation list
   * -------------------------------------------*/
  const renderAllocation = () => {
    D = cacheDom();
    if (!D.allocationList) return;
    const items = Array.isArray(S.fundraiser.allocation) ? S.fundraiser.allocation : [];
    if (!items.length) {
      D.allocationList.innerHTML = `<div class="ff-help">Allocation coming soon.</div>`;
      return;
    }

    const total = items.reduce((a, x) => a + toNum(x.pct, 0), 0) || 100;
    D.allocationList.innerHTML = items
      .map((x) => {
        const pct = clamp(Math.round((toNum(x.pct, 0) / total) * 100), 0, 100);
        return `<div class="ff-slimitem"><span class="ff-help">${escapeHTML(safeText(x.label || ""))}</span><strong class="ff-help ff-num">${pct}%</strong></div>`;
      })
      .join("");

    if (D.allocationUpdated && D.allocationUpdatedText) {
      const upd = safeText(S.fundraiser.allocationUpdatedISO || S.fundraiser.updatedISO || "");
      if (upd) {
        setHidden(D.allocationUpdated, false);
        const d = parseISO(upd);
        D.allocationUpdatedText.textContent = d ? d.toLocaleDateString(locale, { month: "short", day: "numeric" }) : upd;
      } else {
        setHidden(D.allocationUpdated, true);
      }
    }
  };

  /* ---------------------------------------------
   * Impact grid
   * -------------------------------------------*/
  const renderImpact = () => {
    D = cacheDom();
    if (!D.impactGrid) return;

    const items = normalizeImpactList();
    const filter = S.ui.impactFilter;
    const q = safeText(S.ui.impactQuery).trim().toLowerCase();

    const filtered = items.filter((x) => {
      const okCat = filter === "all" ? true : x.cat === filter;
      if (!okCat) return false;
      if (!q) return true;
      return (x.title + " " + x.desc + " " + x.cat).toLowerCase().includes(q);
    });

    if (!filtered.length) {
      if (D.impactEmpty) setHidden(D.impactEmpty, false);
      D.impactGrid.innerHTML = "";
      return;
    }
    if (D.impactEmpty) setHidden(D.impactEmpty, true);

    const card = (x) => {
      const amt = formatCurrency(x.amountCents, currency, locale);
      return `
        <article class="ff-mini" role="listitem" tabindex="0"
          data-ff-impact-item
          data-impact-id="${escapeHTML(x.id)}"
          aria-label="${escapeHTML(x.title)}">
          <div class="ff-row ff-row--between ff-ais">
            <div style="min-width:0">
              <div class="ff-kicker">${escapeHTML(x.cat.toUpperCase())}</div>
              <div class="ff-card__title">${escapeHTML(x.title)}</div>
              <p class="ff-help" style="margin-top:6px">${escapeHTML(x.desc)}</p>
            </div>
            <span class="ff-pill ff-pill--accent">${escapeHTML(amt)}</span>
          </div>
          <div class="ff-row ff-wrap" style="margin-top:10px" role="group" aria-label="Actions">
            <button class="ff-btn ff-btn--primary ff-btn--sm" type="button"
              data-ff-impact-cta data-impact-id="${escapeHTML(x.id)}" data-impact-cents="${escapeHTML(String(x.amountCents))}">
              Prefill ${escapeHTML(amt)}
            </button>
            <button class="ff-btn ff-btn--ghost ff-btn--sm" type="button"
              data-ff-impact-share data-impact-id="${escapeHTML(x.id)}">
              Share need
            </button>
          </div>
        </article>
      `;
    };

    D.impactGrid.innerHTML = filtered.map(card).join("");

    qsa("[data-ff-impact-item]", D.impactGrid).forEach((el) => {
      on(el, "keydown", (e) => {
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault();
          const id = el.getAttribute("data-impact-id") || "";
          const btn = qs("[data-ff-impact-cta]", el);
          const cents = toInt(btn?.getAttribute("data-impact-cents"), 0);
          setPrefill({ amountCents: cents, purpose: "impact", impactId: id });
          scrollToDonate();
          toast("Checkout prefilled.", "success");
        }
      });
    });

    qsa("[data-ff-impact-cta]", D.impactGrid).forEach((btn) => {
      on(btn, "click", () => {
        const cents = toInt(btn.getAttribute("data-impact-cents"), 0);
        const id = btn.getAttribute("data-impact-id") || "";
        setPrefill({ amountCents: cents, purpose: "impact", impactId: id });
        scrollToDonate();
        toast("Checkout prefilled.", "success");
      });
    });

    qsa("[data-ff-impact-share]", D.impactGrid).forEach((btn) => {
      on(btn, "click", async () => {
        const id = btn.getAttribute("data-impact-id") || "";
        const url = buildShareUrl({ needId: id });
        if (navigator.share) {
          try {
            await navigator.share({ title: document.title, text: "Support this specific need.", url });
            toast("Shared.", "success");
            return;
          } catch {}
        }
        const ok = await copyToClipboard(url);
        toast(ok ? "Need link copied." : "Copy failed. Use the Share tools.", ok ? "success" : "error");
      });
    });
  };

  const bindImpactControls = () => {
    D = cacheDom();

    if (D.impactSearch) {
      on(
        D.impactSearch,
        "input",
        debounce(() => {
          S.ui.impactQuery = D.impactSearch.value || "";
          renderImpact();
        }, 120)
      );
    }

    for (const btn of D.impactFilterBtns) {
      on(btn, "click", () => {
        const f = btn.getAttribute("data-ff-impact-filter") || "all";
        S.ui.impactFilter = f;
        for (const b of D.impactFilterBtns) {
          const selected = b === btn;
          b.classList.toggle("is-selected", selected);
          setAriaPressed(b, selected);
        }
        renderImpact();
      });
    }
  };

  /* ---------------------------------------------
   * Sponsors
   * -------------------------------------------*/
  const sponsorBadge = (name) => {
    const initials = safeText(name)
      .split(/\s+/)
      .filter(Boolean)
      .slice(0, 2)
      .map((p) => p[0]?.toUpperCase() || "")
      .join("");
    return initials || "S";
  };

  const bindSponsorPrefills = (root = document) => {
    qsa("[data-ff-sponsor-cta]", root).forEach((btn) => {
      if (btn.__ffBoundSponsor) return;
      btn.__ffBoundSponsor = true;
      on(btn, "click", () => {
        const dollars = toInt(btn.getAttribute("data-ff-prefill-amount"), 0);
        const cents = dollars * 100;
        setPrefill({ amountCents: cents, purpose: "sponsorship", sku: "sponsor" }, { silent: true });
        scrollToDonate();
        toast("Sponsor amount prefilled.", "success");
      });
    });
  };

  const renderSponsorTiers = () => {
    D = cacheDom();
    if (!D.sponsorTiersHost) return;
    const tiers = Array.isArray(S.fundraiser.sponsorTiers) ? S.fundraiser.sponsorTiers : [];
    if (!tiers.length) {
      D.sponsorTiersHost.innerHTML = `<li class="ff-mini"><div class="ff-help">Sponsor tiers coming soon.</div></li>`;
      return;
    }

    const norm = tiers.map((t) => ({
      ...t,
      amountCents: toInt(t.amountCents ?? (toInt(t.amount, 0) * 100), 0),
      perk: safeText(t.perk || "Recognition on wall + leaderboard"),
      title: safeText(t.title || "Sponsor"),
    }));

    D.sponsorTiersHost.innerHTML = norm
      .map((t) => {
        const amt = formatCurrency(t.amountCents, currency, locale);
        return `
          <li class="ff-mini" role="listitem" aria-label="${escapeHTML(t.title)}">
            <div class="ff-row ff-row--between ff-ais">
              <div style="min-width:0">
                <div class="ff-kicker">Tier</div>
                <div class="ff-card__title">${escapeHTML(t.title)}</div>
                <p class="ff-help" style="margin-top:6px">${escapeHTML(t.perk)}</p>
              </div>
              <span class="ff-pill ff-pill--accent">${escapeHTML(amt)}</span>
            </div>
            <div class="ff-row ff-wrap" style="margin-top:10px" role="group" aria-label="Actions">
              <button class="ff-btn ff-btn--primary ff-btn--sm" type="button"
                data-ff-sponsor-cta data-ff-prefill-amount="${escapeHTML(String(Math.round(t.amountCents / 100)))}">
                Sponsor ${escapeHTML(amt)}
              </button>
            </div>
          </li>
        `;
      })
      .join("");

    bindSponsorPrefills(D.sponsorTiersHost);
  };

  const renderSponsorBoard = () => {
    D = cacheDom();

    const sponsors = normalizeSponsors();

    if (D.sponsorPodium) {
      const top = sponsors.slice(0, 3);
      if (!top.length) {
        D.sponsorPodium.innerHTML = `<li class="ff-mini"><div class="ff-help">Sponsors appear after successful payments.</div></li>`;
      } else {
        D.sponsorPodium.innerHTML = top
          .map((s, i) => {
            const amt = formatCurrency(s.amountCents, currency, locale);
            const badge = sponsorBadge(s.name);
            const left = s.logo
              ? `<img src="${escapeHTML(safeUrl(s.logo) || s.logo)}" alt="${escapeHTML(s.name)} logo" loading="lazy" decoding="async"
                   style="width:44px;height:44px;border-radius:12px;object-fit:cover;border:1px solid var(--ff-border)" />`
              : `<div aria-hidden="true" style="width:44px;height:44px;border-radius:12px;display:grid;place-items:center;border:1px solid var(--ff-border);background:color-mix(in oklab,var(--ff-surface-0) 80%,transparent);font-weight:700">${escapeHTML(
                  badge
                )}</div>`;
            const inner = `
              <div class="ff-row ff-row--between ff-ais" style="gap:12px">
                <div class="ff-row ff-ais" style="gap:12px;min-width:0">
                  ${left}
                  <div style="min-width:0">
                    <div class="ff-kicker">Rank #${i + 1}</div>
                    <div class="ff-card__title" style="white-space:nowrap;overflow:hidden;text-overflow:ellipsis;max-width:360px">${escapeHTML(
                      s.name
                    )}</div>
                  </div>
                </div>
                <span class="ff-pill ff-pill--accent">${escapeHTML(amt)}</span>
              </div>
            `;
            return s.url
              ? `<li class="ff-mini" role="listitem"><a href="${escapeHTML(
                  s.url
                )}" target="_blank" rel="noopener noreferrer" style="text-decoration:none;color:inherit;display:block">${inner}</a></li>`
              : `<li class="ff-mini" role="listitem">${inner}</li>`;
          })
          .join("");
      }
    }

    if (D.sponsorList) {
      const list =
        S.ui.sponsorSort === "recent"
          ? sponsors.slice().sort((a, b) => (b.ts || 0) - (a.ts || 0))
          : sponsors.slice();

      if (!list.length) {
        D.sponsorList.innerHTML = `<li class="ff-mini"><div class="ff-help">No sponsors yet. Be the first.</div></li>`;
      } else {
        D.sponsorList.innerHTML = list
          .map((s, idx) => {
            const amt = formatCurrency(s.amountCents, currency, locale);
            const badge = sponsorBadge(s.name);
            const left = s.logo
              ? `<img src="${escapeHTML(safeUrl(s.logo) || s.logo)}" alt="${escapeHTML(s.name)} logo" loading="lazy" decoding="async"
                   style="width:44px;height:44px;border-radius:12px;object-fit:cover;border:1px solid var(--ff-border)" />`
              : `<div aria-hidden="true" style="width:44px;height:44px;border-radius:12px;display:grid;place-items:center;border:1px solid var(--ff-border);background:color-mix(in oklab,var(--ff-surface-0) 80%,transparent);font-weight:700">${escapeHTML(
                  badge
                )}</div>`;
            const inner = `
              <div class="ff-row ff-row--between ff-ais" style="gap:12px">
                <div class="ff-row ff-ais" style="gap:12px;min-width:0">
                  ${left}
                  <div style="min-width:0">
                    <div class="ff-kicker">${S.ui.sponsorSort === "recent" ? "Recent" : `Rank #${idx + 1}`}</div>
                    <div class="ff-card__title" style="white-space:nowrap;overflow:hidden;text-overflow:ellipsis;max-width:420px">${escapeHTML(
                      s.name
                    )}</div>
                  </div>
                </div>
                <strong class="ff-help ff-num">${escapeHTML(amt)}</strong>
              </div>
            `;
            return s.url
              ? `<li class="ff-mini" role="listitem"><a href="${escapeHTML(
                  s.url
                )}" target="_blank" rel="noopener noreferrer" style="text-decoration:none;color:inherit;display:block">${inner}</a></li>`
              : `<li class="ff-mini" role="listitem">${inner}</li>`;
          })
          .join("");
      }
    }

    if (D.sponsorWall) {
      const sponsorsForWall = sponsors.slice(0, 24);
      if (!sponsorsForWall.length) {
        D.sponsorWall.innerHTML = `<div class="ff-mini"><div class="ff-help">Sponsor logos appear after successful payments.</div></div>`;
        return;
      }

      if (S.ui.sponsorWall === "list") {
        D.sponsorWall.innerHTML = sponsorsForWall
          .map((s) => {
            const amt = formatCurrency(s.amountCents, currency, locale);
            return `<div class="ff-mini"><div class="ff-row ff-row--between ff-ais"><div class="ff-card__title">${escapeHTML(
              s.name
            )}</div><span class="ff-pill ff-pill--accent">${escapeHTML(amt)}</span></div></div>`;
          })
          .join("");
      } else {
        D.sponsorWall.innerHTML = sponsorsForWall
          .map((s) => {
            if (s.logo) {
              const src = escapeHTML(safeUrl(s.logo) || s.logo);
              const img = `<img src="${src}" alt="${escapeHTML(s.name)} logo" loading="lazy" decoding="async"
                  style="width:64px;height:64px;border-radius:16px;object-fit:cover;border:1px solid var(--ff-border)" />`;
              return s.url
                ? `<a href="${escapeHTML(s.url)}" target="_blank" rel="noopener noreferrer" aria-label="${escapeHTML(
                    s.name
                  )}" style="display:inline-block">${img}</a>`
                : img;
            }
            const badge = sponsorBadge(s.name);
            const box = `<div aria-label="${escapeHTML(
              s.name
            )}" style="width:64px;height:64px;border-radius:16px;display:grid;place-items:center;border:1px solid var(--ff-border);background:color-mix(in oklab,var(--ff-surface-0) 80%,transparent);font-weight:800">${escapeHTML(
              badge
            )}</div>`;
            return s.url
              ? `<a href="${escapeHTML(s.url)}" target="_blank" rel="noopener noreferrer" style="display:inline-block">${box}</a>`
              : box;
          })
          .join("");
      }
    }
  };

  const bindSponsorControls = () => {
    D = cacheDom();

    for (const btn of D.sponsorSortBtns) {
      on(btn, "click", () => {
        const sort = btn.getAttribute("data-ff-sort") || "rank";
        S.ui.sponsorSort = sort;
        for (const b of D.sponsorSortBtns) {
          const selected = b === btn;
          b.classList.toggle("is-selected", selected);
          setAriaPressed(b, selected);
        }
        renderSponsorBoard();
      });
    }

    for (const btn of D.sponsorWallViewBtns) {
      on(btn, "click", () => {
        const view = btn.getAttribute("data-ff-wall") || "logos";
        S.ui.sponsorWall = view;
        for (const b of D.sponsorWallViewBtns) {
          const selected = b === btn;
          b.classList.toggle("is-selected", selected);
          setAriaPressed(b, selected);
        }
        renderSponsorBoard();
      });
    }

    if (D.refreshSponsorsBtn) {
      on(D.refreshSponsorsBtn, "click", () => {
        renderSponsorBoard();
        toast("Sponsors refreshed.", "success");
      });
    }
  };

  /* ---------------------------------------------
   * Teams grid
   * -------------------------------------------*/
  const renderTeams = () => {
    D = cacheDom();
    if (!D.teamsGrid) return;

    const teams = normalizeTeams();
    const q = safeText(S.ui.teamQuery).trim().toLowerCase();
    let list = teams.filter((t) => {
      if (!q) return true;
      return (t.name + " " + t.meta + " " + t.ask).toLowerCase().includes(q);
    });

    if (S.ui.teamSort === "featured") {
      list = list.sort((a, b) => (b.featured ? 1 : 0) - (a.featured ? 1 : 0));
    } else if (S.ui.teamSort === "goal") {
      list = list.sort((a, b) => (b.pct || 0) - (a.pct || 0));
    } else if (S.ui.teamSort === "recent") {
      list = list.sort((a, b) => (b.ts || 0) - (a.ts || 0));
    }

    if (!list.length) {
      D.teamsGrid.innerHTML = `<div class="ff-mini"><div class="ff-kicker">No matches</div><div class="ff-card__title">Try a different search</div><p class="ff-help">Try fewer words (e.g., “6th”, “Gold”, “Black”).</p></div>`;
      if (D.teamsStatus) D.teamsStatus.textContent = "No teams match your search.";
      return;
    }

    if (D.teamsStatus) D.teamsStatus.textContent = `${list.length} teams shown.`;

    const card = (t) => {
      const goal = formatCurrency(t.goalCents, currency, locale);
      const raised = formatCurrency(t.raisedCents, currency, locale);
      const pct = t.goalCents > 0 ? clamp(Math.round((t.raisedCents / t.goalCents) * 100), 0, 999) : 0;
      const selected = S.ui.selectedTeamId === t.id;

      const img = t.photo
        ? `<img src="${escapeHTML(safeUrl(t.photo) || t.photo)}" alt="${escapeHTML(t.name)} photo" loading="lazy" decoding="async"
             style="width:100%;height:150px;object-fit:cover;border-radius:16px;border:1px solid var(--ff-border)" />`
        : "";

      return `
        <article class="ff-mini" role="listitem" data-ff-team-card data-team-id="${escapeHTML(t.id)}" aria-label="${escapeHTML(t.name)}">
          ${img}
          <div class="ff-row ff-row--between ff-ais" style="margin-top:10px">
            <div style="min-width:0">
              <div class="ff-kicker">${t.featured ? "Featured" : "Team"}</div>
              <div class="ff-card__title" style="white-space:nowrap;overflow:hidden;text-overflow:ellipsis">${escapeHTML(t.name)}</div>
              <p class="ff-help" style="margin-top:6px">${escapeHTML(t.meta)}</p>
            </div>
            <span class="ff-pill ${selected ? "ff-pill--accent" : ""}" aria-label="Goal progress">${escapeHTML(String(pct))}%</span>
          </div>

          <div class="ff-meter" role="progressbar" aria-label="Team progress" aria-valuemin="0" aria-valuemax="100" aria-valuenow="${escapeHTML(
            String(clamp(pct, 0, 100))
          )}" aria-valuetext="${escapeHTML(String(clamp(pct, 0, 100)))}% funded" style="margin-top:10px">
            <span style="width:${escapeHTML(String(clamp(pct, 0, 100)))}%"></span>
          </div>

          <div class="ff-row ff-row--between ff-wrap" style="margin-top:10px">
            <span class="ff-help">Raised: <strong class="ff-num">${escapeHTML(raised)}</strong></span>
            <span class="ff-help">Goal: <strong class="ff-num">${escapeHTML(goal)}</strong></span>
          </div>

          ${t.ask ? `<p class="ff-help ff-muted" style="margin-top:10px">${escapeHTML(t.ask)}</p>` : ""}

          <div class="ff-row ff-wrap" style="margin-top:10px" role="group" aria-label="Team actions">
            <button class="ff-btn ff-btn--secondary ff-btn--sm" type="button" data-ff-team-select data-team-id="${escapeHTML(
              t.id
            )}" aria-pressed="${selected ? "true" : "false"}">
              ${selected ? "Selected" : "Select team"}
            </button>
            <button class="ff-btn ff-btn--primary ff-btn--sm" type="button" data-ff-team-donate data-team-id="${escapeHTML(
              t.id
            )}">
              Donate to this team
            </button>
            <button class="ff-btn ff-btn--ghost ff-btn--sm" type="button" data-ff-team-share data-team-id="${escapeHTML(
              t.id
            )}">
              Share team link
            </button>
          </div>
        </article>
      `;
    };

    D.teamsGrid.innerHTML = list.map(card).join("");

    qsa("[data-ff-team-select]", D.teamsGrid).forEach((btn) => {
      on(btn, "click", () => {
        const id = btn.getAttribute("data-team-id") || "";
        const next = S.ui.selectedTeamId === id ? "" : id;
        setSelectedTeam(next, { silent: false });
      });
    });

    qsa("[data-ff-team-donate]", D.teamsGrid).forEach((btn) => {
      on(btn, "click", () => {
        const id = btn.getAttribute("data-team-id") || "";
        setSelectedTeam(id, { silent: true });
        scrollToDonate();
        toast("Team selected. Donate below.", "success");
      });
    });

    qsa("[data-ff-team-share]", D.teamsGrid).forEach((btn) => {
      on(btn, "click", async () => {
        const id = btn.getAttribute("data-team-id") || "";
        const url = buildShareUrl({ teamId: id });
        if (navigator.share) {
          try {
            await navigator.share({ title: document.title, text: "Support this team.", url });
            toast("Shared.", "success");
            return;
          } catch {}
        }
        const ok = await copyToClipboard(url);
        toast(ok ? "Team link copied." : "Copy failed. Use Share tools.", ok ? "success" : "error");
      });
    });
  };

  const bindTeamControls = () => {
    D = cacheDom();

    if (D.teamSearch) {
      on(
        D.teamSearch,
        "input",
        debounce(() => {
          S.ui.teamQuery = D.teamSearch.value || "";
          renderTeams();
        }, 120)
      );
    }

    for (const btn of D.teamSortBtns) {
      on(btn, "click", () => {
        const sort = btn.getAttribute("data-ff-sort") || "featured";
        S.ui.teamSort = sort;
        for (const b of D.teamSortBtns) {
          const selected = b === btn;
          b.classList.toggle("is-selected", selected);
          setAriaPressed(b, selected);
        }
        renderTeams();
      });
    }

    for (const btn of D.attribClearBtns) on(btn, "click", () => setSelectedTeam("", { silent: false }));
  };

  /* ---------------------------------------------
   * Recent gifts
   * -------------------------------------------*/
  const renderRecentGifts = () => {
    D = cacheDom();
    if (!D.recentGiftsHost) return;
    const gifts = normalizeGifts();
    if (!gifts.length) {
      D.recentGiftsHost.innerHTML = `<div class="ff-help ff-muted">No public gifts yet.</div>`;
      return;
    }
    D.recentGiftsHost.innerHTML = gifts
      .map((g) => {
        const name = g.anon ? "Anonymous" : g.name;
        const amt = formatCurrency(g.amountCents, currency, locale);
        return `<div class="ff-slimitem"><span class="ff-help">${escapeHTML(name)}</span><strong class="ff-help ff-num">${escapeHTML(
          amt
        )}</strong></div>`;
      })
      .join("");
  };

  /* ---------------------------------------------
   * Scroll / anchor helpers
   * -------------------------------------------*/
  const scrollToDonate = () => {
    const el = qs("#donate");
    if (!el) return;
    el.scrollIntoView({ behavior: prefersReducedMotion() ? "auto" : "smooth", block: "start" });
    // Nice UX: focus amount if present
    setTimeout(() => {
      try {
        const amt = qs("#amount");
        amt?.focus?.();
      } catch {}
    }, 250);
  };

  const bindAnchors = () => {
    D = cacheDom();

    const handle = (a) => {
      const href = a.getAttribute("href") || "";
      if (!href.startsWith("#") || href === "#") return;
      on(a, "click", (e) => {
        const id = href.slice(1);
        const target = qs(`#${cssEscape(id)}`);
        if (!target) return;
        e.preventDefault();
        target.scrollIntoView({ behavior: prefersReducedMotion() ? "auto" : "smooth", block: "start" });
      });
    };
    D.anchorLinks.forEach(handle);
    D.tabLinks.forEach(handle);

    qsa("[data-ff-donate-cta]").forEach((el) => {
      if (el.tagName.toLowerCase() === "a") return;
      on(el, "click", (e) => {
        e.preventDefault();
        scrollToDonate();
      });
    });

    if (D.backToTopBtn) {
      on(D.backToTopBtn, "click", (e) => {
        e.preventDefault();
        window.scrollTo({ top: 0, behavior: prefersReducedMotion() ? "auto" : "smooth" });
      });
    }
  };

  const bindScrollProgress = () => {
    D = cacheDom();
    if (!D.scrollProgressBar) return;
    const tick = () => {
      const doc = document.documentElement;
      const max = Math.max(1, doc.scrollHeight - doc.clientHeight);
      const y = doc.scrollTop || window.scrollY || 0;
      const p = clamp((y / max) * 100, 0, 100);
      D.scrollProgressBar.style.width = `${p.toFixed(2)}%`;
    };
    const run = debounce(tick, 24);
    window.addEventListener("scroll", run, { passive: true });
    window.addEventListener("resize", run, { passive: true });
    tick();
  };

  /* ---------------------------------------------
   * Motion reveal (optional, driven by html[data-ff-motion="true"])
   * -------------------------------------------*/
  const initInview = () => {
    const motion = document.documentElement.getAttribute("data-ff-motion") === "true";
    if (!motion) return;

    const els = qsa(".ff-reveal, .ff-stagger");
    if (!els.length) return;

    if (prefersReducedMotion() || !("IntersectionObserver" in window)) {
      els.forEach((el) => el.classList.add("is-inview"));
      return;
    }

    const io = new IntersectionObserver(
      (entries) => {
        for (const e of entries) {
          if (e.isIntersecting) {
            e.target.classList.add("is-inview");
            e.target.setAttribute("data-ff-inview", "true");
            io.unobserve(e.target);
          }
        }
      },
      { threshold: 0.12, rootMargin: "0px 0px -8% 0px" }
    );

    els.forEach((el) => io.observe(el));
  };

  /* ---------------------------------------------
   * Sticky support bar hide/show when donate visible
   * -------------------------------------------*/
  const initStickySupport = () => {
    D = cacheDom();
    const sticky = D.stickySupport;
    const donate = qs("#donate");
    if (!sticky || !donate) return;

    if (!("IntersectionObserver" in window)) return;

    const io = new IntersectionObserver(
      (entries) => {
        const isDonateVisible = entries.some((e) => e.isIntersecting);
        sticky.hidden = !!isDonateVisible;
        sticky.setAttribute("aria-hidden", isDonateVisible ? "true" : "false");
      },
      { root: null, threshold: 0.15 }
    );

    io.observe(donate);
  };

  /* ---------------------------------------------
   * Frequency toggle placeholder (monthly)
   * -------------------------------------------*/
  const injectFrequencyToggle = () => {
    D = cacheDom();
    if (!C?.flagship?.features?.monthlyGivingPlaceholder) return;
    if (!D.amount) return;
    if (qs("[data-ff-frequency-toggle]")) return;

    const wrap = document.createElement("div");
    wrap.className = "ff-seg";
    wrap.setAttribute("data-ff-frequency-toggle", "true");
    wrap.setAttribute("role", "group");
    wrap.setAttribute("aria-label", "Gift frequency");

    const one = document.createElement("button");
    one.type = "button";
    one.className = "ff-chip is-selected";
    one.textContent = "One-time";
    one.setAttribute("aria-pressed", "true");
    one.dataset.ffFreq = "one-time";

    const monthly = document.createElement("button");
    monthly.type = "button";
    monthly.className = "ff-chip";
    monthly.textContent = "Monthly";
    monthly.setAttribute("aria-pressed", "false");
    monthly.dataset.ffFreq = "monthly";

    wrap.appendChild(one);
    wrap.appendChild(monthly);

    const fieldset = D.amount.closest("fieldset") || D.amount.parentElement;
    if (fieldset) fieldset.insertBefore(wrap, fieldset.firstChild);

    const setFreq = (v) => {
      S.ui.giftType = v;
      const isMonthly = v === "monthly";
      one.classList.toggle("is-selected", !isMonthly);
      monthly.classList.toggle("is-selected", isMonthly);
      setAriaPressed(one, !isMonthly);
      setAriaPressed(monthly, isMonthly);

      if (D.payBtn) D.payBtn.textContent = isMonthly ? "Continue (monthly)" : "Continue";
      toast(isMonthly ? "Monthly selected (premium option)." : "One-time selected.", "info");
    };

    on(one, "click", () => setFreq("one-time"));
    on(monthly, "click", () => setFreq("monthly"));
  };

  /* ---------------------------------------------
   * Checkout: summary + recognition + prefills
   * -------------------------------------------*/
  const estimateFeesCents = (donationCents) => {
    const f = S.fundraiser.fees || {};
    const pct = toNum(f.percent, 0);
    const fixed = toInt(f.fixedCents, 0);
    let fee = Math.round(donationCents * pct + fixed);
    const max = toInt(f.maxCents, 0);
    if (max > 0) fee = Math.min(fee, max);
    return Math.max(0, fee);
  };

  const applyPopularAmount = () => {
    D = cacheDom();
    if (!D.popularAmountPill || !D.popularAmountText) return;
    const p = toInt(S.fundraiser.popularAmountCents, 0);
    if (p > 0) {
      setHidden(D.popularAmountPill, false);
      D.popularAmountText.textContent = formatCurrency(p, currency, locale);
    } else {
      setHidden(D.popularAmountPill, true);
    }
  };

  const emailOk = (s) => {
    const v = safeText(s).trim();
    if (!v) return false;
    if (v.length > 320) return false;
    return /^[^\s@]+@[^\s@]+\.[^\s@]{2,}$/.test(v);
  };

  const syncRecognitionUI = () => {
    D = cacheDom();
    const isAnon = !!D.anonymous?.checked || S.ui.recognition === "anonymous";
    S.ui.recognition = isAnon ? "anonymous" : "public";

    for (const btn of D.recognitionBtns) {
      const mode = btn.getAttribute("data-ff-recognition") || "public";
      const selected = (mode === "anonymous" && isAnon) || (mode === "public" && !isAnon);
      btn.classList.toggle("is-selected", selected);
      setAriaPressed(btn, selected);
    }

    if (D.recognitionPreviewText) {
      if (isAnon) D.recognitionPreviewText.textContent = "Anonymous";
      else {
        const nm = safeText(D.fullName?.value || "").trim();
        D.recognitionPreviewText.textContent = nm ? nm : "Your name";
      }
    }
  };

  const updateSummaryUI = () => {
    D = cacheDom();

    const donation = Math.max(0, S.ui.amountCents);
    const cover = !!S.ui.coverFees;
    const fees = cover ? estimateFeesCents(donation) : 0;
    const total = donation + fees;

    if (D.summaryAmount) D.summaryAmount.textContent = formatCurrency(donation, currency, locale);
    if (D.summaryFees) D.summaryFees.textContent = cover ? formatCurrency(fees, currency, locale, true) : "—";
    if (D.summaryTotal) D.summaryTotal.textContent = donation > 0 ? formatCurrency(total, currency, locale, true) : "—";

    if (D.receiptEmail) D.receiptEmail.textContent = safeText(D.email?.value || "your email").trim() || "your email";
    if (D.clearAmountBtn) setHidden(D.clearAmountBtn, donation <= 0);

    for (const btn of D.quickAmountBtns) {
      const dollars = toInt(btn.getAttribute("data-ff-quick-amount") || btn.getAttribute("data-quick-amount"), 0);
      const cents = dollars * 100;
      const selected = cents > 0 && donation === cents;
      btn.classList.toggle("is-selected", selected);
      setAriaPressed(btn, selected);
    }

    if (D.checkoutStatusText) {
      if (donation <= 0) D.checkoutStatusText.textContent = "Ready";
      else if (!emailOk(D.email?.value || "")) D.checkoutStatusText.textContent = "Email required";
      else if (S.ui.stripeMounted && !S.ui.stripeReadyToPay) D.checkoutStatusText.textContent = "Enter payment details";
      else D.checkoutStatusText.textContent = "Ready";
    }

    const method = paypalClientId ? "Stripe + PayPal" : "Stripe";
    if (D.checkoutMethodPill && D.checkoutMethodText) {
      setHidden(D.checkoutMethodPill, false);
      D.checkoutMethodText.textContent = method;
    }

    // optional proof preview fields (if present)
    const proofAmt = qs("#proofAmount");
    if (proofAmt)
      proofAmt.textContent =
        donation > 0 ? formatCurrency(donation, currency, locale) : formatCurrency(S.fundraiser.popularAmountCents, currency, locale);
    const proofName = qs("#proofDonorName");
    if (proofName) proofName.textContent = S.ui.recognition === "anonymous" ? "Anonymous" : safeText(D.fullName?.value || "").trim() || "Your name";
  };

  const bindDonateControls = () => {
    D = cacheDom();

    if (D.amount) {
      on(
        D.amount,
        "input",
        debounce(() => {
          S.ui.amountCents = parseMoneyToCents(D.amount.value);
          updateSummaryUI();
        }, 120)
      );
    }

    if (D.email) on(D.email, "input", debounce(() => updateSummaryUI(), 120));
    if (D.fullName) on(D.fullName, "input", debounce(() => syncRecognitionUI(), 120));

    if (D.coverFees) {
      on(D.coverFees, "change", () => {
        S.ui.coverFees = !!D.coverFees.checked;
        updateSummaryUI();
      });
      if (!S.fundraiser.fees?.enabledCoverFees) {
        D.coverFees.checked = false;
        D.coverFees.disabled = true;
        S.ui.coverFees = false;
      } else {
        S.ui.coverFees = !!D.coverFees.checked;
      }
    }

    if (D.clearAmountBtn) {
      on(D.clearAmountBtn, "click", () => {
        S.ui.amountCents = 0;
        if (D.amount) D.amount.value = "";
        updateSummaryUI();
        toast("Amount cleared.", "info");
      });
    }

    for (const btn of D.quickAmountBtns) {
      on(btn, "click", () => {
        const dollars = toInt(btn.getAttribute("data-ff-quick-amount") || btn.getAttribute("data-quick-amount"), 0);
        setPrefill({ amountCents: dollars * 100, purpose: "donation" }, { silent: true });
        updateSummaryUI();
        toast("Amount selected.", "success");
      });
    }

    for (const btn of D.recognitionBtns) {
      on(btn, "click", () => {
        const mode = btn.getAttribute("data-ff-recognition") || "public";
        const isAnon = mode === "anonymous";
        if (D.anonymous) D.anonymous.checked = isAnon;
        S.ui.recognition = isAnon ? "anonymous" : "public";
        syncRecognitionUI();
        updateSummaryUI();
      });
    }

    if (D.anonymous) {
      on(D.anonymous, "change", () => {
        syncRecognitionUI();
        updateSummaryUI();
      });
    }

    for (const btn of D.prefills) {
      if (btn.__ffBoundPrefill) continue;
      btn.__ffBoundPrefill = true;
      on(btn, "click", () => {
        const dollars = toInt(btn.getAttribute("data-ff-prefill-amount"), 0);
        const purpose = btn.getAttribute("data-ff-prefill-purpose") || "donation";
        const sku = btn.getAttribute("data-ff-prefill-sku") || "";
        setPrefill({ amountCents: dollars * 100, purpose, sku }, { silent: true });
        scrollToDonate();
        toast("Checkout prefilled.", "success");
      });
    }

    bindSponsorPrefills(document);

    for (const btn of D.refreshBtns) {
      on(btn, "click", () => {
        renderRecentGifts();
        applyKpis();
        toast("Refreshed.", "success");
      });
    }

    for (const btn of D.downloadQrBtns) {
      on(btn, "click", () => {
        const url = buildShareUrl();
        const qr = buildQrSrc(url, 500);
        try {
          const a = document.createElement("a");
          a.href = qr;
          a.download = `fundraiser-qr.png`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          toast("QR download started.", "success");
        } catch {
          toast("Download failed. Long-press the QR image and save.", "error");
        }
      });
    }
  };

  /* ---------------------------------------------
   * Payments payload builder (contract-safe)
   * -------------------------------------------*/
  const getBaseCheckoutFacts = () => {
    D = cacheDom();

    const donation = Math.max(0, S.ui.amountCents);
    const cover = !!S.ui.coverFees;
    const fees = cover ? estimateFeesCents(donation) : 0;
    const total = donation + fees;

    const donorName = safeText(D.fullName?.value || "").trim();
    const donorEmail = safeText(D.email?.value || "").trim();
    const donorMessage = safeText(D.message?.value || "").trim();
    const donorAnonymous = !!D.anonymous?.checked;

    return {
      donation_cents: donation,
      fees_cents: fees,
      amount_cents: total,
      currency,
      locale,
      org_id: shellEnv.orgId,
      campaign_id: shellEnv.campaignId,
      gift_type: S.ui.giftType,
      purpose: S.ui.purpose,
      sku: S.ui.sku,
      impact_id: S.ui.impactId,
      team_id: S.ui.selectedTeamId,
      cover_fees: cover,
      donor_name: donorName,
      donor_email: donorEmail,
      donor_message: donorMessage,
      anonymous: donorAnonymous,
      utm: S.utm || {},
      version: shellEnv.version,
      tier: shellEnv.tier,
      env: shellEnv.env,
    };
  };

  const buildPaymentsPayload = () => {
    const base = getBaseCheckoutFacts();

    let payload = {};
    if (payloadShape === "flat_donor_v1") {
      payload = { ...base };
    } else {
      // nested_donor_v1 (default)
      payload = {
        amount_cents: base.amount_cents,
        donation_cents: base.donation_cents,
        fees_cents: base.fees_cents,
        currency: base.currency,
        locale: base.locale,
        org_id: base.org_id,
        campaign_id: base.campaign_id,
        gift_type: base.gift_type,
        purpose: base.purpose,
        sku: base.sku,
        impact_id: base.impact_id,
        team_id: base.team_id,
        cover_fees: base.cover_fees,
        donor: {
          name: base.donor_name,
          email: base.donor_email,
          message: base.donor_message,
          anonymous: base.anonymous,
        },
        utm: base.utm,
        version: base.version,
        tier: base.tier,
        env: base.env,
      };
    }

    return deepMerge(payload, payloadExtra || {});
  };

  /* ---------------------------------------------
   * Payments: Stripe (Payment Element)
   * -------------------------------------------*/
  const loadScriptOnce = (src, id) =>
    new Promise((resolve) => {
      try {
        if (id && document.getElementById(id)) return resolve(true);
        const s = document.createElement("script");
        if (id) s.id = id;
        s.src = src;
        s.async = true;
        s.onload = () => resolve(true);
        s.onerror = () => resolve(false);
        document.head.appendChild(s);
      } catch {
        resolve(false);
      }
    });

  const stripeAppearance = () => {
    if (stripeThemeMeta === "stripe" || stripeThemeMeta === "night") return { theme: stripeThemeMeta };
    const theme = document.documentElement.getAttribute("data-theme") || "";
    return { theme: theme === "light" ? "stripe" : "night" };
  };

  const setCheckoutError = (msg) => {
    D = cacheDom();
    if (D.payError && D.payErrorText) {
      D.payErrorText.textContent = msg || "Something went wrong. Please try again.";
      setHidden(D.payError, false);
      try {
        D.payError.focus();
      } catch {}
    }
    if (D.paySuccess) setHidden(D.paySuccess, true);
  };

  const setCheckoutSuccess = (msg) => {
    D = cacheDom();
    if (D.paySuccess && D.paySuccessText) {
      D.paySuccessText.textContent = msg || "Thank you! Your receipt has been emailed.";
      setHidden(D.paySuccess, false);
      try {
        D.paySuccess.focus();
      } catch {}
    }
    if (D.payError) setHidden(D.payError, true);
  };

  const setCheckoutBusy = (busy) => {
    D = cacheDom();
    S.ui.stripeBusy = !!busy;
    if (D.payBtn) D.payBtn.disabled = !!busy;
    if (D.checkoutStatusText) D.checkoutStatusText.textContent = busy ? "Processing…" : "Ready";
  };

  const ensureStripe = async () => {
    if (!stripePk || captureMode) return false;

    if (!window.Stripe) {
      const ok = await loadScriptOnce(stripeJsSrc, "ffStripeJs");
      if (!ok || !window.Stripe) return false;
    }

    if (!S.ui.stripe) {
      try {
        S.ui.stripe = window.Stripe(stripePk);
      } catch {
        return false;
      }
    }
    return true;
  };

  const createStripeIntent = async (payload) => {
    const headers = { "Content-Type": "application/json" };
    if (csrfToken) headers["X-CSRF-Token"] = csrfToken;

    const data = await fetchJson(stripeIntentEndpoint, {
      method: "POST",
      headers,
      body: JSON.stringify(payload),
      credentials: "same-origin",
    });

    const cs = data.client_secret || data.clientSecret || "";
    if (!cs) throw new Error("Missing client_secret");
    return cs;
  };

  const unmountStripe = () => {
    try {
      if (S.ui.paymentElement) S.ui.paymentElement.unmount();
    } catch {}
    S.ui.paymentElement = null;
    S.ui.elements = null;
    S.ui.clientSecret = "";
    S.ui.stripeMounted = false;
    S.ui.stripeReadyToPay = false;
  };

  const mountStripeElement = async (clientSecret) => {
    D = cacheDom();
    if (!D.paymentElementHost) return false;

    const ok = await ensureStripe();
    if (!ok) return false;

    if (S.ui.stripeMounted && S.ui.clientSecret === clientSecret) return true;
    if (S.ui.stripeMounted && S.ui.clientSecret !== clientSecret) unmountStripe();

    S.ui.clientSecret = clientSecret;

    try {
      S.ui.elements = S.ui.stripe.elements({ clientSecret, appearance: stripeAppearance() });
      S.ui.paymentElement = S.ui.elements.create("payment");
      S.ui.paymentElement.on("change", (evt) => {
        S.ui.stripeReadyToPay = !!evt.complete;
        updateSummaryUI();
        if (D.payBtn) D.payBtn.textContent = "Pay now";
      });
      S.ui.paymentElement.mount(D.paymentElementHost);

      S.ui.stripeMounted = true;
      S.ui.stripeReadyToPay = false;

      if (D.stripeMount) setHidden(D.stripeMount, false);
      return true;
    } catch (e) {
      console.error(e);
      return false;
    }
  };

  const ensureStripeMountedForCurrentAmount = async () => {
    const payload = buildPaymentsPayload();
    const nextKey = `${payload.amount_cents || 0}:${payload.currency || ""}:${payload.org_id || ""}:${payload.campaign_id || ""}:${payload.team_id || ""}:${payload.impact_id || ""}:${payload.gift_type || ""}`;
    const prevKey = S.ui.__stripeKey || "";

    if (S.ui.stripeMounted && prevKey === nextKey) return true;

    const clientSecret = await createStripeIntent(payload);
    const mounted = await mountStripeElement(clientSecret);
    if (!mounted) return false;

    S.ui.__stripeKey = nextKey;
    return true;
  };

  const handleStripeSubmit = async (e) => {
    e.preventDefault();
    D = cacheDom();

    if (D.payError) setHidden(D.payError, true);
    if (D.paySuccess) setHidden(D.paySuccess, true);

    const donation = Math.max(0, S.ui.amountCents);
    const email = safeText(D.email?.value || "").trim();

    if (donation <= 0) return setCheckoutError("Enter an amount.");
    if (!emailOk(email)) return setCheckoutError("Enter a valid email for your receipt.");
    if (!stripePk) return setCheckoutError("Stripe is not configured yet.");

    try {
      setCheckoutBusy(true);

      // Step 1: mount payment element (create intent). Do NOT confirm yet.
      if (!S.ui.stripeMounted) {
        const ok = await ensureStripeMountedForCurrentAmount();
        if (!ok) throw new Error("Unable to load payment form.");

        setCheckoutBusy(false);
        updateSummaryUI();
        toast("Enter payment details, then click Pay now.", "info");
        try {
          D.paymentElementHost?.scrollIntoView({ behavior: prefersReducedMotion() ? "auto" : "smooth", block: "center" });
        } catch {}
        return;
      }

      // If mounted but amount/team/need changed, remount with new intent and ask for confirmation again.
      const ok2 = await ensureStripeMountedForCurrentAmount();
      if (!ok2) throw new Error("Unable to update payment form.");

      // Step 2: confirm payment
      const { error } = await S.ui.stripe.confirmPayment({
        elements: S.ui.elements,
        confirmParams: { return_url: stripeReturnUrl },
        redirect: "if_required",
      });

      if (error) throw new Error(error.message || "Payment failed.");

      setCheckoutSuccess("Thank you! Your receipt has been emailed.");
      toast("Payment successful.", "success");

      // display-only bump (server remains source of truth)
      S.fundraiser.raisedCents += donation;
      setProgressUI();
      renderRecentGifts();
      renderSponsorBoard();
      applyKpis();
    } catch (err) {
      console.error(err);
      setCheckoutError(err?.message || "Payment failed. Please try again.");
      toast("Payment error.", "error");
    } finally {
      setCheckoutBusy(false);
    }
  };

  /* ---------------------------------------------
   * Payments: PayPal (optional)
   * -------------------------------------------*/
  const ensurePayPal = async () => {
    if (!paypalClientId || captureMode) return false;
    if (window.paypal && window.paypal.Buttons) return true;

    if (typeof window.ffLoadPayPal === "function") {
      try {
        const ok = await window.ffLoadPayPal();
        return !!(ok && window.paypal && window.paypal.Buttons);
      } catch {
        return false;
      }
    }

    const src = `https://www.paypal.com/sdk/js?client-id=${encodeURIComponent(paypalClientId)}&currency=${encodeURIComponent(
      paypalCurrency
    )}&intent=${encodeURIComponent(paypalIntent)}`;
    const ok = await loadScriptOnce(src, "ffPayPalJs");
    return !!(ok && window.paypal && window.paypal.Buttons);
  };

  const initPayPal = async () => {
    D = cacheDom();
    if (!paypalClientId || !D.paypalMount || !D.paypalButtonsHost) return;

    try {
      setHidden(D.paypalMount, false);

      const ok = await ensurePayPal();
      if (!ok) {
        setHidden(D.paypalMount, true);
        return;
      }

      window.paypal
        .Buttons({
          style: { layout: "vertical" },
          createOrder: async () => {
            const donation = Math.max(0, S.ui.amountCents);
            const email = safeText(D.email?.value || "").trim();
            if (donation <= 0) throw new Error("Enter an amount.");
            if (!emailOk(email)) throw new Error("Enter a valid email.");

            const payload = buildPaymentsPayload();
            const headers = { "Content-Type": "application/json" };
            if (csrfToken) headers["X-CSRF-Token"] = csrfToken;

            const data = await fetchJson(paypalCreateEndpoint, {
              method: "POST",
              headers,
              body: JSON.stringify({ ...payload, paypal: { currency: paypalCurrency, intent: paypalIntent } }),
              credentials: "same-origin",
            });

            return data.order_id || data.id;
          },
          onApprove: async (data) => {
            const headers = { "Content-Type": "application/json" };
            if (csrfToken) headers["X-CSRF-Token"] = csrfToken;

            await fetchJson(paypalCaptureEndpoint, {
              method: "POST",
              headers,
              body: JSON.stringify({ order_id: data.orderID }),
              credentials: "same-origin",
            });

            setCheckoutSuccess("Thank you! Your receipt has been emailed.");
            toast("Payment successful.", "success");

            S.fundraiser.raisedCents += Math.max(0, S.ui.amountCents);
            setProgressUI();
            renderRecentGifts();
            renderSponsorBoard();
            applyKpis();
          },
          onError: (err) => {
            console.error(err);
            setCheckoutError("PayPal error. Please try Stripe or refresh.");
          },
        })
        .render(D.paypalButtonsHost);

      S.ui.paypalReady = true;
    } catch (e) {
      console.error(e);
      setHidden(D.paypalMount, true);
    }
  };

  /* ---------------------------------------------
   * Share controls (v14 compat-first)
   * -------------------------------------------*/
  const bindShareControls = () => {
    D = cacheDom();

    for (const btn of D.shareCopyBtns) {
      if (btn.__ffBoundCopy) continue;
      btn.__ffBoundCopy = true;
      on(btn, "click", async () => {
        const url = buildShareUrl();
        const ok = await copyToClipboard(url);
        toast(ok ? "Link copied." : "Copy failed.", ok ? "success" : "error");
      });
    }

    for (const btn of D.shareOpenBtns) {
      if (btn.__ffBoundShareOpen) continue;
      btn.__ffBoundShareOpen = true;
      on(btn, "click", async () => {
        if (D.drawer && !D.drawer.hidden) closeDrawer();

        const shareModal = findModal("share");
        if (shareModal) {
          bindModalCloseWiring(shareModal);
          setShareFields();
          openModal(shareModal);
          return;
        }

        const url = buildShareUrl();
        if (navigator.share) {
          try {
            await navigator.share({ title: document.title, text: "Support this fundraiser.", url });
            toast("Shared.", "success");
            return;
          } catch {}
        }
        const ok = await copyToClipboard(url);
        toast(ok ? "Link copied." : "Copy failed.", ok ? "success" : "error");
      });
    }

    for (const btn of D.shareNativeBtns) {
      if (btn.__ffBoundNative) continue;
      btn.__ffBoundNative = true;
      on(btn, "click", async () => {
        const url = buildShareUrl();
        if (navigator.share) {
          try {
            await navigator.share({ title: document.title, text: "Support this fundraiser.", url });
            toast("Shared.", "success");
            return;
          } catch {}
        }
        const ok = await copyToClipboard(url);
        toast(ok ? "Link copied." : "Copy failed.", ok ? "success" : "error");
      });
    }

    if (D.shareLink) {
      on(D.shareLink, "focus", () => {
        try {
          D.shareLink.select();
        } catch {}
      });
    }
  };

  const bindCopyLinkCompat = () => {
    qsa("[data-ff-copy-link]").forEach((btn) => {
      if (btn.__ffBoundCopy2) return;
      btn.__ffBoundCopy2 = true;
      on(btn, "click", async (e) => {
        e.preventDefault();
        const ok = await copyToClipboard(buildShareUrl());
        toast(ok ? "Link copied." : "Copy failed.", ok ? "success" : "error");
      });
    });
  };

  const bindAutoShareFieldRefresh = () => {
    const rerender = debounce(() => setShareFields(), 80);
    on(window, "popstate", rerender);
  };

  /* ---------------------------------------------
   * v14 Theme toggle
   * -------------------------------------------*/
  const initThemeToggle = () => {
    D = cacheDom();
    if (!D.themeToggle) return;

    const applyBtnState = () => {
      const t = document.documentElement.getAttribute("data-theme") || "dark";
      setAriaPressed(D.themeToggle, t === "dark");
    };

    applyBtnState();

    on(D.themeToggle, "click", () => {
      try {
        const cur = document.documentElement.getAttribute("data-theme") || "dark";
        const next = cur === "dark" ? "light" : "dark";
        document.documentElement.setAttribute("data-theme", next);
        localStorage.setItem("ff_theme_v12", next);
        applyBtnState();
        toast(next === "dark" ? "Dark mode." : "Light mode.", "info");
      } catch {
        toast("Theme toggle unavailable.", "error");
      }
    });
  };

  /* ---------------------------------------------
   * v14 Drawer (mobile menu)
   * -------------------------------------------*/
  const openDrawer = () => {
    D = cacheDom();
    if (!D.drawer || captureMode) return;

    S.ui.__lastActiveEl = document.activeElement || null;
    setHidden(D.drawer, false);
    D.drawer.setAttribute("aria-hidden", "false");

    try {
      document.body.style.overflow = "hidden";
    } catch {}

    D.drawerOpenBtns.forEach((b) => b.setAttribute("aria-expanded", "true"));
    try {
      (D.drawerPanel || D.drawer).focus?.();
    } catch {}
  };

  const closeDrawer = () => {
    D = cacheDom();
    if (!D.drawer) return;

    setHidden(D.drawer, true);
    D.drawer.setAttribute("aria-hidden", "true");

    try {
      document.body.style.overflow = "";
    } catch {}

    D.drawerOpenBtns.forEach((b) => b.setAttribute("aria-expanded", "false"));

    if (C?.flagship?.accessibility?.focusRestore !== false) {
      try {
        S.ui.__lastActiveEl?.focus?.();
      } catch {}
    }
  };

  const initDrawer = () => {
    D = cacheDom();
    if (!D.drawer) return;

    for (const b of D.drawerOpenBtns) on(b, "click", (e) => (e.preventDefault(), openDrawer()));
    for (const b of D.drawerCloseBtns) on(b, "click", (e) => (e.preventDefault(), closeDrawer()));

    on(D.drawer, "click", (e) => {
      const t = e.target;
      if (!t || !(t instanceof Element)) return;
      if (t.matches(".ff-drawer__backdrop")) {
        e.preventDefault();
        closeDrawer();
      }
    });

    on(document, "keydown", (e) => {
      if (e.key === "Escape" && D.drawer && !D.drawer.hidden) closeDrawer();
    });

    D.drawerOpenBtns.forEach((b) => b.setAttribute("aria-expanded", "false"));
  };

  /* ---------------------------------------------
   * Topbar dismiss (persisted)
   * -------------------------------------------*/
  const initTopbarDismiss = () => {
    D = cacheDom();
    if (!D.topbar) return;
    const key = `ff_topbar_dismiss_${shellEnv.orgId}_${shellEnv.campaignId}`;
    try {
      if (localStorage.getItem(key)) setHidden(D.topbar, true);
    } catch {}

    if (D.topbarDismiss) {
      on(D.topbarDismiss, "click", () => {
        setHidden(D.topbar, true);
        try {
          localStorage.setItem(key, String(now()));
        } catch {}
      });
    }
  };

  /* ---------------------------------------------
   * Proof / Policy open (modal if exists, else scroll)
   * -------------------------------------------*/
  const bindProofAndPolicy = () => {
    D = cacheDom();

    const openKind = (kind) => {
      const el = findModal(kind);
      if (el) {
        bindModalCloseWiring(el);
        openModal(el);
        return;
      }
      const anchor = qs(`#${kind}`) || qs(`#ff${kind[0]?.toUpperCase() || ""}${kind.slice(1)}`);
      if (anchor) {
        anchor.scrollIntoView({ behavior: prefersReducedMotion() ? "auto" : "smooth", block: "start" });
        return;
      }
      toast(`${kind === "proof" ? "Proof kit" : "Trust center"} not available in this layout.`, "info");
    };

    D.proofOpenBtns.forEach((btn) => on(btn, "click", (e) => (e.preventDefault(), closeDrawer(), openKind("proof"))));
    D.policyOpenBtns.forEach((btn) => on(btn, "click", (e) => (e.preventDefault(), closeDrawer(), openKind("policy"))));
  };

  /* ---------------------------------------------
   * Gallery (v14)
   * Reads: cfg.gallery.items OR #ffGalleryData
   * -------------------------------------------*/
  const normalizeGalleryItems = (items) => {
    if (!Array.isArray(items)) return [];
    return items
      .map((it) => {
        if (!it) return null;
        if (typeof it === "string") return { src: it, alt: "", caption: "" };
        if (typeof it === "object") {
          return { src: it.src || it.url || it.image || "", alt: it.alt || "", caption: it.caption || it.title || "" };
        }
        return null;
      })
      .filter((x) => x && x.src);
  };

  const ensureGallerySectionVisibility = (items) => {
    D = cacheDom();
    const grid = D.galleryGrid;
    const section = grid?.closest("section") || qs("[data-ff-gallery-grid]")?.closest("section");
    if (!section) return;
    if (!items || !items.length) {
      if (grid) grid.innerHTML = "";
      return;
    }
    section.hidden = false;
  };

  const openGalleryAt = (idx = 0) => {
    D = cacheDom();
    const modal = D.galleryModal || findModal("gallery");
    if (!modal) return false;

    bindModalCloseWiring(modal);
    openModal(modal);

    setTimeout(() => {
      const target = qs(`[data-ff-gallery-all] [data-ff-gallery-idx="${idx}"]`);
      if (target) {
        try {
          target.scrollIntoView({ block: "center", behavior: prefersReducedMotion() ? "auto" : "smooth" });
        } catch {}
        try {
          target.focus?.();
        } catch {}
      }
    }, 60);

    return true;
  };

  const renderGallery = (items) => {
    D = cacheDom();
    const grid = D.galleryGrid;
    const all = D.galleryAll;
    if (!grid && !all) return;

    const safeImgSrc = (src) => escapeHTML(safeUrl(src) || src);

    if (grid) {
      const preview = items.slice(0, 6);
      grid.innerHTML = preview
        .map(
          (it, idx) => `
        <button type="button" class="ff-mini ff-glass" data-ff-gallery-open data-ff-gallery-idx="${idx}" aria-label="Open gallery image">
          <img src="${safeImgSrc(it.src)}" alt="${escapeHTML(it.alt || "")}" loading="lazy" decoding="async" style="width:100%;height:auto;border-radius:14px;display:block;" />
          ${it.caption ? `<div class="ff-help ff-mt-1">${escapeHTML(it.caption)}</div>` : ``}
        </button>
      `
        )
        .join("");
    }

    if (all) {
      all.innerHTML = items
        .map(
          (it, idx) => `
        <button type="button" class="ff-mini ff-glass" data-ff-gallery-idx="${idx}" aria-label="View image">
          <img src="${safeImgSrc(it.src)}" alt="${escapeHTML(it.alt || "")}" loading="lazy" decoding="async" style="width:100%;height:auto;border-radius:14px;display:block;" />
          ${it.caption ? `<div class="ff-help ff-mt-1">${escapeHTML(it.caption)}</div>` : ``}
        </button>
      `
        )
        .join("");
    }

    qsa("[data-ff-gallery-open]").forEach((btn) => {
      if (btn.__ffBound_gallery) return;
      btn.__ffBound_gallery = true;
      on(btn, "click", () => {
        const i = toInt(btn.getAttribute("data-ff-gallery-idx"), 0);
        openGalleryAt(i);
      });
    });
  };

  const bootstrapGalleryFromDomOrConfig = () => {
    const enabledByFeature = C?.flagship?.features?.gallery !== false;
    if (!enabledByFeature) {
      ensureGallerySectionVisibility([]);
      return;
    }

    let items = normalizeGalleryItems(S.gallery?.items || []);
    if (!items.length) {
      const el = document.getElementById("ffGalleryData");
      if (el) items = normalizeGalleryItems(parseJSON(el.textContent || "[]", []));
    }

    const enabled = S.gallery?.enabled === true || items.length > 0;
    if (!enabled) {
      ensureGallerySectionVisibility([]);
      return;
    }

    ensureGallerySectionVisibility(items);
    renderGallery(items);

    D = cacheDom();
    D.galleryOpenBtns.forEach((btn) => {
      if (btn.__ffBound_galleryOpen) return;
      btn.__ffBound_galleryOpen = true;
      on(btn, "click", (e) => {
        e.preventDefault();
        const idx = toInt(btn.getAttribute("data-ff-gallery-idx"), 0);
        openGalleryAt(idx);
      });
    });
  };

  /* ---------------------------------------------
   * Chrome height CSS var patch (v14)
   * -------------------------------------------*/
  const initChromeHeightVar = () => {
    const root = document.documentElement;
    const chrome = document.querySelector(".ff-chrome");
    if (!chrome) return;

    const set = () => {
      const h = Math.ceil(chrome.getBoundingClientRect().height);
      root.style.setProperty("--ff-chrome-h", `${h}px`);
    };

    set();
    window.addEventListener("resize", set, { passive: true });
    setTimeout(set, 120);
  };

  /* ---------------------------------------------
   * Sponsor/Team/Impact control binders
   * -------------------------------------------*/
  const bindSponsorAndTeamAndImpact = () => {
    bindImpactControls();
    bindSponsorControls();
    bindTeamControls();
  };

  /* ---------------------------------------------
   * Share + QR wiring
   * -------------------------------------------*/
  const initShare = () => {
    setShareFields();
    bindShareControls();
    bindCopyLinkCompat();
    bindAutoShareFieldRefresh();
  };

  /* ---------------------------------------------
   * Init
   * -------------------------------------------*/
  const init = async () => {
    D = cacheDom();

    S.fundraiser.raisedCents = deriveRaisedCents();

    applyBrand();
    applyAnnouncement();
    initTopbarDismiss();

    renderAllocation();
    renderImpact();

    renderSponsorTiers();
    renderSponsorBoard();

    renderTeams();

    setProgressUI();
    applyUpdated();
    startDeadlineLoop();
    applyMatch();
    applyEventPill();

    readUtm();
    initShare();

    applyPopularAmount();
    syncRecognitionUI();
    updateSummaryUI();
    bindDonateControls();
    renderRecentGifts();
    applyKpis();

    injectFrequencyToggle();
    bindAnchors();
    bindScrollProgress();
    initInview();

    initThemeToggle();
    initDrawer();
    bindProofAndPolicy();

    bootstrapGalleryFromDomOrConfig();
    initChromeHeightVar();
    initStickySupport();

    // Bind remaining controls after initial render
    bindSponsorAndTeamAndImpact();

    // Stripe form submit
    D = cacheDom();
    if (D.donationForm) on(D.donationForm, "submit", handleStripeSubmit);

    // Stripe redirect success hint (server should verify)
    try {
      const u = new URL(window.location.href);
      const rs = u.searchParams.get("redirect_status") || "";
      if (rs === "succeeded") setCheckoutSuccess("Payment successful. Your receipt has been emailed.");
    } catch {}

    if (paypalClientId) initPayPal();

    // Expose minimal API
    window.FF = window.FF || {};
    window.FF.toast = window.FF.toast || toast;
    window.FF.buildShareUrl = window.FF.buildShareUrl || buildShareUrl;
    window.FF.setShareFields = window.FF.setShareFields || setShareFields;
    window.FF.scrollToDonate = window.FF.scrollToDonate || scrollToDonate;

    // Optional convenience: allow prefill via global helper
    window.FF.__setPrefill = window.FF.__setPrefill || setPrefill;
    window.FF.__setTeam = window.FF.__setTeam || setSelectedTeam;
  };

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", init, { once: true });
  } else {
    init();
  }
})();

