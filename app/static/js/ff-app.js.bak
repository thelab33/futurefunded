/*! ff-app.js â€” FutureFunded Flagship v15.0.1 PRO (drop-in replacement)
  PATCH NOTES (v15.0.1-pro):
    - Stripe â€œcard incompleteâ€ fix (no element resets on submit; mount once per clientSecret)
    - Adds elements.submit() before confirmPayment()
    - Intent request de-dupe + stale-response protection
    - PayPal loader hardened (script ID + src handling)
    - metaBool parsing hardened (true/1/yes/on)
    - Fixes fees merge bug (removes accidental assignment side-effect)
    - Supports BOTH meta endpoints: ff-stripe-intent-endpoint AND ff-checkout-endpoint
    - CSRF header hardened (X-CSRF-Token + X-CSRFToken)
    - Keeps v13/v14 selectors + contract exports intact
*/
(() => {
  "use strict";

  // Prevent double-init (v13/v14/v15 compat)
  if (
    window.__FF_APP_V15_LOADED ||
    window.__FF_APP_V14_2_LOADED ||
    window.__FF_APP_V14_LOADED ||
    window.__FF_APP_V13_LOADED
  )
    return;

  window.__FF_APP_V15_LOADED = true;
  window.__FF_APP_V14_2_LOADED = true;
  window.__FF_APP_V14_LOADED = true;
  window.__FF_APP_V13_LOADED = true;

  /* ---------------------------------------------
   * Utilities
   * -------------------------------------------*/
  const qs = (sel, root = document) => root.querySelector(sel);
  const qsa = (sel, root = document) => Array.from(root.querySelectorAll(sel));
  const on = (el, ev, fn, opt) => el && el.addEventListener(ev, fn, opt);
  const safeText = (v) => (v == null ? "" : String(v));
  const clamp = (n, a, b) => Math.min(b, Math.max(a, n));
  const toInt = (v, def = 0) => {
    const n = Number.parseInt(String(v ?? ""), 10);
    return Number.isFinite(n) ? n : def;
  };
  const toNum = (v, def = 0) => {
    const n = Number(v);
    return Number.isFinite(n) ? n : def;
  };
  const now = () => Date.now();

  const parseJSON = (txt, fallback) => {
    try {
      return JSON.parse(txt);
    } catch {
      return fallback;
    }
  };

  const decodeMaybeBase64Json = (txt, fallback) => {
    const s = safeText(txt).trim();
    if (!s) return fallback;
    if (s.startsWith("{") || s.startsWith("[")) return parseJSON(s, fallback);
    try {
      const decoded = atob(s);
      return parseJSON(decoded, fallback);
    } catch {
      return fallback;
    }
  };

  const debounce = (fn, ms = 150) => {
    let t = null;
    return (...args) => {
      clearTimeout(t);
      t = setTimeout(() => fn(...args), ms);
    };
  };

  const prefersReducedMotion = () => {
    try {
      return window.matchMedia && window.matchMedia("(prefers-reduced-motion: reduce)").matches;
    } catch {
      return false;
    }
  };

  const safeUrl = (raw) => {
    const s = safeText(raw).trim();
    if (!s) return "";
    try {
      const u = new URL(s, window.location.origin);
      const p = (u.protocol || "").toLowerCase();
      if (p === "http:" || p === "https:" || p === "mailto:" || p === "tel:") return u.toString();
      return "";
    } catch {
      return "";
    }
  };

  // Images: allow http/https, blob, and data:image/* EXCEPT svg
  const safeImgUrl = (raw) => {
    const s = safeText(raw).trim();
    if (!s) return "";
    try {
      if (s.startsWith("data:image/svg")) return "";
      if (s.startsWith("data:image/")) return s;
      const u = new URL(s, window.location.origin);
      const p = (u.protocol || "").toLowerCase();
      if (p === "http:" || p === "https:" || p === "blob:") return u.toString();
      return "";
    } catch {
      return "";
    }
  };

  const cssEscape = (s) => {
    if (window.CSS && typeof window.CSS.escape === "function") return window.CSS.escape(s);
    return safeText(s).replace(/[^a-zA-Z0-9_\-]/g, "\\$&");
  };

  const parseMoneyToCents = (raw) => {
    const s = safeText(raw).trim();
    if (!s) return 0;
    const cleaned = s.replace(/[^\d.]/g, "");
    if (!cleaned) return 0;
    const parts = cleaned.split(".");
    const whole = parts[0] || "0";
    const frac = (parts[1] || "").slice(0, 2).padEnd(2, "0");
    const cents = toInt(whole, 0) * 100 + toInt(frac, 0);
    return Math.max(0, cents);
  };

  const formatCurrency = (cents, currency = "USD", locale = "en-US", exact = false) => {
    const n = (toNum(cents, 0) / 100) || 0;
    try {
      return new Intl.NumberFormat(locale, {
        style: "currency",
        currency,
        minimumFractionDigits: exact ? 2 : 0,
        maximumFractionDigits: exact ? 2 : 0,
      }).format(n);
    } catch {
      return `$${exact ? n.toFixed(2) : Math.round(n).toLocaleString("en-US")}`;
    }
  };

  const parseISO = (iso) => {
    if (!iso) return null;
    const d = new Date(iso);
    return Number.isFinite(d.getTime()) ? d : null;
  };

  const humanCountdown = (ms) => {
    const s = Math.max(0, Math.floor(ms / 1000));
    const d = Math.floor(s / 86400);
    const h = Math.floor((s % 86400) / 3600);
    const m = Math.floor((s % 3600) / 60);
    if (d >= 7) return `${d}d`;
    if (d > 0) return `${d}d ${h}h`;
    if (h > 0) return `${h}h ${m}m`;
    if (m > 0) return `${m}m`;
    return "soon";
  };

  const deepMerge = (a, b) => {
    if (!b || typeof b !== "object") return a;
    const out = Array.isArray(a) ? [...a] : { ...(a || {}) };
    for (const [k, v] of Object.entries(b)) {
      if (
        v &&
        typeof v === "object" &&
        !Array.isArray(v) &&
        out[k] &&
        typeof out[k] === "object" &&
        !Array.isArray(out[k])
      ) {
        out[k] = deepMerge(out[k], v);
      } else {
        out[k] = v;
      }
    }
    return out;
  };

  // PATCH: tolerant JSON fetch (handles non-JSON errors)
  const fetchJson = async (
    url,
    { method = "GET", headers = {}, body = null, credentials = "same-origin" } = {}
  ) => {
    const res = await fetch(url, { method, headers, body, credentials });
    const text = await res.text().catch(() => "");
    const data = parseJSON(text, null) || {};
    if (!res.ok) throw new Error(data?.error || data?.message || text || `HTTP ${res.status}`);
    return data;
  };

  const copyToClipboard = async (txt) => {
    const s = safeText(txt);
    try {
      if (navigator.clipboard && navigator.clipboard.writeText) {
        await navigator.clipboard.writeText(s);
        return true;
      }
    } catch {}
    try {
      const ta = document.createElement("textarea");
      ta.value = s;
      ta.style.position = "fixed";
      ta.style.opacity = "0";
      document.body.appendChild(ta);
      ta.focus();
      ta.select();
      const ok = document.execCommand("copy");
      document.body.removeChild(ta);
      return !!ok;
    } catch {
      return false;
    }
  };

  /* ---------------------------------------------
   * DOM builder helpers (no innerHTML)
   * -------------------------------------------*/
  const clearChildren = (host) => {
    if (!host) return;
    while (host.firstChild) host.removeChild(host.firstChild);
  };
  const textNode = (v) => document.createTextNode(v == null ? "" : String(v));

  const h = (tag, attrs = {}, kids = null) => {
    const el = document.createElement(tag);
    for (const [k, v] of Object.entries(attrs || {})) {
      if (v == null) continue;
      if (k === "class") el.className = String(v);
      else if (k === "text") el.textContent = String(v);
      else if (k === "style") el.style.cssText = String(v);
      else if (k === "dataset" && v && typeof v === "object") Object.assign(el.dataset, v);
      else if (k === "aria" && v && typeof v === "object")
        for (const [ak, av] of Object.entries(v)) el.setAttribute(`aria-${ak}`, String(av));
      else if (k === "role") el.setAttribute("role", String(v));
      else if (k === "tabindex") el.tabIndex = Number(v);
      else if (k.startsWith("on") && typeof v === "function") el.addEventListener(k.slice(2), v);
      else if (typeof v === "boolean") {
        if (v) el.setAttribute(k, "");
      } else el.setAttribute(k, String(v));
    }
    if (kids != null) {
      const add = (child) => {
        if (child == null) return;
        if (Array.isArray(child)) child.forEach(add);
        else if (child instanceof Node) el.appendChild(child);
        else el.appendChild(textNode(child));
      };
      add(kids);
    }
    return el;
  };

  const setChildren = (host, kids) => {
    if (!host) return;
    clearChildren(host);
    const add = (child) => {
      if (child == null) return;
      if (Array.isArray(child)) child.forEach(add);
      else host.appendChild(child instanceof Node ? child : textNode(child));
    };
    add(kids);
  };

  /* ---------------------------------------------
   * Meta tags (payments/endpoints only) â€” PATCHED
   * -------------------------------------------*/
  const meta = (name) => (qs(`meta[name="${name}"]`)?.content || "").trim();
  const metaBool = (name, def = false) => {
    const v = meta(name);
    if (!v) return def;
    const s = String(v).trim().toLowerCase();
    return s === "true" || s === "1" || s === "yes" || s === "y" || s === "on";
  };

  const captureMode = document.documentElement.getAttribute("data-ff-capture") === "true";

  // PATCH: CSRF meta supports both names
  const csrfToken = meta("ff-csrf-token") || meta("csrf-token") || "";

  const stripePk = meta("ff-stripe-pk");
  const stripeJsSrc = meta("ff-stripe-js") || "https://js.stripe.com/v3/";

  // PATCH: supports both meta keys (your old HTML used ff-checkout-endpoint)
  const stripeIntentEndpoint =
    meta("ff-stripe-intent-endpoint") || meta("ff-checkout-endpoint") || "/payments/stripe/intent";

  const stripeReturnUrl = meta("ff-stripe-return-url") || window.location.href;
  const stripeThemeMeta = meta("ff-stripe-theme") || "";
  const stripeAutoload = metaBool("ff-stripe-autoload", false);

  const paypalClientId = meta("ff-paypal-client-id");
  const paypalCurrency = meta("ff-paypal-currency") || "USD";
  const paypalIntent = meta("ff-paypal-intent") || "capture";
  const paypalCreateEndpoint = meta("ff-paypal-create-endpoint") || "/payments/paypal/order";
  const paypalCaptureEndpoint = meta("ff-paypal-capture-endpoint") || "/payments/paypal/capture";

  const qrEndpoint = meta("ff-qr-endpoint") || "https://api.qrserver.com/v1/create-qr-code/";

  const payloadShape = meta("ff-payments-payload-shape") || "nested_donor_v1";
  const payloadExtra = decodeMaybeBase64Json(meta("ff-payments-extra-json") || "", {});
  const coverFeesExact = metaBool("ff-cover-fees-exact", false);
  const requireEmail = metaBool("ff-require-email", false);

  /* ---------------------------------------------
   * Shell env (from best [data-ff-shell])
   * -------------------------------------------*/
  const pickShellEl = () => {
    const els = qsa("[data-ff-shell]");
    if (!els.length) return null;
    let best = els[0];
    let bestScore = -1;
    for (const el of els) {
      const d = el.dataset || {};
      const score =
        (d.ffOrg ? 1 : 0) +
        (d.ffCampaign ? 1 : 0) +
        (d.ffTier ? 1 : 0) +
        (d.ffEnv ? 1 : 0) +
        (d.ffVersion ? 1 : 0) +
        (d.ffEmbed ? 1 : 0) +
        (d.ffWhitelabel ? 1 : 0) +
        (d.ffPage ? 1 : 0);
      if (score > bestScore) {
        bestScore = score;
        best = el;
      }
    }
    return best;
  };

  const shellEl = pickShellEl();
  const shellEnv = {
    orgId: safeText(shellEl?.dataset?.ffOrg || "default"),
    campaignId: safeText(shellEl?.dataset?.ffCampaign || "season"),
    tier: safeText(shellEl?.dataset?.ffTier || "standard"),
    env: safeText(shellEl?.dataset?.ffEnv || "prod"),
    version: safeText(shellEl?.dataset?.ffVersion || "15.0.1-pro"),
    embed: safeText(shellEl?.dataset?.ffEmbed || "false") === "true",
    whiteLabel: safeText(shellEl?.dataset?.ffWhitelabel || "false") === "true",
    page: safeText(shellEl?.dataset?.ffPage || "fundraiser"),
  };

  /* ---------------------------------------------
   * Config (UI/content only) from #ffConfig
   * -------------------------------------------*/
  const readConfigFromScript = () => {
    const scripts = qsa('script#ffConfig[type="application/json"]');
    if (!scripts.length) return {};
    for (let i = scripts.length - 1; i >= 0; i--) {
      const raw = (scripts[i].textContent || "").trim();
      if (!raw) continue;
      const parsed = parseJSON(raw, null);
      if (parsed && typeof parsed === "object") return parsed;
    }
    return {};
  };

  const DEFAULTS = {
    org: {
      name: "Organization",
      meta: "City â€¢ State",
      seasonPill: "Season Fund",
      sportPill: "Youth program",
      heroAccentLine: "Keep kids playing.",
      footerTagline: "Fuel the season. Fund the future.",
      announcement: "",
    },
    fundraiser: {
      goalAmount: 25000,
      raisedAmount: null,
      deadlineISO: "",
      updatedISO: "",
      allocationUpdatedISO: "",
      match: null,
      allocation: [
        { label: "Gym time + training", pct: 35 },
        { label: "Tournaments + fees", pct: 30 },
        { label: "Travel support", pct: 25 },
        { label: "Scholarships", pct: 10 },
      ],
      impact: [],
      sponsorTiers: [],
      sponsors: [],
      recentGifts: [],
      popularAmountCents: 7500,
      fees: { enabledCoverFees: true, percent: 0.029, fixedCents: 30, maxCents: 0 },
    },
    teams: [],
    gallery: { enabled: false, items: [] },
    flagship: {
      features: { shareAttribution: true, gallery: true },
      defaults: { currency: "USD", locale: "en-US", timezone: "America/Chicago" },
      analytics: { utm: { enabled: true, sourceParam: "src", campaignParam: "cmp" } },
      accessibility: { reducedMotionRespect: true, focusRestore: true, ariaLiveToasts: true },
    },
  };

  const C = deepMerge(DEFAULTS, readConfigFromScript() || {});
  const locale = safeText(C?.flagship?.defaults?.locale || "en-US");
  const currency = safeText(C?.flagship?.defaults?.currency || "USD");

  /* ---------------------------------------------
   * DOM cache
   * -------------------------------------------*/
  const ensureToastsHost = () => {
    let host = qs("[data-ff-toasts]");
    if (host) return host;
    host = document.createElement("div");
    host.className = "ff-toasts";
    host.setAttribute("data-ff-toasts", "true");
    document.body.appendChild(host);
    return host;
  };

  const cacheDom = () => ({
    orgName: qs("#orgName"),
    orgMeta: qs("#orgMeta"),
    footerOrgName: qs("#footerOrgName"),
    footerOrgMeta: qs("#footerOrgMeta"),
    seasonPill: qs("#seasonPill"),
    sportPill: qs("#sportPill"),
    heroAccentLine: qs("#heroAccentLine"),
    heroOrgLine: qs("#heroOrgLine"),

    topbar: qs("[data-ff-topbar], #ffTopbar"),
    topbarRaised: qs("#topbarRaised"),
    topbarGoal: qs("#topbarGoal"),
    topbarDeadline: qs("#topbarDeadline"),
    topbarCountdown: qs("#topbarCountdown"),
    topbarMatchStrip: qs("[data-ff-match-strip]"),
    topbarMatchText: qs("#topbarMatchText"),
    topbarMatchRemaining: qs("#topbarMatchRemaining"),
    topbarDismiss: qs("[data-ff-topbar-dismiss]"),

    heroCountdown: qs("#heroCountdown"),
    heroEventPill: qs("#heroEventPill, [data-ff-event-pill]"),

    raisedBig: qs("#raisedBig"),
    remainingText: qs("#remainingText"),
    deadlineText: qs("#deadlineText"),
    lastUpdatedText: qs("#lastUpdatedText"),
    goalPill: qs("#goalPill"),
    raisedRow: qs("#raisedRow"),
    goalRow: qs("#goalRow"),
    pctText: qs("#pctText"),
    overallBar: qs("#overallBar"),
    scrollProgressBar: qs("#scrollProgressBar"),

    donorCount: qs("#donorCount"),
    avgGift: qs("#avgGift"),
    topGift: qs("#topGift"),

    heroMatchPill: qs("#heroMatchPill"),
    matchDetailRow: qs("[data-ff-match-details]"),
    matchRemainingPill: qs("#matchRemainingPill"),
    matchEndsPill: qs("#matchEndsPill"),
    matchStatus: qs("#matchStatus"),
    sponsorMatchPill: qs("[data-ff-sponsor-match-pill]"),
    matchCallout: qs("[data-ff-match-callout]"),
    matchCalloutText: qs("[data-ff-match-callout-text]"),

    announce: qs("[data-ff-announcement]"),
    announcementText: qs("#announcementText"),
    announceDismiss: qs("[data-ff-announcement-dismiss]"),

    shareLink: qs("#shareLink"),
    shareCopyBtns: qsa("[data-ff-copy-link], [data-ff-copy-share]"),
    shareNativeBtns: qsa("[data-ff-native-share]"),
    shareOpenBtns: qsa("[data-ff-share-open]"),
    smsShareBtns: qsa("[data-ff-sms-share]"),
    emailShareBtns: qsa("[data-ff-email-share]"),
    copyCaptionBtns: qsa("[data-ff-copy-caption]"),
    proofCaption: qs("#proofCaption"),
    proofDonorName: qs("#proofDonorName"),
    proofAmount: qs("#proofAmount"),
    qrImgs: qsa("[data-ff-qr]"),
    downloadQrBtns: qsa("[data-ff-download-qr]"),

    allocationList: qs("[data-ff-allocation-list]"),
    allocationUpdated: qs("[data-ff-allocation-updated]"),
    allocationUpdatedText: qs("[data-ff-allocation-updated-text]"),

    impactGrid: qs("[data-ff-impact-grid]"),
    impactEmpty: qs("[data-ff-impact-empty]"),
    impactSearch: qs("[data-ff-impact-search]"),
    impactFilterBtns: qsa("[data-ff-impact-filter]"),

    sponsorTiersHost: qs("[data-ff-sponsor-tiers]"),
    sponsorPodium: qs("[data-ff-sponsor-podium]"),
    sponsorList: qs("[data-ff-sponsor-leaderboard]"),
    sponsorSortBtns: qsa("[data-ff-sponsor-sort] [data-ff-sort]"),
    sponsorWall: qs("[data-ff-sponsor-wall]"),
    sponsorWallViewBtns: qsa("[data-ff-sponsor-wall-view] [data-ff-wall]"),
    refreshSponsorsBtn: qs("[data-ff-refresh-sponsors]"),

    teamsGrid: qs("[data-ff-teams-grid], #teamsGrid"),
    teamsStatus: qs("[data-ff-teams-status]"),
    teamSearch: qs("[data-ff-team-search]"),
    teamSortBtns: qsa("[data-ff-team-sort] [data-ff-sort]"),
    attribBox: qs("[data-ff-attrib-box]"),
    attribTitle: qs("[data-ff-attrib-title]"),
    attribHelp: qs("[data-ff-attrib-help]"),
    attribClearBtns: qsa("[data-ff-attrib-clear]"),
    summaryTeamRow: qs("#summaryTeamRow"),
    summaryTeam: qs("#summaryTeam"),

    donationForm: qs("#donationForm"),
    amount: qs("#amount"),
    email: qs("#email"),
    fullName: qs("#fullName"),
    message: qs("#message"),
    anonymous: qs("#anonymous"),
    coverFees: qs("#coverFees"),
    payBtn: qs("#payBtn"),
    payError: qs("#payError"),
    payErrorText: qs("#payErrorText"),
    paySuccess: qs("#paySuccess"),
    paySuccessText: qs("#paySuccessText"),
    summaryAmount: qs("#summaryAmount"),
    summaryFees: qs("#summaryFees"),
    summaryTotal: qs("#summaryTotal"),
    receiptEmail: qs("#receiptEmail"),
    checkoutStatusText: qs("#checkoutStatusText"),
    checkoutMethodPill: qs("[data-ff-payment-method]"),
    checkoutMethodText: qs("#checkoutMethodText"),

    // PATCH: prefer explicit mount id first
    paymentElementHost:
      qs("#paymentElement") ||
      qs("#stripeMount") ||
      qs("[data-ff-stripe-host]") ||
      qs("[data-ff-stripe-element]") ||
      qs("#stripeElement"),
    stripeMount: qs("#stripeMount"),
    paypalMount: qs("#paypalMount"),
    paypalButtonsHost: qs("[data-ff-paypal-buttons], #paypalButtons, #paypalButtonsHost"),
    paymentLive: qs("[data-ff-payment-live]"),

    recognitionBtns: qsa("[data-ff-recognition]"),
    recognitionPreviewText: qs("#recognitionPreviewText"),

    quickAmountBtns: qsa("[data-ff-quick-amount], [data-quick-amount]"),
    clearAmountBtn: qs("[data-ff-clear-amount]"),
    popularAmountPill: qs("[data-ff-popular-amount]"),
    popularAmountText: qs("#popularAmountText"),
    sponsorCtas: qsa("[data-ff-sponsor-cta]"),
    prefills: qsa("[data-ff-prefill]"),

    recentGiftsHost: qs("[data-ff-recent-gifts]"),
    refreshBtns: qsa("[data-ff-refresh]"),

    backToTopBtn: qs(".ff-backtotop, [data-ff-backtotop], #backToTop"),
    tabLinks: qsa('[data-ff-tab][href^="#"]'),
    anchorLinks: qsa('a[href^="#"]:not([href="#"])'),

    toasts: ensureToastsHost(),

    themeToggle: qs("[data-ff-theme-toggle]"),
    drawer: qs("[data-ff-drawer], #mobileDrawer"),
    drawerOpenBtns: qsa("[data-ff-drawer-open]"),
    drawerCloseBtns: qsa("[data-ff-drawer-close]"),

    proofOpenBtns: qsa("[data-ff-proof-open]"),
    policyOpenBtns: qsa("[data-ff-policy-open]"),

    galleryGrid: qs("[data-ff-gallery-grid]"),
    galleryAll: qs("[data-ff-gallery-all]"),
    galleryOpenBtns: qsa("[data-ff-gallery-open]"),

    stickySupport: qs('[data-ff-sticky="support"], .ff-sticky, #ffStickySupport'),
    stickyRaised: qs("#stickyRaised"),
    stickyGoal: qs("#stickyGoal"),
  });

  let D = cacheDom();

  /* ---------------------------------------------
   * Toasts
   * -------------------------------------------*/
  const toast = (msg, kind = "info") => {
    if (captureMode) return;
    D = D || cacheDom();
    const host = D.toasts;
    if (!host) return;

    const ariaLive = C?.flagship?.accessibility?.ariaLiveToasts !== false;

    const t = h("div", {
      class: `ff-toast ff-toast--${kind}`,
      role: "status",
      aria: ariaLive ? { live: "polite" } : {},
      style: "opacity:0;transform:translateY(6px);",
    });

    t.appendChild(h("div", { class: "ff-kicker", text: safeText(kind) }));
    t.appendChild(h("div", { class: "ff-help", text: safeText(msg) }));
    host.appendChild(t);

    requestAnimationFrame(() => {
      t.style.opacity = "1";
      t.style.transform = "translateY(0)";
    });

    setTimeout(() => {
      t.style.opacity = "0";
      t.style.transform = "translateY(-2px)";
    }, 2400);

    setTimeout(() => {
      try {
        host.removeChild(t);
      } catch {}
    }, 2900);
  };

  /* ---------------------------------------------
   * State
   * -------------------------------------------*/
  const S = {
    org: {
      name: safeText(C.org?.name),
      meta: safeText(C.org?.meta),
      seasonPill: safeText(C.org?.seasonPill),
      sportPill: safeText(C.org?.sportPill),
      heroAccentLine: safeText(C.org?.heroAccentLine),
      footerTagline: safeText(C.org?.footerTagline),
    },
    fundraiser: {
      goalCents: toInt(C.fundraiser?.goalAmount, 0) * 100,
      deadlineISO: safeText(C.fundraiser?.deadlineISO || ""),
      updatedISO: safeText(C.fundraiser?.updatedISO || ""),
      allocationUpdatedISO: safeText(C.fundraiser?.allocationUpdatedISO || ""),
      match: C.fundraiser?.match || null,
      allocation: Array.isArray(C.fundraiser?.allocation) ? C.fundraiser.allocation : DEFAULTS.fundraiser.allocation,
      impact: Array.isArray(C.fundraiser?.impact) ? C.fundraiser.impact : [],
      sponsorTiers: Array.isArray(C.fundraiser?.sponsorTiers) ? C.fundraiser.sponsorTiers : [],
      sponsors: Array.isArray(C.fundraiser?.sponsors) ? C.fundraiser.sponsors : [],
      recentGifts: Array.isArray(C.fundraiser?.recentGifts) ? C.fundraiser.recentGifts : [],
      popularAmountCents: toInt(C.fundraiser?.popularAmountCents, DEFAULTS.fundraiser.popularAmountCents),

      // PATCH: correct merge (no assignment side effects)
      fees: deepMerge(DEFAULTS.fundraiser.fees, C?.fundraiser?.fees || {}),

      raisedCents: 0,
    },
    teams: Array.isArray(C.teams) ? C.teams.slice() : [],
    gallery: deepMerge(DEFAULTS.gallery, C.gallery || {}),
    ui: {
      impactFilter: "all",
      impactQuery: "",
      sponsorSort: "rank",
      sponsorWall: "logos",
      teamSort: "featured",
      teamQuery: "",
      selectedTeamId: "",
      selectedTeamName: "",
      purpose: "donation",
      sku: "",
      impactId: "",
      recognition: "public",
      amountCents: 0,
      coverFees: false,

      stripe: null,
      elements: null,
      paymentElement: null,
      paymentElementReady: false,
      clientSecret: "",
      stripeMounted: false,
      stripeBusy: false,
      stripeUserInteracted: false,
      intentPricingKey: "",
      __stripeKey: "",
      __stripeInitInFlight: null,
      __intentReqId: 0,

      // PATCH: intent de-dupe
      __intentInFlightKey: "",
      __intentInFlightPromise: null,

      paypalReady: false,

      __lastActiveEl: null,
      __activeModal: null,
    },
    utm: {},
  };

  /* ---------------------------------------------
   * Normalizers
   * -------------------------------------------*/
  const normalizeTeams = () => {
    const raw = Array.isArray(S.teams) ? S.teams : [];
    return raw
      .filter((t) => t && t.id && t.name)
      .map((t) => {
        const goal = toInt(t.goal, 0) * 100;
        const raised = toInt(t.raised, 0) * 100;
        const pct = goal > 0 ? clamp(Math.round((raised / goal) * 100), 0, 999) : 0;
        return {
          id: safeText(t.id),
          name: safeText(t.name),
          meta: safeText(t.meta || ""),
          goalCents: goal,
          raisedCents: raised,
          pct,
          featured: !!t.featured,
          needs: !!t.needs,
          restricted: !!t.restricted,
          photo: safeText(t.photo || ""),
          ask: safeText(t.ask || ""),
          ts: parseISO(t.tsISO || t.timestamp || "")?.getTime() || 0,
        };
      });
  };

  const normalizeImpactList = () => {
    const cats = new Set(["gear", "travel", "fees", "scholarship"]);
    const items = Array.isArray(S.fundraiser.impact) ? S.fundraiser.impact : [];
    return items
      .filter((x) => x && x.id && x.title)
      .map((x) => ({
        id: safeText(x.id),
        cat: cats.has(safeText(x.cat)) ? safeText(x.cat) : "gear",
        title: safeText(x.title),
        desc: safeText(x.desc || ""),
        amountCents: toInt(x.amountCents ?? (toInt(x.amount, 0) * 100), 0),
      }));
  };

  const normalizeSponsors = () => {
    const raw = Array.isArray(S.fundraiser.sponsors) ? S.fundraiser.sponsors : [];
    return raw
      .map((s) => ({
        name: safeText(s.name || "Sponsor"),
        amountCents: toInt(s.amountCents ?? (toInt(s.amount, 0) * 100), 0),
        logo: safeText(s.logo || ""),
        url: safeUrl(s.url || ""),
        ts: parseISO(s.tsISO || s.timestamp || "")?.getTime() || 0,
      }))
      .filter((x) => x.amountCents > 0);
  };

  const normalizeGifts = () => {
    const raw = Array.isArray(S.fundraiser.recentGifts) ? S.fundraiser.recentGifts : [];
    return raw
      .map((g) => ({
        name: safeText(g.name || "Supporter"),
        anon: !!g.anon || !!g.anonymous,
        amountCents: toInt(g.amountCents ?? (toInt(g.amount, 0) * 100), 0),
        ts: parseISO(g.tsISO || g.timestamp || "")?.getTime() || 0,
      }))
      .filter((x) => x.amountCents > 0);
  };

  /* ---------------------------------------------
   * Exports (contract)
   * -------------------------------------------*/
  window.FF = window.FF || {};
  window.FF.toast = toast;

  /* ---------------------------------------------
   * Small helpers
   * -------------------------------------------*/
  const setHidden = (el, v) => {
    if (!el) return;
    el.hidden = !!v;
    el.setAttribute("aria-hidden", v ? "true" : "false");
  };

  /* ---------------------------------------------
   * Attribution / UTM
   * -------------------------------------------*/
  const setSelectedTeam = (teamId, { silent } = { silent: false }) => {
    D = cacheDom();

    const id = safeText(teamId || "");
    S.ui.selectedTeamId = id;

    const team = normalizeTeams().find((t) => t.id === id);
    S.ui.selectedTeamName = team ? team.name : "";

    const has = !!S.ui.selectedTeamId;
    if (D.attribBox) setHidden(D.attribBox, !has);
    if (D.attribTitle) D.attribTitle.textContent = "Supporting a team";
    if (D.attribHelp)
      D.attribHelp.textContent = has
        ? `This donation will credit ${S.ui.selectedTeamName}.`
        : "This donation will credit the selected group.";

    if (D.summaryTeamRow) setHidden(D.summaryTeamRow, !has);
    if (D.summaryTeam) D.summaryTeam.textContent = has ? S.ui.selectedTeamName : "Team";

    setShareFields();
    updateProofKit();
    updateSummaryUI();
    renderTeams();
    onPricingInputsChanged();

    if (!silent) toast(has ? `Team selected: ${S.ui.selectedTeamName}` : "Team cleared.", "info");
  };

  const setPrefill = (opts, { silent } = { silent: false }) => {
    D = cacheDom();

    const amountCents = toInt(opts?.amountCents, 0);
    S.ui.amountCents = Math.max(0, amountCents);

    S.ui.purpose = safeText(opts?.purpose || "donation");
    S.ui.sku = safeText(opts?.sku || "");
    S.ui.impactId = safeText(opts?.impactId || "");

    if (D.amount) D.amount.value = amountCents > 0 ? String(Math.round(amountCents / 100)) : "";

    updateSummaryUI();
    updateProofKit();
    renderImpact();
    onPricingInputsChanged();

    if (!silent) toast("Prefilled.", "success");
  };

  const readUtm = () => {
    const url = new URL(window.location.href);
    const p = url.searchParams;

    const utm = {};
    for (const k of ["utm_source", "utm_medium", "utm_campaign", "utm_content", "utm_term"])
      if (p.has(k)) utm[k] = p.get(k) || "";

    const srcParam = safeText(C?.flagship?.analytics?.utm?.sourceParam || "src");
    const cmpParam = safeText(C?.flagship?.analytics?.utm?.campaignParam || "cmp");
    if (p.has(srcParam)) utm[srcParam] = p.get(srcParam) || "";
    if (p.has(cmpParam)) utm[cmpParam] = p.get(cmpParam) || "";

    const teamId = p.get("team") || p.get("t") || "";
    if (teamId) utm.team = teamId;

    const needId = p.get("need") || "";
    if (needId) utm.need = needId;

    try {
      const ref = document.referrer || "";
      if (ref) utm.referrer = ref;
    } catch {}

    S.utm = utm;

    if (utm.team) setSelectedTeam(utm.team, { silent: true });
    if (utm.need) {
      const impact = normalizeImpactList().find((x) => x.id === utm.need);
      if (impact) setPrefill({ amountCents: impact.amountCents, purpose: "impact", impactId: impact.id }, { silent: true });
    }

    try {
      const key = `ff_attrib_${shellEnv.orgId}_${shellEnv.campaignId}`;
      localStorage.setItem(key, JSON.stringify({ ts: new Date().toISOString(), utm }));
    } catch {}
  };

  /* ---------------------------------------------
   * Share URL + QR
   * -------------------------------------------*/
  const buildShareUrl = (overrides = {}) => {
    const url = new URL(window.location.href);
    for (const k of ["payment_intent", "payment_intent_client_secret", "redirect_status"])
      url.searchParams.delete(k);

    const shareAttrib = !!C?.flagship?.features?.shareAttribution;
    if (shareAttrib && (overrides.teamId || S.ui.selectedTeamId))
      url.searchParams.set("team", overrides.teamId || S.ui.selectedTeamId);
    else url.searchParams.delete("team");

    if (overrides.needId) url.searchParams.set("need", overrides.needId);
    else url.searchParams.delete("need");

    const srcParam = safeText(C?.flagship?.analytics?.utm?.sourceParam || "src");
    const cmpParam = safeText(C?.flagship?.analytics?.utm?.campaignParam || "cmp");
    if (S.utm[srcParam] && !url.searchParams.get(srcParam)) url.searchParams.set(srcParam, S.utm[srcParam]);
    if (S.utm[cmpParam] && !url.searchParams.get(cmpParam)) url.searchParams.set(cmpParam, S.utm[cmpParam]);

    return url.toString();
  };

  const buildQrSrc = (dataUrl, size = 180) => {
    const ep = qrEndpoint;
    if (ep.includes("?")) {
      return (
        ep +
        (ep.endsWith("&") || ep.endsWith("?") ? "" : "&") +
        `size=${size}x${size}&data=${encodeURIComponent(dataUrl)}`
      );
    }
    const u = new URL(ep, window.location.origin);
    u.searchParams.set("size", `${size}x${size}`);
    u.searchParams.set("data", dataUrl);
    return u.toString();
  };

  const setShareFields = () => {
    D = cacheDom();
    const url = buildShareUrl();
    if (D.shareLink) {
      if ("value" in D.shareLink) D.shareLink.value = url;
      else D.shareLink.textContent = url;
    }
    const src = buildQrSrc(url, 180);
    for (const img of D.qrImgs) if (img && img.getAttribute("src") !== src) img.setAttribute("src", src);
  };

  const buildProofCaption = () => {
    const url = buildShareUrl();
    return [
      `Supporting ${S.org.name} this season ðŸŽ¯`,
      ``,
      `Help us cover travel, gym time, fees, and gear. Secure checkout + instant receipt:`,
      url,
      ``,
      `#FutureFunded #YouthSports #Community`,
    ].join("\n");
  };

  const updateProofKit = () => {
    D = cacheDom();
    const donorName = safeText(D.fullName?.value || "").trim() || "Your name";
    const anon = !!D.anonymous?.checked || S.ui.recognition !== "public";
    const label = anon ? "Anonymous" : donorName;

    const amt = toInt(S.ui.amountCents, 0);
    const fallback = toInt(S.fundraiser.popularAmountCents, 7500);
    const amtText = amt > 0 ? formatCurrency(amt, currency, locale) : formatCurrency(fallback, currency, locale);

    if (D.proofDonorName) D.proofDonorName.textContent = label;
    if (D.proofAmount) D.proofAmount.textContent = amtText;

    if (D.proofCaption) {
      const cap = buildProofCaption();
      if ("value" in D.proofCaption) D.proofCaption.value = cap;
      else D.proofCaption.textContent = cap;
    }
  };

  window.FF.buildShareUrl = buildShareUrl;
  window.FF.setShareFields = setShareFields;

  // Compatibility aliases (safe)
  window.FF.setSelectedTeam = setSelectedTeam;
  window.FF.selectTeam = setSelectedTeam;
  window.FF.setPrefill = setPrefill;
  window.FF.prefill = setPrefill;

  /* ---------------------------------------------
   * Modal helper (minimal)
   * -------------------------------------------*/
  const findModal = (kind) => {
    const k = safeText(kind);
    const byId =
      qs(`#ff${k[0]?.toUpperCase() || ""}${k.slice(1)}Modal`) ||
      qs(`#${k}Modal`) ||
      qs(`#ff-${k}-modal`) ||
      null;
    return byId || qs(`[data-ff-modal="${k}"]`) || qs(`[data-ff-${k}-modal]`) || null;
  };

  const getFocusable = (root) => {
    const sels = [
      "a[href]",
      "button:not([disabled])",
      "input:not([disabled])",
      "select:not([disabled])",
      "textarea:not([disabled])",
      "[tabindex]:not([tabindex='-1'])",
    ];
    return qsa(sels.join(","), root).filter((el) => !!(el.offsetWidth || el.offsetHeight || el.getClientRects().length));
  };

  let __globalEscapeBound = false;

  const openModal = (el) => {
    if (!el || captureMode) return false;
    S.ui.__lastActiveEl = document.activeElement || null;
    S.ui.__activeModal = el;
    setHidden(el, false);
    try {
      if (el.id) qsa(`[aria-controls="${el.id}"]`).forEach((btn) => btn.setAttribute("aria-expanded", "true"));
    } catch {}
    const f = getFocusable(el)[0];
    try {
      (f || el).focus?.();
    } catch {}
    return true;
  };

  const closeModal = (el) => {
    if (!el) return;
    setHidden(el, true);
    try {
      if (el.id) qsa(`[aria-controls="${el.id}"]`).forEach((btn) => btn.setAttribute("aria-expanded", "false"));
    } catch {}
    if (C?.flagship?.accessibility?.focusRestore !== false) {
      try {
        S.ui.__lastActiveEl?.focus?.();
      } catch {}
    }
    if (S.ui.__activeModal === el) S.ui.__activeModal = null;
  };

  const bindModalCloseWiring = (modalEl) => {
    if (!modalEl || modalEl.__ffModalBound) return;
    modalEl.__ffModalBound = true;

    on(modalEl, "click", (e) => {
      const t = e.target;
      if (!t || !(t instanceof Element)) return;
      if (
        t.matches(
          "[data-ff-modal-close], [data-ff-share-close], [data-ff-gallery-close], [data-ff-proof-close], [data-ff-policy-close]"
        )
      ) {
        e.preventDefault();
        closeModal(modalEl);
        return;
      }
      if (t.matches(".ff-modal__backdrop, .ff-drawer__backdrop, [data-ff-backdrop]")) {
        e.preventDefault();
        closeModal(modalEl);
      }
    });

    if (!__globalEscapeBound) {
      __globalEscapeBound = true;
      on(document, "keydown", (e) => {
        if (e.key !== "Escape") return;
        const active = S.ui.__activeModal;
        if (active && !active.hidden) closeModal(active);
      });
    }

    on(modalEl, "keydown", (e) => {
      if (e.key !== "Tab") return;
      if (modalEl.hidden) return;

      const focusables = getFocusable(modalEl);
      if (!focusables.length) return;

      const first = focusables[0];
      const last = focusables[focusables.length - 1];
      const active = document.activeElement;

      if (e.shiftKey) {
        if (active === first || !modalEl.contains(active)) {
          e.preventDefault();
          last.focus?.();
        }
      } else {
        if (active === last) {
          e.preventDefault();
          first.focus?.();
        }
      }
    });
  };

  /* ---------------------------------------------
   * Rendering: Branding + Announcement
   * -------------------------------------------*/
  const applyBrand = () => {
    D = cacheDom();
    if (D.orgName) D.orgName.textContent = S.org.name;
    if (D.orgMeta) D.orgMeta.textContent = S.org.meta;
    if (D.footerOrgName) D.footerOrgName.textContent = S.org.name;
    if (D.footerOrgMeta) D.footerOrgMeta.textContent = S.org.meta;
    if (D.seasonPill) D.seasonPill.textContent = S.org.seasonPill;
    if (D.sportPill) D.sportPill.textContent = S.org.sportPill;
    if (D.heroAccentLine) D.heroAccentLine.textContent = S.org.heroAccentLine;
    if (D.heroOrgLine) D.heroOrgLine.textContent = `${S.org.name} â€¢ Fundraiser`;
  };

  const applyAnnouncement = () => {
    D = cacheDom();
    if (!D.announce || !D.announcementText) return;

    const ann = safeText(C?.org?.announcement || C?.fundraiser?.announcement || "");
    if (!ann) return setHidden(D.announce, true);

    const key = `ff_announce_dismiss_${shellEnv.orgId}_${shellEnv.campaignId}`;
    try {
      if (localStorage.getItem(key)) return setHidden(D.announce, true);
    } catch {}

    D.announcementText.textContent = ann;
    setHidden(D.announce, false);

    if (D.announceDismiss) {
      on(D.announceDismiss, "click", () => {
        setHidden(D.announce, true);
        try {
          localStorage.setItem(key, String(now()));
        } catch {}
      });
    }
  };

  /* ---------------------------------------------
   * Fundraising math + progress UI
   * -------------------------------------------*/
  const deriveRaisedCents = () => {
    const explicit = C?.fundraiser?.raisedAmount;
    if (explicit != null) return toInt(explicit, 0) * 100;

    if (Array.isArray(S.teams) && S.teams.length)
      return S.teams.reduce((sum, t) => sum + toInt(t.raised, 0) * 100, 0);

    let sum = 0;
    for (const s of S.fundraiser.sponsors || [])
      sum += toInt(s.amountCents ?? (toInt(s.amount, 0) * 100), 0);
    for (const g of S.fundraiser.recentGifts || [])
      sum += toInt(g.amountCents ?? (toInt(g.amount, 0) * 100), 0);
    return sum;
  };

  const applyUpdated = () => {
    D = cacheDom();
    if (!D.lastUpdatedText) return;
    const d = parseISO(S.fundraiser.updatedISO) || new Date();
    let label = "Updated â€” just now";
    try {
      const mins = Math.max(0, Math.round((now() - d.getTime()) / 60000));
      if (mins < 2) label = "Updated â€” just now";
      else if (mins < 60) label = `Updated â€” ${mins}m ago`;
      else {
        const hrs = Math.round(mins / 60);
        label =
          hrs < 24
            ? `Updated â€” ${hrs}h ago`
            : `Updated â€” ${d.toLocaleDateString(locale, { month: "short", day: "numeric" })}`;
      }
    } catch {
      label = `Updated â€” ${d.toISOString().slice(0, 10)}`;
    }
    D.lastUpdatedText.textContent = label;
  };

  const setProgressUI = () => {
    D = cacheDom();
    const raised = toInt(S.fundraiser.raisedCents, 0);
    const goal = toInt(S.fundraiser.goalCents, 0);
    const pct = goal > 0 ? clamp(Math.round((raised / goal) * 100), 0, 999) : 0;
    const remaining = Math.max(0, goal - raised);

    const raisedTxt = formatCurrency(raised, currency, locale);
    const goalTxt = formatCurrency(goal, currency, locale);

    if (D.raisedBig) D.raisedBig.textContent = raisedTxt;
    if (D.raisedRow) D.raisedRow.textContent = raisedTxt;
    if (D.goalRow) D.goalRow.textContent = goalTxt;
    if (D.goalPill) D.goalPill.textContent = goalTxt;

    if (D.remainingText) D.remainingText.textContent = formatCurrency(remaining, currency, locale);
    if (D.pctText) D.pctText.textContent = String(pct);

    if (D.overallBar) {
      const w = clamp(goal > 0 ? (raised / goal) * 100 : 0, 0, 100);
      D.overallBar.style.width = `${w.toFixed(2)}%`;
      const meter = qs('[data-ff-meter="overall"]');
      if (meter) {
        meter.setAttribute("aria-valuenow", String(clamp(pct, 0, 100)));
        meter.setAttribute("aria-valuetext", `${clamp(pct, 0, 100)}% funded`);
      }
    }

    if (D.topbarRaised) D.topbarRaised.textContent = raisedTxt;
    if (D.topbarGoal) D.topbarGoal.textContent = goalTxt;

    if (D.stickyRaised) D.stickyRaised.textContent = raisedTxt;
    if (D.stickyGoal) D.stickyGoal.textContent = goalTxt;
  };

  const applyKpis = () => {
    D = cacheDom();
    if (!D.donorCount && !D.avgGift && !D.topGift) return;

    const gifts = normalizeGifts();
    const sponsors = normalizeSponsors();
    const contribs = gifts.map((g) => g.amountCents).concat(sponsors.map((s) => s.amountCents));

    const count = contribs.length;
    const top = contribs.reduce((m, x) => Math.max(m, toInt(x, 0)), 0);
    const avg = count > 0 ? Math.round(contribs.reduce((a, x) => a + toInt(x, 0), 0) / count) : 0;

    if (D.donorCount) D.donorCount.textContent = String(count);
    if (D.topGift) D.topGift.textContent = formatCurrency(top, currency, locale);
    if (D.avgGift) D.avgGift.textContent = formatCurrency(avg, currency, locale);
  };

  /* ---------------------------------------------
   * Deadline / Countdown
   * -------------------------------------------*/
  let countdownTimer = null;

  const startDeadlineLoop = () => {
    D = cacheDom();
    const deadline = parseISO(S.fundraiser.deadlineISO);

    const deadlineLabel = (() => {
      if (!deadline) return "â€”";
      try {
        return deadline.toLocaleDateString(locale, { month: "short", day: "numeric", year: "numeric" });
      } catch {
        return deadline.toISOString().slice(0, 10);
      }
    })();

    if (D.deadlineText) D.deadlineText.textContent = deadline ? deadlineLabel : "No deadline";
    if (D.topbarDeadline) D.topbarDeadline.textContent = deadline ? deadlineLabel : "â€”";
    if (!deadline) return;

    const tick = () => {
      const ms = deadline.getTime() - now();
      const label = ms <= 0 ? "Ended" : humanCountdown(ms);
      if (D.heroCountdown) D.heroCountdown.textContent = label;
      if (D.topbarCountdown) D.topbarCountdown.textContent = label;
    };

    tick();
    clearInterval(countdownTimer);
    countdownTimer = setInterval(tick, 15000);
  };

  /* ---------------------------------------------
   * Event pill (optional)
   * -------------------------------------------*/
  const applyEventPill = () => {
    D = cacheDom();
    const pill = D.heroEventPill;
    if (!pill) return;

    const ev = C?.event || C?.fundraiser?.event || null;
    const starts = parseISO(ev?.startsISO || ev?.startISO || "");
    const title = safeText(ev?.title || ev?.name || "Next event");

    if (!starts) return setHidden(pill, true);

    const tick = () => {
      const ms = starts.getTime() - now();
      const t = ms <= 0 ? "Now" : humanCountdown(ms);
      pill.textContent = `${title} â€¢ ${t}`;
      setHidden(pill, false);
    };
    tick();
    setInterval(tick, 15000);
  };

  /* ---------------------------------------------
   * Match UI
   * -------------------------------------------*/
  const applyMatch = () => {
    D = cacheDom();
    const m = S.fundraiser.match;
    const isActive = !!m?.active;

    if (D.heroMatchPill) setHidden(D.heroMatchPill, !isActive);
    if (D.sponsorMatchPill) setHidden(D.sponsorMatchPill, !isActive);
    if (D.matchDetailRow) setHidden(D.matchDetailRow, !isActive);
    if (D.matchStatus) D.matchStatus.textContent = isActive ? "On" : "Off";
    if (D.topbarMatchStrip) setHidden(D.topbarMatchStrip, !isActive);
    if (D.matchCallout) setHidden(D.matchCallout, !isActive);

    if (!isActive) return;

    const remainingCents = toInt(m.remainingCents ?? (toInt(m.remaining, 0) * 100), 0);
    const ends = parseISO(m.endsISO || "");

    if (D.matchRemainingPill) D.matchRemainingPill.textContent = `Remaining ${formatCurrency(remainingCents, currency, locale)}`;
    if (D.matchEndsPill) D.matchEndsPill.textContent = ends ? `Ends ${humanCountdown(ends.getTime() - now())}` : "Ends â€”";

    if (D.topbarMatchText) D.topbarMatchText.textContent = "Active";
    if (D.topbarMatchRemaining) D.topbarMatchRemaining.textContent = formatCurrency(remainingCents, currency, locale);

    if (D.matchCalloutText)
      D.matchCalloutText.textContent = ends
        ? `until ${ends.toLocaleDateString(locale, { month: "short", day: "numeric" })}`
        : "doubling gifts";
  };

  /* ---------------------------------------------
   * Allocation / Impact / Sponsors / Teams / Gifts / Gallery
   * -------------------------------------------*/
  const renderAllocation = () => {
    D = cacheDom();
    if (!D.allocationList) return;
    const items = Array.isArray(S.fundraiser.allocation) ? S.fundraiser.allocation : [];
    if (!items.length)
      return setChildren(D.allocationList, h("div", { class: "ff-help", text: "Allocation coming soon." }));

    const total = items.reduce((a, x) => a + toNum(x.pct, 0), 0) || 100;
    const nodes = items.map((x) => {
      const pct = clamp(Math.round((toNum(x.pct, 0) / total) * 100), 0, 100);
      return h("div", { class: "ff-slimitem" }, [
        h("span", { class: "ff-help", text: safeText(x.label || "") }),
        h("strong", { class: "ff-help ff-num", text: `${pct}%` }),
      ]);
    });
    setChildren(D.allocationList, nodes);

    if (D.allocationUpdated && D.allocationUpdatedText) {
      const upd = safeText(S.fundraiser.allocationUpdatedISO || S.fundraiser.updatedISO || "");
      if (upd) {
        setHidden(D.allocationUpdated, false);
        const d = parseISO(upd);
        D.allocationUpdatedText.textContent = d ? d.toLocaleDateString(locale, { month: "short", day: "numeric" }) : upd;
      } else setHidden(D.allocationUpdated, true);
    }
  };

  const renderImpact = () => {
    D = cacheDom();
    if (!D.impactGrid) return;

    const all = normalizeImpactList();
    const q = safeText(S.ui.impactQuery || "").trim().toLowerCase();
    const filter = safeText(S.ui.impactFilter || "all");
    const filtered = all.filter((x) => {
      if (filter !== "all" && x.cat !== filter) return false;
      if (!q) return true;
      return (x.title + " " + x.desc).toLowerCase().includes(q);
    });

    if (D.impactEmpty) setHidden(D.impactEmpty, filtered.length > 0);

    const card = (x) => {
      const amount = x.amountCents > 0 ? formatCurrency(x.amountCents, currency, locale) : "Custom";
      const btn = h("button", { class: "ff-btn ff-btn--sm", type: "button", text: "Fund this" });
      on(btn, "click", () => {
        if (x.amountCents > 0) setPrefill({ amountCents: x.amountCents, purpose: "impact", impactId: x.id }, { silent: true });
        else setPrefill({ purpose: "impact", impactId: x.id }, { silent: true });
        toast("Impact selected.", "success");
        scrollToDonate();
      });

      return h("div", { class: "ff-card ff-impact" }, [
        h("div", { class: "ff-kicker", text: x.cat.toUpperCase() }),
        h("div", { class: "ff-title", text: x.title }),
        x.desc ? h("div", { class: "ff-help", text: x.desc }) : null,
        h("div", { class: "ff-row ff-row--space" }, [
          h("strong", { class: "ff-num", text: amount }),
          btn,
        ]),
      ]);
    };

    setChildren(
      D.impactGrid,
      filtered.length ? filtered.map(card) : h("div", { class: "ff-help", text: "No matching needs right now." })
    );
  };

  const renderSponsorTiers = () => {
    D = cacheDom();
    if (!D.sponsorTiersHost) return;

    const tiers = Array.isArray(S.fundraiser.sponsorTiers) ? S.fundraiser.sponsorTiers : [];
    if (!tiers.length) return setChildren(D.sponsorTiersHost, h("div", { class: "ff-help", text: "Sponsor tiers coming soon." }));

    const norm = tiers
      .filter((t) => t && (t.name || t.title))
      .map((t) => ({
        name: safeText(t.name || t.title || "Tier"),
        amountCents: toInt(t.amountCents ?? (toInt(t.amount, 0) * 100), 0),
        perks: Array.isArray(t.perks) ? t.perks.map((p) => safeText(p)).filter(Boolean) : [],
      }))
      .sort((a, b) => b.amountCents - a.amountCents);

    const node = (t) =>
      h("div", { class: "ff-card ff-tier" }, [
        h("div", { class: "ff-row ff-row--space" }, [
          h("div", { class: "ff-title", text: t.name }),
          h("strong", { class: "ff-num", text: t.amountCents ? formatCurrency(t.amountCents, currency, locale) : "â€”" }),
        ]),
        t.perks.length ? h("ul", { class: "ff-list" }, t.perks.map((p) => h("li", { class: "ff-help", text: p }))) : null,
      ]);

    setChildren(D.sponsorTiersHost, norm.map(node));
  };

  const renderSponsorBoard = () => {
    D = cacheDom();
    const sponsors = normalizeSponsors();

    // sort
    const sort = safeText(S.ui.sponsorSort || "rank");
    const sorted = sponsors.slice().sort((a, b) => {
      if (sort === "new") return (b.ts || 0) - (a.ts || 0);
      if (sort === "amount") return b.amountCents - a.amountCents;
      return b.amountCents - a.amountCents; // rank defaults to amount
    });

    // podium (top 3)
    if (D.sponsorPodium) {
      const top3 = sorted.slice(0, 3);
      const podiumCard = (s, idx) => {
        const logo = safeImgUrl(s.logo);
        const nameNode = s.url
          ? h("a", { class: "ff-title", href: s.url, target: "_blank", rel: "noopener", text: s.name })
          : h("div", { class: "ff-title", text: s.name });

        return h("div", { class: `ff-card ff-sponsor ff-sponsor--podium ff-sponsor--${idx + 1}` }, [
          h("div", { class: "ff-kicker", text: idx === 0 ? "TOP SPONSOR" : `#${idx + 1}` }),
          logo ? h("img", { class: "ff-logo", src: logo, alt: `${s.name} logo`, loading: "lazy" }) : null,
          nameNode,
          h("strong", { class: "ff-num", text: formatCurrency(s.amountCents, currency, locale) }),
        ]);
      };
      setChildren(
        D.sponsorPodium,
        top3.length ? top3.map(podiumCard) : h("div", { class: "ff-help", text: "Be the first sponsor." })
      );
    }

    // wall/list
    if (D.sponsorWall) {
      const view = safeText(S.ui.sponsorWall || "logos");
      const list = sorted.slice(0, 30);

      if (view === "list") {
        const row = (s, i) =>
          h("div", { class: "ff-row ff-row--space ff-sponsor-row" }, [
            h("div", { class: "ff-row ff-row--gap" }, [
              h("strong", { class: "ff-num ff-rank", text: `#${i + 1}` }),
              s.url
                ? h("a", { class: "ff-help", href: s.url, target: "_blank", rel: "noopener", text: s.name })
                : h("span", { class: "ff-help", text: s.name }),
            ]),
            h("strong", { class: "ff-num", text: formatCurrency(s.amountCents, currency, locale) }),
          ]);
        setChildren(D.sponsorWall, list.length ? list.map(row) : h("div", { class: "ff-help", text: "No sponsors yet." }));
      } else {
        const tile = (s) => {
          const logo = safeImgUrl(s.logo);
          const inner = h("div", { class: "ff-sponsor-tile" }, [
            logo ? h("img", { class: "ff-logo", src: logo, alt: `${s.name} logo`, loading: "lazy" }) : null,
            h("div", { class: "ff-help", text: s.name }),
            h("strong", { class: "ff-num", text: formatCurrency(s.amountCents, currency, locale) }),
          ]);
          if (s.url) {
            const a = h("a", { class: "ff-sponsor-tilelink", href: s.url, target: "_blank", rel: "noopener" }, [inner]);
            return a;
          }
          return inner;
        };
        setChildren(
          D.sponsorWall,
          list.length ? h("div", { class: "ff-grid ff-grid--logos" }, list.map(tile)) : h("div", { class: "ff-help", text: "No sponsors yet." })
        );
      }
    }

    // legacy leaderboard host
    if (D.sponsorList && !D.sponsorWall) {
      const list = sorted.slice(0, 20);
      const row = (s, i) =>
        h("div", { class: "ff-row ff-row--space ff-sponsor-row" }, [
          h("div", { class: "ff-row ff-row--gap" }, [
            h("strong", { class: "ff-num ff-rank", text: `#${i + 1}` }),
            s.url
              ? h("a", { class: "ff-help", href: s.url, target: "_blank", rel: "noopener", text: s.name })
              : h("span", { class: "ff-help", text: s.name }),
          ]),
          h("strong", { class: "ff-num", text: formatCurrency(s.amountCents, currency, locale) }),
        ]);
      setChildren(D.sponsorList, list.length ? list.map(row) : h("div", { class: "ff-help", text: "No sponsors yet." }));
    }
  };

  const renderTeams = () => {
    D = cacheDom();
    if (!D.teamsGrid) return;

    const all = normalizeTeams();
    const q = safeText(S.ui.teamQuery || "").trim().toLowerCase();
    const sort = safeText(S.ui.teamSort || "featured");

    let filtered = all.filter((t) => {
      if (!q) return true;
      return (t.name + " " + t.meta).toLowerCase().includes(q);
    });

    filtered.sort((a, b) => {
      if (sort === "raised") return b.raisedCents - a.raisedCents;
      if (sort === "name") return a.name.localeCompare(b.name);
      if (sort === "new") return (b.ts || 0) - (a.ts || 0);
      // featured default
      if (a.featured !== b.featured) return a.featured ? -1 : 1;
      return b.raisedCents - a.raisedCents;
    });

    if (D.teamsStatus) D.teamsStatus.textContent = `${filtered.length} groups`;

    const card = (t) => {
      const selected = t.id === S.ui.selectedTeamId;
      const barPct = clamp(t.goalCents > 0 ? (t.raisedCents / t.goalCents) * 100 : 0, 0, 100);
      const img = safeImgUrl(t.photo);

      const chooseBtn = h("button", {
        class: `ff-btn ff-btn--sm ${selected ? "is-selected" : ""}`,
        type: "button",
        text: selected ? "Selected" : "Support this team",
        aria: { pressed: selected ? "true" : "false" },
      });

      on(chooseBtn, "click", (e) => {
        e.preventDefault();
        if (selected) setSelectedTeam("", {});
        else setSelectedTeam(t.id, {});
        scrollToDonate();
      });

      return h("div", { class: `ff-card ff-team ${selected ? "is-selected" : ""}`, dataset: { ffTeamId: t.id } }, [
        img ? h("img", { class: "ff-photo", src: img, alt: `${t.name} photo`, loading: "lazy" }) : null,
        h("div", { class: "ff-title", text: t.name }),
        t.meta ? h("div", { class: "ff-help", text: t.meta }) : null,
        h("div", { class: "ff-row ff-row--space" }, [
          h("div", { class: "ff-help", text: `Raised ${formatCurrency(t.raisedCents, currency, locale)}` }),
          t.goalCents ? h("div", { class: "ff-help", text: `Goal ${formatCurrency(t.goalCents, currency, locale)}` }) : null,
        ]),
        h("div", { class: "ff-meter", role: "progressbar", aria: { valuenow: String(Math.round(barPct)), valuemin: "0", valuemax: "100" } }, [
          h("div", { class: "ff-meter__bar", style: `width:${barPct.toFixed(2)}%` }),
        ]),
        h("div", { class: "ff-row ff-row--space" }, [h("strong", { class: "ff-num", text: `${t.pct}%` }), chooseBtn]),
        t.ask ? h("div", { class: "ff-help", text: t.ask }) : null,
      ]);
    };

    setChildren(D.teamsGrid, filtered.length ? filtered.map(card) : h("div", { class: "ff-help", text: "No groups found." }));
  };

  const renderRecentGifts = () => {
    D = cacheDom();
    if (!D.recentGiftsHost) return;

    const gifts = normalizeGifts().sort((a, b) => (b.ts || 0) - (a.ts || 0)).slice(0, 10);
    const row = (g) => {
      const name = g.anon ? "Anonymous" : g.name;
      return h("div", { class: "ff-row ff-row--space ff-gift" }, [
        h("div", { class: "ff-help", text: name }),
        h("strong", { class: "ff-num", text: formatCurrency(g.amountCents, currency, locale) }),
      ]);
    };
    setChildren(D.recentGiftsHost, gifts.length ? gifts.map(row) : h("div", { class: "ff-help", text: "Be the first supporter." }));
  };

  const renderGallery = () => {
    D = cacheDom();
    const enabled = !!S.gallery?.enabled && !!C?.flagship?.features?.gallery;
    const items = Array.isArray(S.gallery?.items) ? S.gallery.items : [];

    if (D.galleryGrid) setHidden(D.galleryGrid, !enabled || !items.length);
    if (D.galleryAll) setHidden(D.galleryAll, !enabled || !items.length);

    if (!enabled || !items.length) return;

    const norm = items
      .map((it) => ({
        src: safeImgUrl(it.src || it.url || ""),
        caption: safeText(it.caption || it.alt || ""),
      }))
      .filter((x) => !!x.src);

    const tile = (x) =>
      h("div", { class: "ff-gallery-tile" }, [
        h("img", { class: "ff-gallery-img", src: x.src, alt: x.caption || "Gallery image", loading: "lazy" }),
        x.caption ? h("div", { class: "ff-help", text: x.caption }) : null,
      ]);

    if (D.galleryGrid) {
      setChildren(D.galleryGrid, norm.slice(0, 6).map(tile));
    }
    if (D.galleryAll) {
      setChildren(D.galleryAll, norm.map(tile));
    }
  };

  const bindImpactControls = () => {
    D = cacheDom();
    if (D.impactSearch) {
      on(
        D.impactSearch,
        "input",
        debounce(() => {
          S.ui.impactQuery = safeText(D.impactSearch.value || "");
          renderImpact();
        }, 120)
      );
    }
    for (const btn of D.impactFilterBtns) {
      on(btn, "click", (e) => {
        e.preventDefault();
        const f = safeText(btn.getAttribute("data-ff-impact-filter") || btn.getAttribute("data-filter") || "all");
        S.ui.impactFilter = f;
        for (const b of D.impactFilterBtns) b.classList.toggle("is-selected", b === btn);
        renderImpact();
      });
    }
  };

  const bindSponsorControls = () => {
    D = cacheDom();

    for (const btn of D.sponsorSortBtns) {
      on(btn, "click", (e) => {
        e.preventDefault();
        const sort = safeText(btn.getAttribute("data-ff-sort") || "rank");
        S.ui.sponsorSort = sort;
        for (const b of D.sponsorSortBtns) b.classList.toggle("is-selected", b === btn);
        renderSponsorBoard();
      });
    }

    for (const btn of D.sponsorWallViewBtns) {
      on(btn, "click", (e) => {
        e.preventDefault();
        const view = safeText(btn.getAttribute("data-ff-wall") || "logos");
        S.ui.sponsorWall = view;
        for (const b of D.sponsorWallViewBtns) b.classList.toggle("is-selected", b === btn);
        renderSponsorBoard();
      });
    }

    if (D.refreshSponsorsBtn) on(D.refreshSponsorsBtn, "click", (e) => (e.preventDefault(), renderSponsorBoard()));
  };

  const bindTeamControls = () => {
    D = cacheDom();

    if (D.teamSearch) {
      on(
        D.teamSearch,
        "input",
        debounce(() => {
          S.ui.teamQuery = safeText(D.teamSearch.value || "");
          renderTeams();
        }, 120)
      );
    }

    for (const btn of D.teamSortBtns) {
      on(btn, "click", (e) => {
        e.preventDefault();
        const sort = safeText(btn.getAttribute("data-ff-sort") || "featured");
        S.ui.teamSort = sort;
        for (const b of D.teamSortBtns) b.classList.toggle("is-selected", b === btn);
        renderTeams();
      });
    }

    for (const btn of D.attribClearBtns) {
      on(btn, "click", (e) => {
        e.preventDefault();
        setSelectedTeam("", {});
      });
    }
  };

  /* ---------------------------------------------
   * Scroll / anchors
   * -------------------------------------------*/
  const scrollToDonate = () => {
    const el = qs("#donate");
    if (!el) return;
    el.scrollIntoView({ behavior: prefersReducedMotion() ? "auto" : "smooth", block: "start" });
    const focusTarget = D?.amount || D?.email || D?.fullName || null;
    try {
      if (focusTarget && typeof focusTarget.focus === "function")
        setTimeout(() => focusTarget.focus(), prefersReducedMotion() ? 0 : 250);
    } catch {}
  };

  window.FF.scrollToDonate = scrollToDonate;

  const applyScrollUI = () => {
    D = cacheDom();
    const bar = D.scrollProgressBar;
    const back = D.backToTopBtn;
    const sticky = D.stickySupport;

    const doc = document.documentElement;
    const scrolled = window.scrollY || doc.scrollTop || document.body.scrollTop || 0;
    const max = Math.max(1, (doc.scrollHeight || 1) - (doc.clientHeight || 1));
    const pct = clamp((scrolled / max) * 100, 0, 100);
    if (bar) bar.style.width = `${pct.toFixed(2)}%`;

    const showBack = scrolled > 700;
    if (back) {
      if (back.hasAttribute("hidden")) back.hidden = !showBack;
      back.classList.toggle("is-visible", showBack);
      back.setAttribute("aria-hidden", showBack ? "false" : "true");
    }
    if (sticky) {
      const showSticky = scrolled > 320;
      if (sticky.hasAttribute("hidden")) sticky.hidden = !showSticky;
      sticky.classList.toggle("is-visible", showSticky);
      sticky.setAttribute("aria-hidden", showSticky ? "false" : "true");
    }
  };

  const bindScrollUI = () => {
    const tick = debounce(applyScrollUI, 50);
    on(window, "scroll", tick, { passive: true });
    on(window, "resize", tick);
    tick();

    if (D.backToTopBtn)
      on(D.backToTopBtn, "click", (e) =>
        (e.preventDefault(), window.scrollTo({ top: 0, behavior: prefersReducedMotion() ? "auto" : "smooth" }))
      );
    if (D.stickySupport) {
      qsa('[data-ff-sticky-cta="donate"], [data-ff-sticky-donate]', D.stickySupport).forEach((btn) =>
        on(btn, "click", (e) => (e.preventDefault(), scrollToDonate()))
      );
    }
  };

  const bindAnchors = () => {
    D = cacheDom();
    for (const a of D.anchorLinks) {
      on(a, "click", (e) => {
        const href = a.getAttribute("href") || "";
        if (!href.startsWith("#") || href === "#") return;
        const id = href.slice(1);
        const target = qs(`#${cssEscape(id)}`);
        if (!target) return;
        e.preventDefault();
        try {
          target.scrollIntoView({ behavior: prefersReducedMotion() ? "auto" : "smooth", block: "start" });
        } catch {
          window.location.hash = href;
        }
        if (D.drawer && !D.drawer.hidden) closeModal(D.drawer);
      });
    }
  };

  /* ---------------------------------------------
   * Theme + Drawer
   * -------------------------------------------*/
  const themeKey = `ff_theme_${shellEnv.orgId}_${shellEnv.campaignId}`;
  const getTheme = () => {
    const attr = document.documentElement.getAttribute("data-theme");
    if (attr) return attr;
    try {
      const saved = localStorage.getItem(themeKey);
      if (saved) return saved;
    } catch {}
    return "";
  };
  const setTheme = (t) => {
    const theme = safeText(t);
    if (theme) document.documentElement.setAttribute("data-theme", theme);
    else document.documentElement.removeAttribute("data-theme");
    try {
      if (theme) localStorage.setItem(themeKey, theme);
      else localStorage.removeItem(themeKey);
    } catch {}
    if (D.themeToggle) D.themeToggle.setAttribute("aria-pressed", theme === "dark" ? "true" : "false");
  };

  const bindThemeToggle = () => {
    D = cacheDom();
    if (!D.themeToggle) return;
    const cur = getTheme();
    if (cur) setTheme(cur);
    on(D.themeToggle, "click", () => {
      const curTheme = getTheme() || "";
      const next = curTheme === "dark" ? "light" : "dark";
      setTheme(next);
      toast(next === "dark" ? "Dark mode" : "Light mode", "info");
    });
  };

  const bindDrawer = () => {
    D = cacheDom();
    if (!D.drawer) return;
    bindModalCloseWiring(D.drawer);
    for (const btn of D.drawerOpenBtns) on(btn, "click", (e) => (e.preventDefault(), openModal(D.drawer)));
    for (const btn of D.drawerCloseBtns) on(btn, "click", (e) => (e.preventDefault(), closeModal(D.drawer)));
    qsa('a[href^="#"]', D.drawer).forEach((a) => on(a, "click", () => closeModal(D.drawer)));
  };

  /* ---------------------------------------------
   * Share + Aux modals
   * -------------------------------------------*/
  const bindShare = () => {
    D = cacheDom();
    setShareFields();

    for (const btn of D.shareCopyBtns) {
      on(btn, "click", async () => {
        const url = buildShareUrl();
        const ok = await copyToClipboard(url);
        toast(ok ? "Link copied." : "Copy failed.", ok ? "success" : "error");
      });
    }

    for (const btn of D.shareNativeBtns) {
      on(btn, "click", async () => {
        const url = buildShareUrl();
        if (navigator.share) {
          try {
            await navigator.share({ title: document.title, text: "Support our fundraiser.", url });
            toast("Shared.", "success");
            return;
          } catch {}
        }
        const ok = await copyToClipboard(url);
        toast(ok ? "Link copied." : "Copy failed.", ok ? "success" : "error");
      });
    }

    for (const btn of D.copyCaptionBtns || []) {
      on(btn, "click", async () => {
        updateProofKit();
        const cap =
          "value" in (D.proofCaption || {}) ? D.proofCaption?.value || "" : D.proofCaption?.textContent || "";
        const ok = await copyToClipboard(cap);
        toast(ok ? "Caption copied." : "Copy failed.", ok ? "success" : "error");
      });
    }

    for (const btn of D.smsShareBtns || []) {
      on(btn, "click", (e) => {
        e.preventDefault();
        updateProofKit();
        const body = encodeURIComponent(buildProofCaption());
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent || "");
        window.location.href = isIOS ? `sms:&body=${body}` : `sms:?&body=${body}`;
      });
    }

    for (const btn of D.emailShareBtns || []) {
      on(btn, "click", (e) => {
        e.preventDefault();
        updateProofKit();
        const subject = encodeURIComponent(`Support ${S.org.name}`);
        const body = encodeURIComponent(buildProofCaption());
        window.location.href = `mailto:?subject=${subject}&body=${body}`;
      });
    }

    const shareModal = findModal("share");
    if (shareModal) bindModalCloseWiring(shareModal);

    for (const btn of D.shareOpenBtns) {
      on(btn, "click", (e) => {
        e.preventDefault();
        if (shareModal) {
          openModal(shareModal);
          setShareFields();
          updateProofKit();
        } else toast("Share tools not available.", "info");
      });
    }

    for (const btn of D.downloadQrBtns) {
      on(btn, "click", async (e) => {
        e.preventDefault();
        const url = buildShareUrl();
        const src = buildQrSrc(url, 480);
        try {
          const res = await fetch(src);
          const blob = await res.blob();
          const objUrl = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = objUrl;
          a.download = `qr-${shellEnv.orgId}-${shellEnv.campaignId}.png`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          setTimeout(() => URL.revokeObjectURL(objUrl), 2000);
          toast("QR downloaded.", "success");
        } catch {
          toast("QR download failed.", "error");
        }
      });
    }
  };

  const bindAuxModals = () => {
    const proof = findModal("proof");
    const policy = findModal("policy");
    const gallery = findModal("gallery");

    if (proof) bindModalCloseWiring(proof);
    if (policy) bindModalCloseWiring(policy);
    if (gallery) bindModalCloseWiring(gallery);

    for (const btn of D.proofOpenBtns) {
      on(btn, "click", (e) => {
        e.preventDefault();
        if (!proof) return;
        updateProofKit();
        openModal(proof);
      });
    }

    for (const btn of D.policyOpenBtns) on(btn, "click", (e) => (e.preventDefault(), policy && openModal(policy)));
    for (const btn of D.galleryOpenBtns) on(btn, "click", (e) => (e.preventDefault(), gallery && openModal(gallery)));

    if (D.fullName) on(D.fullName, "input", debounce(updateProofKit, 100));
    if (D.amount) on(D.amount, "input", debounce(updateProofKit, 140));
    if (D.anonymous) on(D.anonymous, "change", updateProofKit);
  };

  /* ---------------------------------------------
   * Recognition
   * -------------------------------------------*/
  const applyRecognitionPreview = () => {
    D = cacheDom();
    const el = D.recognitionPreviewText;
    if (!el) return;

    if (el.dataset.ffPrefix == null) {
      const initial = (el.textContent || "").trim();
      const m = initial.match(/^(.*?:)\s+/);
      el.dataset.ffPrefix = m ? m[1] + " " : "Shown as: ";
    }

    const name = safeText(D.fullName?.value || "Supporter").trim() || "Supporter";
    const anon = !!D.anonymous?.checked || S.ui.recognition !== "public";
    const label = anon ? "Anonymous" : name;
    el.textContent = (el.dataset.ffPrefix || "Shown as: ") + label;
  };

  const bindRecognition = () => {
    D = cacheDom();
    for (const btn of D.recognitionBtns) {
      on(btn, "click", () => {
        const modeRaw = btn.getAttribute("data-ff-recognition") || "public";
        const modeNorm = modeRaw === "private" ? "anonymous" : modeRaw;
        S.ui.recognition = modeNorm === "public" ? "public" : "anonymous";

        for (const b of D.recognitionBtns) {
          const selected = b === btn;
          b.classList.toggle("is-selected", selected);
          b.setAttribute("aria-pressed", selected ? "true" : "false");
        }

        if (D.anonymous) D.anonymous.checked = S.ui.recognition !== "public";
        applyRecognitionPreview();
        updateProofKit();
      });
    }

    if (D.anonymous) {
      on(D.anonymous, "change", () => {
        S.ui.recognition = D.anonymous.checked ? "anonymous" : "public";
        applyRecognitionPreview();
        updateProofKit();
      });
    }

    if (D.fullName) on(D.fullName, "input", debounce(() => (applyRecognitionPreview(), updateProofKit()), 90));
  };

  /* ---------------------------------------------
   * Fees + Summary â€” PATCHED
   * -------------------------------------------*/
  const computeFees = (amountCents) => {
    const fees = S.fundraiser.fees || {};
    const enabled = fees.enabledCoverFees !== false;
    if (!enabled) return { feeCents: 0, totalCents: amountCents };

    const pct = toNum(fees.percent, 0);
    const fixed = toInt(fees.fixedCents, 0);
    const max = toInt(fees.maxCents, 0);

    let feeCents = Math.max(0, Math.round(amountCents * pct) + fixed);

    if (coverFeesExact && pct > 0 && pct < 1) {
      const total = Math.ceil((amountCents + fixed) / (1 - pct));
      feeCents = Math.max(0, total - amountCents);
    }

    if (max > 0) feeCents = Math.min(feeCents, max);
    const totalCents = amountCents + (S.ui.coverFees ? feeCents : 0);
    return { feeCents, totalCents };
  };

  const updateSummaryUI = () => {
    D = cacheDom();
    const amountCents = Math.max(0, toInt(S.ui.amountCents, 0));
    const { feeCents, totalCents } = computeFees(amountCents);

    if (D.summaryAmount) D.summaryAmount.textContent = formatCurrency(amountCents, currency, locale, true);
    const showFee = !!S.ui.coverFees && feeCents > 0;
    if (D.summaryFees)
      D.summaryFees.textContent = showFee
        ? `+ ${formatCurrency(feeCents, currency, locale, true)}`
        : formatCurrency(0, currency, locale, true);
    if (D.summaryTotal) D.summaryTotal.textContent = formatCurrency(totalCents, currency, locale, true);

    if (D.receiptEmail) {
      const email = safeText(D.email?.value || "").trim();
      D.receiptEmail.textContent = email || "â€”";
    }

    if (D.checkoutMethodText) {
      let method = "Card";
      if (!stripePk && paypalClientId) method = "PayPal";
      D.checkoutMethodText.textContent = method;
    }
  };

  const setAmountCents = (cents) => {
    const v = Math.max(0, toInt(cents, 0));
    S.ui.amountCents = v;
    if (D.amount) D.amount.value = v > 0 ? String(Math.round(v / 100)) : "";
    updateSummaryUI();
    updateProofKit();
    onPricingInputsChanged();
  };

  const bindAmountControls = () => {
    D = cacheDom();

    for (const btn of D.quickAmountBtns) {
      on(btn, "click", () => {
        const raw = btn.getAttribute("data-ff-quick-amount") || btn.getAttribute("data-quick-amount") || "";
        const cents = parseMoneyToCents(raw);
        if (cents > 0) setAmountCents(cents);
        scrollToDonate();
        toast("Amount selected.", "success");
      });
    }

    if (D.clearAmountBtn) on(D.clearAmountBtn, "click", () => (setAmountCents(0), toast("Amount cleared.", "info")));

    if (D.amount) {
      on(
        D.amount,
        "input",
        debounce(() => {
          S.ui.amountCents = parseMoneyToCents(D.amount.value);
          updateSummaryUI();
          updateProofKit();

          // PATCH: if Stripe already mounted, and pricing changed, remount *now* (not on submit)
          onPricingInputsChanged();

          // Safe autoload: only if not mounted yet (never remount while user is typing card unless pricing changed)
          if (stripeAutoload && stripePk) maybePrepareStripeUI().catch(() => {});
        }, 180)
      );
    }

    if (D.coverFees) {
      on(D.coverFees, "change", () => {
        S.ui.coverFees = !!D.coverFees.checked;
        updateSummaryUI();
        updateProofKit();
        onPricingInputsChanged();
        if (stripeAutoload && stripePk) maybePrepareStripeUI().catch(() => {});
      });
      S.ui.coverFees = !!D.coverFees.checked;
    }

    if (D.popularAmountPill && D.popularAmountText) {
      const popular = toInt(S.fundraiser.popularAmountCents, 0);
      if (popular > 0) {
        D.popularAmountText.textContent = formatCurrency(popular, currency, locale);
        setHidden(D.popularAmountPill, false);
        on(D.popularAmountPill, "click", () => (setAmountCents(popular), toast("Popular amount selected.", "success")));
      } else setHidden(D.popularAmountPill, true);
    }

    if (D.email) on(D.email, "input", debounce(() => (updateSummaryUI(), updateProofKit()), 140));
  };

  /* ---------------------------------------------
   * Prefills from DOM
   * -------------------------------------------*/
  const bindPrefills = () => {
    D = cacheDom();
    for (const el of D.prefills) {
      on(el, "click", (e) => {
        e.preventDefault();
        const cents = toInt(el.getAttribute("data-ff-amount-cents") || el.getAttribute("data-amount-cents"), 0);
        const amount = toInt(el.getAttribute("data-ff-amount") || el.getAttribute("data-amount"), 0) * 100;
        const purpose = el.getAttribute("data-ff-purpose") || "donation";
        const sku = el.getAttribute("data-ff-sku") || "";
        const impactId = el.getAttribute("data-ff-impact-id") || "";
        const amt = cents > 0 ? cents : amount;
        setPrefill({ amountCents: amt, purpose, sku, impactId }, { silent: true });
        scrollToDonate();
        toast("Checkout prefilled.", "success");
      });
    }
  };

  /* ---------------------------------------------
   * Payment UI helpers
   * -------------------------------------------*/
  const setPayError = (msg) => {
    D = cacheDom();
    if (D.payError && D.payErrorText) {
      D.payErrorText.textContent = safeText(msg || "");
      setHidden(D.payError, !msg);
    }
    if (D.paymentLive) D.paymentLive.textContent = safeText(msg || "");
  };

  const setPaySuccess = (msg) => {
    D = cacheDom();
    if (D.paySuccess && D.paySuccessText) {
      D.paySuccessText.textContent = safeText(msg || "");
      setHidden(D.paySuccess, !msg);
    }
    if (D.paymentLive) D.paymentLive.textContent = safeText(msg || "");
  };

  const setBusy = (busy) => {
    D = cacheDom();
    S.ui.stripeBusy = !!busy;
    if (D.payBtn) {
      D.payBtn.disabled = !!busy;
      D.payBtn.setAttribute("aria-busy", busy ? "true" : "false");
    }
  };

  const validateDonation = () => {
    const amountCents = toInt(S.ui.amountCents, 0);
    if (amountCents <= 0) return { ok: false, message: "Enter an amount." };

    const email = safeText(D.email?.value || "").trim();
    if (requireEmail && !email) return { ok: false, message: "Email is required for a receipt." };
    if (email && !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) return { ok: false, message: "Enter a valid email." };

    return { ok: true, message: "" };
  };

  /* ---------------------------------------------
   * Payload shaping (locked)
   * -------------------------------------------*/
  const buildPaymentPayload = () => {
    D = cacheDom();

    const amountCents = Math.max(0, toInt(S.ui.amountCents, 0));
    const { feeCents, totalCents } = computeFees(amountCents);

    const donorName = safeText(D.fullName?.value || "").trim();
    const donorEmail = safeText(D.email?.value || "").trim();
    const donorMessage = safeText(D.message?.value || "").trim();

    const anon = !!D.anonymous?.checked || S.ui.recognition !== "public";

    const base = {
      org_id: shellEnv.orgId,
      campaign_id: shellEnv.campaignId,
      tier: shellEnv.tier,
      env: shellEnv.env,
      version: shellEnv.version,
      page: shellEnv.page,

      purpose: safeText(S.ui.purpose || "donation"),
      sku: safeText(S.ui.sku || ""),
      impact_id: safeText(S.ui.impactId || ""),

      team_id: safeText(S.ui.selectedTeamId || ""),

      amount_cents: amountCents,
      cover_fees: !!S.ui.coverFees,
      fee_cents: feeCents,
      total_cents: totalCents,

      recognition: anon ? "anonymous" : "public",
      utm: S.utm || {},
    };

    const donorNested = { donor: { name: donorName, email: donorEmail, message: donorMessage, anonymous: anon } };
    const donorFlat = {
      donor_name: donorName,
      donor_email: donorEmail,
      donor_message: donorMessage,
      donor_anonymous: anon,
    };

    const shaped = payloadShape === "flat_donor_v1" ? { ...base, ...donorFlat } : { ...base, ...donorNested };
    return deepMerge(shaped, payloadExtra && typeof payloadExtra === "object" ? payloadExtra : {});
  };

  /* ---------------------------------------------
   * Script loader (PATCHED: id+src aware)
   * -------------------------------------------*/
  const loadScriptOnce = (src, { id = "" } = {}) =>
    new Promise((resolve, reject) => {
      if (!src) return resolve(false);

      if (id) {
        const existing = document.getElementById(id);
        if (existing) {
          const existingSrc = existing.getAttribute("src") || "";
          if (!existingSrc || existingSrc === src) return resolve(true);
          // If id exists but src differs, keep existing and load a new one (avoid clobber)
        }
      } else {
        const existing = qsa("script").find((s) => (s.getAttribute("src") || "") === src);
        if (existing) return resolve(true);
      }

      const s = document.createElement("script");
      if (id) s.id = id;
      s.src = src;
      s.async = true;
      s.onload = () => resolve(true);
      s.onerror = () => reject(new Error(`Failed to load ${src}`));
      document.head.appendChild(s);
    });

  /* ---------------------------------------------
   * Stripe â€” PATCHED lifecycle
   * -------------------------------------------*/
  const pendingKey = `ff_pending_${shellEnv.orgId}_${shellEnv.campaignId}`;

  const writePendingPayment = (obj) => {
    try {
      localStorage.setItem(pendingKey, JSON.stringify({ ...obj, ts: new Date().toISOString() }));
    } catch {}
  };
  const readPendingPayment = () => {
    try {
      return parseJSON(localStorage.getItem(pendingKey) || "", null);
    } catch {
      return null;
    }
  };
  const clearPendingPayment = () => {
    try {
      localStorage.removeItem(pendingKey);
    } catch {}
  };

  const ensureStripeClient = async () => {
    if (!stripePk) throw new Error("Stripe not configured.");
    await loadScriptOnce(stripeJsSrc, { id: "ffStripeJs" });
    if (!window.Stripe) throw new Error("Stripe.js unavailable.");
    const key = stripePk;
    if (!S.ui.stripe || S.ui.__stripeKey !== key) {
      S.ui.__stripeKey = key;
      S.ui.stripe = window.Stripe(key, locale ? { locale } : undefined);
    }
    return S.ui.stripe;
  };

  const pricingKey = () => {
    const p = buildPaymentPayload();
    // stable key: things that affect amount/intent
    return [
      p.org_id,
      p.campaign_id,
      p.purpose,
      p.sku,
      p.impact_id,
      p.team_id,
      String(p.amount_cents),
      p.cover_fees ? "1" : "0",
      String(p.fee_cents),
      String(p.total_cents),
    ].join("|");
  };

  const ensureStripeIntent = async () => {
    const v = validateDonation();
    if (!v.ok) throw new Error(v.message);

    const payload = buildPaymentPayload();
    const key = pricingKey();

    // PATCH: intent request de-dupe
    if (S.ui.__intentInFlightPromise && S.ui.__intentInFlightKey === key) {
      const existing = await S.ui.__intentInFlightPromise;
      return existing;
    }

    const headers = {
      "Content-Type": "application/json",
      Accept: "application/json",
    };
    if (csrfToken) {
      // PATCH: send both common CSRF header spellings
      headers["X-CSRF-Token"] = csrfToken;
      headers["X-CSRFToken"] = csrfToken;
    }

    const reqId = (S.ui.__intentReqId = (S.ui.__intentReqId || 0) + 1);

    const promise = (async () => {
      const data = await fetchJson(stripeIntentEndpoint, {
        method: "POST",
        headers,
        body: JSON.stringify(payload),
        credentials: "same-origin",
      });
      const clientSecret = safeText(data?.client_secret || data?.clientSecret || "");
      if (!clientSecret) throw new Error("Missing Stripe client secret.");
      // stale response guard
      if (reqId !== S.ui.__intentReqId) return null;

      S.ui.clientSecret = clientSecret;
      S.ui.intentPricingKey = key;
      return clientSecret;
    })();

    S.ui.__intentInFlightKey = key;
    S.ui.__intentInFlightPromise = promise;

    try {
      return await promise;
    } finally {
      // clear only if still the same promise
      if (S.ui.__intentInFlightPromise === promise) {
        S.ui.__intentInFlightPromise = null;
        S.ui.__intentInFlightKey = "";
      }
    }
  };

  const mountStripePaymentElement = async ({ forceNewIntent = false, reason = "" } = {}) => {
    D = cacheDom();
    if (captureMode) return false;
    if (!stripePk) return false;
    const host = D.paymentElementHost || D.stripeMount;
    if (!host) return false;

    if (S.ui.__stripeInitInFlight) return S.ui.__stripeInitInFlight;

    S.ui.__stripeInitInFlight = (async () => {
      const stripe = await ensureStripeClient();

      const currentKey = pricingKey();
      const alreadyMounted =
        !!S.ui.elements && !!S.ui.paymentElement && !!S.ui.clientSecret && S.ui.stripeMounted;

      // If mounted but pricing changed, we *must* remount now (not on submit) to avoid charging wrong amount.
      if (alreadyMounted && S.ui.intentPricingKey && S.ui.intentPricingKey !== currentKey) {
        forceNewIntent = true;
        reason = reason || "Pricing changed";
      }

      if (alreadyMounted && !forceNewIntent) return true;

      const clientSecret = await ensureStripeIntent();
      if (!clientSecret) return false;

      const appearance = {};
      if (stripeThemeMeta) appearance.theme = stripeThemeMeta;

      S.ui.elements = stripe.elements({
        clientSecret,
        appearance: Object.keys(appearance).length ? appearance : undefined,
      });

      // clear + mount target
      clearChildren(host);
      const mountTarget = h("div", { class: "ff-stripe-element-host" });
      host.appendChild(mountTarget);

      S.ui.paymentElementReady = false;
      S.ui.stripeUserInteracted = false;
      S.ui.paymentElement = S.ui.elements.create("payment", { layout: "tabs" });

      if (D.payBtn) D.payBtn.disabled = true;

      S.ui.paymentElement.on("ready", () => {
        S.ui.paymentElementReady = true;
        D = cacheDom();
        if (D.payBtn && !S.ui.stripeBusy) D.payBtn.disabled = false;
        if (reason) toast(`${reason}: payment form refreshed.`, "info");
      });

      S.ui.paymentElement.on("change", (e) => {
        // PATCH: track interaction to avoid unexpected resets (we still remount if pricing changes)
        if (e && typeof e.empty === "boolean" && e.empty === false) S.ui.stripeUserInteracted = true;
        if (e?.error?.message) setPayError(e.error.message);
        else setPayError("");
      });

      S.ui.paymentElement.mount(mountTarget);

      S.ui.stripeMounted = true;
      return true;
    })();

    try {
      return await S.ui.__stripeInitInFlight;
    } finally {
      S.ui.__stripeInitInFlight = null;
    }
  };

  const confirmStripePayment = async () => {
    if (!S.ui.stripe || !S.ui.elements) throw new Error("Stripe not initialized.");

    const payload = buildPaymentPayload();
    writePendingPayment({
      amount_cents: payload.amount_cents,
      total_cents: payload.total_cents,
      team_id: payload.team_id,
      purpose: payload.purpose,
      impact_id: payload.impact_id,
    });

    // PATCH: required validation step for Payment Element
    const { error: submitError } = await S.ui.elements.submit();
    if (submitError) throw new Error(submitError.message || "Check your payment details.");

    const res = await S.ui.stripe.confirmPayment({
      elements: S.ui.elements,
      confirmParams: { return_url: stripeReturnUrl || window.location.href },
      redirect: "if_required",
    });

    if (res?.error) throw new Error(res.error.message || "Payment failed.");
    return res;
  };

  const handleStripeRedirectStatus = () => {
    const url = new URL(window.location.href);
    const status = url.searchParams.get("redirect_status") || "";
    if (!status) return;

    try {
      for (const k of ["payment_intent", "payment_intent_client_secret", "redirect_status"])
        url.searchParams.delete(k);
      window.history.replaceState({}, document.title, url.toString());
    } catch {}

    D = cacheDom();
    if (D.checkoutStatusText) {
      const label =
        status === "succeeded"
          ? "Payment succeeded."
          : status === "processing"
          ? "Payment processing."
          : status === "requires_payment_method"
          ? "Payment failed. Try another method."
          : `Payment status: ${status}`;
      D.checkoutStatusText.textContent = label;
    }

    if (status === "succeeded") {
      setPaySuccess("Thanks! Your payment was successful.");
      toast("Donation received.", "success");

      const pending = readPendingPayment();
      if (pending?.amount_cents) {
        S.fundraiser.raisedCents += toInt(pending.amount_cents, 0);
        setProgressUI();
      }
      clearPendingPayment();
      renderSponsorBoard();
      renderRecentGifts();
    } else if (status === "processing") {
      toast("Payment processing.", "info");
    } else {
      setPayError("Payment did not complete. Please try again.");
      clearPendingPayment();
    }

    if (D.checkoutMethodPill) setHidden(D.checkoutMethodPill, false);
  };

  const maybePrepareStripeUI = async () => {
    if (!stripeAutoload) return false;
    if (!stripePk) return false;
    if (S.ui.stripeMounted && S.ui.clientSecret) return true;

    const v = validateDonation();
    if (!v.ok) return false;

    return mountStripePaymentElement({ forceNewIntent: true, reason: "" });
  };

  // PATCH: remount Stripe when pricing inputs change (so you never charge the wrong amount)
  const onPricingInputsChanged = debounce(() => {
    if (!stripePk) return;
    if (!S.ui.stripeMounted) return;
    if (!S.ui.clientSecret) return;
    const cur = pricingKey();
    if (S.ui.intentPricingKey && S.ui.intentPricingKey !== cur) {
      // remount now; this may clear entered details, but prevents mismatched charge.
      mountStripePaymentElement({ forceNewIntent: true, reason: "Amount updated" }).catch(() => {});
    }
  }, 220);

  /* ---------------------------------------------
   * PayPal (PATCHED loader id/src behavior)
   * -------------------------------------------*/
  const paypalSdkSrc = () => {
    const base = "https://www.paypal.com/sdk/js";
    const u = new URL(base);
    u.searchParams.set("client-id", paypalClientId);
    u.searchParams.set("currency", paypalCurrency || "USD");
    u.searchParams.set("intent", paypalIntent || "capture");
    u.searchParams.set("components", "buttons");
    return u.toString();
  };

  const initPayPal = async () => {
    D = cacheDom();
    if (!paypalClientId) return false;
    const host = D.paypalButtonsHost || D.paypalMount;
    if (!host) return false;
    if (captureMode) return false;

    const src = paypalSdkSrc();
    await loadScriptOnce(src, { id: "ffPaypalSdk" });
    if (!window.paypal || !window.paypal.Buttons) throw new Error("PayPal SDK unavailable.");

    clearChildren(host);
    const container = h("div", { "data-ff-paypal-buttons": "true" });
    host.appendChild(container);

    const headers = { "Content-Type": "application/json", Accept: "application/json" };
    if (csrfToken) {
      headers["X-CSRF-Token"] = csrfToken;
      headers["X-CSRFToken"] = csrfToken;
    }

    window.paypal
      .Buttons({
        style: { layout: "vertical" },
        createOrder: async () => {
          const v = validateDonation();
          if (!v.ok) throw new Error(v.message);
          const payload = buildPaymentPayload();
          const data = await fetchJson(paypalCreateEndpoint, { method: "POST", headers, body: JSON.stringify(payload) });
          const id = safeText(data?.id || data?.order_id || data?.orderID || "");
          if (!id) throw new Error("Missing PayPal order id.");
          return id;
        },
        onApprove: async (data) => {
          const orderId = safeText(data?.orderID || data?.orderId || "");
          if (!orderId) throw new Error("Missing PayPal order id.");

          setBusy(true);
          setPayError("");
          setPaySuccess("");

          const payload = buildPaymentPayload();
          payload.order_id = orderId;

          const captured = await fetchJson(paypalCaptureEndpoint, { method: "POST", headers, body: JSON.stringify(payload) });

          setPaySuccess("Thanks! Your payment was successful.");
          toast("Donation received.", "success");

          const amountCents = toInt(payload.amount_cents, 0);
          if (amountCents > 0) {
            S.fundraiser.raisedCents += amountCents;
            setProgressUI();
          }
          renderSponsorBoard();
          renderRecentGifts();

          if (D.checkoutStatusText) D.checkoutStatusText.textContent = "Payment succeeded.";
          setBusy(false);
          return captured;
        },
        onCancel: () => toast("PayPal cancelled.", "info"),
        onError: (err) => {
          const msg = safeText(err?.message || err || "PayPal error.");
          setPayError(msg);
          toast("Payment error.", "error");
          setBusy(false);
        },
      })
      .render(container);

    S.ui.paypalReady = true;
    return true;
  };

  window.FF.initPayPal = initPayPal;

  /* ---------------------------------------------
   * Payment provider visibility
   * -------------------------------------------*/
  const bindPaymentProviderVisibility = () => {
    D = cacheDom();

    if (stripePk) {
      if (D.stripeMount) setHidden(D.stripeMount, false);
      if (D.paymentElementHost) setHidden(D.paymentElementHost, false);
      if (D.paypalMount) setHidden(D.paypalMount, !paypalClientId);
      if (D.paypalButtonsHost) setHidden(D.paypalButtonsHost, !paypalClientId);
      if (D.checkoutMethodText) D.checkoutMethodText.textContent = "Card";
      return;
    }

    if (paypalClientId) {
      if (D.stripeMount) setHidden(D.stripeMount, true);
      if (D.paymentElementHost) setHidden(D.paymentElementHost, true);
      if (D.paypalMount) setHidden(D.paypalMount, false);
      if (D.paypalButtonsHost) setHidden(D.paypalButtonsHost, false);
      if (D.checkoutMethodText) D.checkoutMethodText.textContent = "PayPal";
      return;
    }

    if (D.stripeMount) setHidden(D.stripeMount, true);
    if (D.paymentElementHost) setHidden(D.paymentElementHost, true);
    if (D.paypalMount) setHidden(D.paypalMount, true);
    if (D.paypalButtonsHost) setHidden(D.paypalButtonsHost, true);
  };

  /* ---------------------------------------------
   * Payment submission â€” PATCHED (NO reset on submit)
   * -------------------------------------------*/
  const bindPaymentSubmit = () => {
    D = cacheDom();
    if (!D.donationForm && !D.payBtn) return;

    const submit = async (e) => {
      if (e) e.preventDefault();
      if (captureMode) return;

      D = cacheDom();
      setPayError("");
      setPaySuccess("");

      const v = validateDonation();
      if (!v.ok) return (setPayError(v.message), toast(v.message, "error"));

      setBusy(true);

      try {
        if (stripePk) {
          // PATCH: do NOT reset elements/paymentElement/clientSecret here.
          // Only mount if missing; remount happens on pricing changes (not on submit).
          await mountStripePaymentElement({ forceNewIntent: !S.ui.clientSecret });

          // Guard: if pricing changed and remount is pending, block instead of charging wrong amount.
          const cur = pricingKey();
          if (S.ui.intentPricingKey && S.ui.intentPricingKey !== cur) {
            setPayError("Amount changedâ€”refreshing payment form. Please re-check your payment details.");
            await mountStripePaymentElement({ forceNewIntent: true, reason: "Amount updated" });
            throw new Error("Payment form refreshed. Please submit again.");
          }

          const res = await confirmStripePayment();

          // If no redirect required, Stripe may return paymentIntent
          const piStatus = res?.paymentIntent?.status || "";
          if (piStatus === "succeeded") {
            setPaySuccess("Thanks! Your payment was successful.");
            if (D.checkoutStatusText) D.checkoutStatusText.textContent = "Payment succeeded.";

            const payload = buildPaymentPayload();
            const amountCents = toInt(payload.amount_cents, 0);
            if (amountCents > 0) {
              S.fundraiser.raisedCents += amountCents;
              setProgressUI();
            }
            renderSponsorBoard();
            renderRecentGifts();
            toast("Donation received.", "success");
            clearPendingPayment();
          } else if (piStatus === "processing") {
            toast("Payment processing.", "info");
          }
        } else if (paypalClientId) {
          toast("Use the PayPal buttons to complete payment.", "info");
          scrollToDonate();
        } else {
          throw new Error("No payment provider configured.");
        }
      } catch (err) {
        const msg = safeText(err?.message || err || "Payment failed.");
        setPayError(msg);
        toast(msg, "error");
      } finally {
        setBusy(false);
      }
    };

    if (D.donationForm) on(D.donationForm, "submit", submit);
    if (D.payBtn) on(D.payBtn, "click", submit);
  };

  /* ---------------------------------------------
   * Topbar + refresh
   * -------------------------------------------*/
  const bindTopbar = () => {
    D = cacheDom();
    if (!D.topbar) return;

    const key = `ff_topbar_dismiss_${shellEnv.orgId}_${shellEnv.campaignId}`;
    try {
      if (localStorage.getItem(key)) {
        setHidden(D.topbar, true);
        return;
      }
    } catch {}

    if (D.topbarDismiss) {
      on(D.topbarDismiss, "click", (e) => {
        e.preventDefault();
        setHidden(D.topbar, true);
        try {
          localStorage.setItem(key, String(now()));
        } catch {}
      });
    }
  };

  const bindRefreshButtons = () => {
    D = cacheDom();
    for (const btn of D.refreshBtns) {
      on(btn, "click", (e) => {
        e.preventDefault();
        S.fundraiser.raisedCents = deriveRaisedCents();
        setProgressUI();
        applyUpdated();
        applyKpis();
        applyMatch();
        renderSponsorBoard();
        renderRecentGifts();
        renderTeams();
        renderImpact();
        renderAllocation();
        renderGallery();
        setShareFields();
        updateProofKit();
        toast("Refreshed.", "success");
      });
    }
  };

  /* ---------------------------------------------
   * Bind all
   * -------------------------------------------*/
  const bindAll = () => {
    D = cacheDom();
    bindTopbar();
    bindAnchors();
    bindScrollUI();
    bindThemeToggle();
    bindDrawer();

    bindShare();
    bindAuxModals();
    bindRecognition();
    bindAmountControls();
    bindPrefills();

    bindImpactControls();
    bindSponsorControls();
    bindTeamControls();
    bindRefreshButtons();

    bindPaymentProviderVisibility();
    bindPaymentSubmit();
  };

  /* ---------------------------------------------
   * Boot / Hydrate
   * -------------------------------------------*/
  const hydrateInitial = () => {
    readUtm();
    S.fundraiser.raisedCents = deriveRaisedCents();

    applyBrand();
    applyAnnouncement();
    applyUpdated();
    setProgressUI();
    applyKpis();

    startDeadlineLoop();
    applyEventPill();
    applyMatch();

    renderAllocation();
    renderImpact();
    renderSponsorTiers();
    renderSponsorBoard();
    renderTeams();
    renderRecentGifts();
    renderGallery();

    setShareFields();
    updateSummaryUI();
    applyRecognitionPreview();
    updateProofKit();

    handleStripeRedirectStatus();
  };

  const initPayments = async () => {
    if (paypalClientId) {
      try {
        await initPayPal();
      } catch (e) {
        setPayError(safeText(e?.message || "PayPal failed to initialize."));
      }
    }

    if (stripeAutoload && stripePk) {
      try {
        await maybePrepareStripeUI();
      } catch {}
    }
  };

  const boot = async () => {
    if (captureMode) return;
    try {
      bindAll();
      hydrateInitial();
      await initPayments();
      applyScrollUI();
    } catch (e) {
      console.error("[ff-app] boot error:", e);
      toast("Some features failed to load.", "error");
    }
  };

  if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", boot);
  else boot();
})();

