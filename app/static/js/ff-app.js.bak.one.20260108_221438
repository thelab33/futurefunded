can you refactor /* ============================================================================
  FutureFunded • Flagship v8 — ff-app.js (from scratch)
  - Works with the provided index.html (keeps IDs + data-ff hooks)
  - No dependencies (except Stripe.js which is already loaded)
  - Graceful: if elements/config are missing, it no-ops safely
============================================================================ */
(() => {
  "use strict";

  /* ---------------------------------------------
   * Helpers
   * -------------------------------------------*/
  const qs = (sel, root = document) => root.querySelector(sel);
  const qsa = (sel, root = document) => Array.from(root.querySelectorAll(sel));
  const on = (el, evt, fn, opts) => el && el.addEventListener(evt, fn, opts);
  const clamp = (n, a, b) => Math.max(a, Math.min(b, n));
  const safeText = (v) => (v === null || v === undefined ? "" : String(v));
  const isEmail = (s) => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(String(s || "").trim());
  const nowISO = () => new Date().toISOString();

  const fmtUSD0 = new Intl.NumberFormat("en-US", {
    style: "currency",
    currency: "USD",
    maximumFractionDigits: 0
  });
  const fmtUSD2 = new Intl.NumberFormat("en-US", {
    style: "currency",
    currency: "USD",
    maximumFractionDigits: 2
  });

  const parseAmount = (raw) => {
    // Accept: "75", "$75", "75.00", "1,000"
    const s = String(raw || "")
      .replace(/[^\d.]/g, "")
      .trim();
    if (!s) return 0;
    const n = Number(s);
    if (!Number.isFinite(n) || n <= 0) return 0;
    // cents ok, but keep sane
    return Math.round(n * 100) / 100;
  };

  const roundUpToNext = (amt, step) => {
    const a = Number(amt) || 0;
    const s = Number(step) || 5;
    if (a <= 0) return 0;
    const next = Math.ceil(a / s) * s;
    return Math.round((next - a) * 100) / 100;
  };

  const pct = (raised, goal) => {
    const r = Number(raised) || 0;
    const g = Number(goal) || 0;
    if (g <= 0) return 0;
    return clamp(Math.round((r / g) * 100), 0, 100);
  };

  const computeDaysLeft = (deadlineISO) => {
    if (!deadlineISO) return null;
    const d = new Date(deadlineISO);
    if (Number.isNaN(d.getTime())) return null;
    const ms = d.getTime() - Date.now();
    return Math.max(0, Math.ceil(ms / (1000 * 60 * 60 * 24)));
  };

  const computeDeadlineLabel = (deadlineISO) => {
    if (!deadlineISO) return "—";
    const d = new Date(deadlineISO);
    if (Number.isNaN(d.getTime())) return "—";
    // "Feb 28, 2026"
    const f = new Intl.DateTimeFormat("en-US", { month: "short", day: "2-digit", year: "numeric" });
    return f.format(d);
  };

  const money = (n, preferCents = false) => {
    const v = Number(n) || 0;
    if (preferCents && v % 1 !== 0) return fmtUSD2.format(v);
    return fmtUSD0.format(v);
  };

  const uid = () => {
    try {
      if (crypto && crypto.randomUUID) return crypto.randomUUID();
    } catch (_) {}
    return `ff_${Math.random().toString(16).slice(2)}_${Date.now()}`;
  };

  const meta = (name) => {
    const el = qs(`meta[name="${name}"]`);
    return el ? (el.content || "").trim() : "";
  };

  const setHidden = (el, h) => el && (el.hidden = !!h);
  const setText = (el, t) => el && (el.textContent = safeText(t));
  const setAttr = (el, k, v) => el && el.setAttribute(k, safeText(v));
  const delAttr = (el, k) => el && el.removeAttribute(k);

  const toastRegion = qs("#toastRegion");
  const toast = (msg, opts = {}) => {
    if (!toastRegion) return;
    const id = uid();
    const div = document.createElement("div");
    div.className = "ff-toast__item";
    div.setAttribute("role", "status");
    div.setAttribute("aria-live", "polite");
    div.dataset.toastId = id;

    const strong = document.createElement("strong");
    strong.textContent = opts.title ? String(opts.title) : "Notice";
    const p = document.createElement("p");
    p.className = "ff-help";
    p.style.margin = "6px 0 0";
    p.textContent = String(msg || "");

    const btn = document.createElement("button");
    btn.className = "ff-icon";
    btn.type = "button";
    btn.setAttribute("aria-label", "Dismiss notification");
    btn.innerHTML = "<span aria-hidden='true'>✕</span>";
    btn.addEventListener("click", () => div.remove());

    const row = document.createElement("div");
    row.className = "ff-row ff-row--between";
    row.style.alignItems = "flex-start";
    row.style.gap = "10px";

    const left = document.createElement("div");
    left.appendChild(strong);
    left.appendChild(p);

    row.appendChild(left);
    row.appendChild(btn);

    div.appendChild(row);
    toastRegion.appendChild(div);

    const ttl = Number(opts.ttlMs ?? 3600);
    if (ttl > 0) setTimeout(() => div.remove(), ttl);
  };

  const copyText = async (text) => {
    const val = String(text || "");
    try {
      if (navigator.clipboard && navigator.clipboard.writeText) {
        await navigator.clipboard.writeText(val);
        return true;
      }
    } catch (_) {}
    // fallback
    try {
      const ta = document.createElement("textarea");
      ta.value = val;
      ta.style.position = "fixed";
      ta.style.top = "-9999px";
      ta.style.left = "-9999px";
      document.body.appendChild(ta);
      ta.focus();
      ta.select();
      const ok = document.execCommand("copy");
      ta.remove();
      return !!ok;
    } catch (_) {
      return false;
    }
  };

  /* ---------------------------------------------
   * Config
   * -------------------------------------------*/
  const shell = qs("[data-ff-shell]");
  const tier = (shell && shell.getAttribute("data-ff-tier")) || "standard";
  const orgId = (shell && shell.getAttribute("data-ff-org")) || "default";
  const campaignId = (shell && shell.getAttribute("data-ff-campaign")) || "season";
  const page = (shell && shell.getAttribute("data-ff-page")) || "fundraiser";

  const DEFAULTS = {
    org: {
      name: "FutureFunded",
      meta: "Youth program",
      seasonPill: "Season Fund",
      sportPill: "Youth program",
      heroAccentLine: "Keep kids playing.",
      footerTagline: "Fuel the season. Fund the future.",
      logo: ""
    },
    fundraiser: {
      goalAmount: 25000,
      deadlineISO: "",
      currency: "USD",
      announcement: "" // if non-empty, shows announcement bar
    },
    impact: {
      cards: [
        { id: "gym", title: "Gym time", desc: "Cover practice space for the week.", amount: 75, note: "Helping with gym time." },
        { id: "travel", title: "Travel", desc: "Gas, vans, and tournament weekends.", amount: 150, note: "Helping with travel." },
        { id: "gear", title: "Gear", desc: "Shoes, uniforms, and safe equipment.", amount: 250, note: "Helping with gear." },
        { id: "scholarship", title: "Scholarship", desc: "Support families who need help.", amount: 500, note: "Helping with scholarships." }
      ]
    },
    allocation: [
      { label: "Travel + tournaments", pct: 45 },
      { label: "Gym time + training", pct: 35 },
      { label: "Gear + uniforms", pct: 20 }
    ],
    sponsors: {
      tiers: [
        { id: "bronze", name: "Bronze", amount: 250, perks: ["Name on sponsor wall", "Thank-you post"] },
        { id: "silver", name: "Silver", amount: 500, perks: ["Logo on sponsor wall", "Thank-you post"] },
        { id: "gold", name: "Gold", amount: 1000, perks: ["Logo + link", "Leaderboard placement", "Thank-you post"] }
      ],
      leaderboard: [], // [{name, amount, website, logoUrl}]
      wall: [] // [{name, website, logoUrl}]
    },
    match: {
      active: false,
      endsISO: "" // optional
    },
    fees: {
      // Default Stripe-ish blended estimate (you should override from server if you want exact)
      pct: 0.029,
      flat: 0.3,
      enabled: true
    },
    share: {
      caption: "" // if blank, we generate from org name/goal
    }
  };

  const cfg = (() => {
    const c = window.__FF_CONFIG || {};
    // shallow-ish merge with defaults (good enough for front-end config)
    const merged = {
      ...DEFAULTS,
      ...c,
      org: { ...DEFAULTS.org, ...(c.org || {}) },
      fundraiser: { ...DEFAULTS.fundraiser, ...(c.fundraiser || {}) },
      impact: { ...DEFAULTS.impact, ...(c.impact || {}) },
      sponsors: {
        ...DEFAULTS.sponsors,
        ...(c.sponsors || {}),
        tiers: Array.isArray((c.sponsors || {}).tiers) ? c.sponsors.tiers : DEFAULTS.sponsors.tiers,
        leaderboard: Array.isArray((c.sponsors || {}).leaderboard) ? c.sponsors.leaderboard : DEFAULTS.sponsors.leaderboard,
        wall: Array.isArray((c.sponsors || {}).wall) ? c.sponsors.wall : DEFAULTS.sponsors.wall
      },
      match: { ...DEFAULTS.match, ...(c.match || {}) },
      fees: { ...DEFAULTS.fees, ...(c.fees || {}) },
      allocation: Array.isArray(c.allocation) ? c.allocation : DEFAULTS.allocation,
      teams: Array.isArray(c.teams) ? c.teams : []
    };
    return merged;
  })();

  // Expose a stable read-only config handle (useful for debugging/integrations)
  window.FF = window.FF || {};
  window.FF.config = cfg;

  /* ---------------------------------------------
   * Premium-only toggles (data-ff-premium-only)
   * -------------------------------------------*/
  const applyPremiumVisibility = () => {
    const premium = tier === "premium";
    qsa("[data-ff-premium-only]").forEach((el) => {
      // Keep "hidden" attributes for placeholders unless premium.
      // If premium: only unhide if element isn't explicitly hidden by author for other reasons.
      if (!premium) el.hidden = true;
    });
  };

  /* ---------------------------------------------
   * Theme
   * -------------------------------------------*/
  const THEME_KEY = "ff_theme_v8";
  const themeToggleBtn = qs("[data-ff-theme-toggle]");

  const getTheme = () => {
    const t = (localStorage.getItem(THEME_KEY) || "").trim();
    if (t === "dark" || t === "light") return t;
    const t2 = (localStorage.getItem("ff_theme") || "").trim();
    if (t2 === "dark" || t2 === "light") return t2;
    return document.documentElement.getAttribute("data-theme") || "dark";
  };

  const setTheme = (t) => {
    const theme = t === "light" ? "light" : "dark";
    document.documentElement.setAttribute("data-theme", theme);
    try {
      localStorage.setItem(THEME_KEY, theme);
    } catch (_) {}
    if (themeToggleBtn) {
      themeToggleBtn.setAttribute("aria-pressed", String(theme === "light"));
      themeToggleBtn.textContent = theme === "light" ? "☀" : "☾";
    }
  };

  /* ---------------------------------------------
   * Announcement bar
   * -------------------------------------------*/
  const ann = qs("[data-ff-announcement]");
  const annText = qs("#announcementText");
  const annDismiss = qs("[data-ff-announcement-dismiss]");
  const ANN_KEY = `ff_ann_dismissed_v8:${orgId}:${campaignId}`;

  const initAnnouncement = () => {
    const text = safeText(cfg.fundraiser.announcement || "").trim();
    if (!ann || !annText) return;

    let dismissed = false;
    try {
      dismissed = localStorage.getItem(ANN_KEY) === "1";
    } catch (_) {}

    if (!text || dismissed) {
      ann.hidden = true;
      return;
    }

    annText.textContent = text;
    ann.hidden = false;

    on(annDismiss, "click", () => {
      ann.hidden = true;
      try {
        localStorage.setItem(ANN_KEY, "1");
      } catch (_) {}
    });
  };

  /* ---------------------------------------------
   * Topbar dismiss
   * -------------------------------------------*/
  const topbar = qs("[data-ff-topbar]");
  const topbarDismiss = qs("[data-ff-topbar-dismiss]");
  const TOPBAR_KEY = `ff_topbar_dismissed_v8:${orgId}:${campaignId}`;

  const initTopbar = () => {
    if (!topbar) return;
    let dismissed = false;
    try {
      dismissed = localStorage.getItem(TOPBAR_KEY) === "1";
    } catch (_) {}
    if (dismissed) topbar.style.display = "none";
    on(topbarDismiss, "click", () => {
      topbar.style.display = "none";
      try {
        localStorage.setItem(TOPBAR_KEY, "1");
      } catch (_) {}
    });
  };

  /* ---------------------------------------------
   * Drawer (mobile)
   * -------------------------------------------*/
  const drawer = qs("[data-ff-drawer]");
  const drawerPanel = qs("[data-ff-drawer-panel]");
  const drawerOpenBtn = qs("[data-ff-drawer-open]");
  const drawerCloseBtns = qsa("[data-ff-drawer-close]");

  const focusableSel =
    'a[href], button:not([disabled]), textarea, input, select, details summary, [tabindex]:not([tabindex="-1"])';

  const trapFocus = (container, e) => {
    const items = qsa(focusableSel, container).filter((el) => !el.hidden && el.offsetParent !== null);
    if (!items.length) return;
    const first = items[0];
    const last = items[items.length - 1];
    if (e.key === "Tab" && e.shiftKey && document.activeElement === first) {
      e.preventDefault();
      last.focus();
    } else if (e.key === "Tab" && !e.shiftKey && document.activeElement === last) {
      e.preventDefault();
      first.focus();
    }
  };

  let lastFocus = null;

  const openDrawer = () => {
    if (!drawer) return;
    lastFocus = document.activeElement;
    drawer.hidden = false;
    drawer.setAttribute("aria-hidden", "false");
    if (drawerOpenBtn) drawerOpenBtn.setAttribute("aria-expanded", "true");
    document.body.style.overflow = "hidden";
    setTimeout(() => drawerPanel && drawerPanel.focus(), 0);
  };

  const closeDrawer = () => {
    if (!drawer) return;
    drawer.hidden = true;
    drawer.setAttribute("aria-hidden", "true");
    if (drawerOpenBtn) drawerOpenBtn.setAttribute("aria-expanded", "false");
    document.body.style.overflow = "";
    if (lastFocus && lastFocus.focus) lastFocus.focus();
  };

  const initDrawer = () => {
    on(drawerOpenBtn, "click", openDrawer);
    drawerCloseBtns.forEach((b) => on(b, "click", closeDrawer));
    on(document, "keydown", (e) => {
      if (!drawer || drawer.hidden) return;
      if (e.key === "Escape") closeDrawer();
      if (e.key === "Tab") trapFocus(drawer, e);
    });
  };

  /* ---------------------------------------------
   * Modals (share, sponsor kit, checkout, success)
   * -------------------------------------------*/
  const modalEls = {
    share: qs('#shareModal[data-ff-modal="share"]'),
    sponsorKit: qs('#sponsorKitModal[data-ff-modal="sponsorKit"]'),
    checkout: qs('#checkoutModal[data-ff-modal="checkout"]'),
    success: qs('#successModal[data-ff-modal="success"]')
  };
  const modalCloseBtns = qsa("[data-ff-modal-close]");

  const openModal = (name) => {
    const m = modalEls[name];
    if (!m) return;
    lastFocus = document.activeElement;
    m.hidden = false;
    m.setAttribute("aria-hidden", "false");
    document.body.style.overflow = "hidden";
    const panel = qs("[data-ff-modal-panel]", m);
    setTimeout(() => panel && panel.focus(), 0);
  };

  const closeModal = (name) => {
    const m = modalEls[name];
    if (!m) return;
    m.hidden = true;
    m.setAttribute("aria-hidden", "true");
    document.body.style.overflow = "";
    if (lastFocus && lastFocus.focus) lastFocus.focus();
  };

  const closeAllModals = () => {
    Object.keys(modalEls).forEach(closeModal);
  };

  const initModals = () => {
    modalCloseBtns.forEach((b) =>
      on(b, "click", () => {
        // close nearest modal
        const m = b.closest(".ff-modal");
        if (!m) return;
        const name = m.getAttribute("data-ff-modal");
        if (name) closeModal(name);
      })
    );

    on(document, "keydown", (e) => {
      if (e.key !== "Escape") return;
      // Close whichever modal is open (topmost)
      const open = Object.entries(modalEls).find(([, el]) => el && !el.hidden);
      if (open) closeModal(open[0]);
    });

    // Focus trap for any open modal
    on(document, "keydown", (e) => {
      if (e.key !== "Tab") return;
      const open = Object.values(modalEls).find((el) => el && !el.hidden);
      if (!open) return;
      trapFocus(open, e);
    });
  };

  /* ---------------------------------------------
   * Share system
   * -------------------------------------------*/
  const shareOpenBtns = qsa("[data-ff-share-open]");
  const copyLinkBtns = qsa("[data-ff-copy-link]");
  const nativeShareBtns = qsa("[data-ff-native-share]");

  const shareLinkInput = qs("#shareLink");
  const shareCaptionTa = qs("#shareCaption");
  const shareQrImg = qs("#shareQr");
  const successCaptionTa = qs("#successCaption");
  const successCopyCaptionBtn = qs("[data-ff-success-copy-caption]");
  const copyCaptionBtn = qs("[data-ff-copy-caption]");

  const kitLinkInput = qs("#kitLink");
  const kitCaptionTa = qs("#kitCaption");
  const kitTierList = qs("#kitTierList");
  const copyKitCaptionBtn = qs("[data-ff-copy-kit-caption]");

  const getBaseShareLink = () => {
    // Keep URL clean, preserve campaign/page
    try {
      const u = new URL(window.location.href);
      // Keep any embed/whitelabel params if you want; otherwise drop them here
      u.hash = "";
      return u.toString();
    } catch (_) {
      return window.location.href.split("#")[0];
    }
  };

  const buildShareCaption = () => {
    const org = cfg.org?.name || "our program";
    const goal = money(cfg.fundraiser?.goalAmount || 0);
    return (
      (cfg.share && cfg.share.caption) ||
      `Support ${org}—we’re raising ${goal} for the season. Any amount helps. Donate here:`
    );
  };

  const qrEndpoint = meta("ff-qr-endpoint") || "https://api.qrserver.com/v1/create-qr-code/";

  const buildQrUrl = (data) => {
    const base = qrEndpoint.endsWith("/") ? qrEndpoint : `${qrEndpoint}`;
    const size = "220x220";
    const margin = "10";
    const u = new URL(base);
    u.searchParams.set("size", size);
    u.searchParams.set("margin", margin);
    u.searchParams.set("data", data);
    return u.toString();
  };

  const openShareModal = async (opts = {}) => {
    const link = opts.link || getBaseShareLink();
    const caption = `${buildShareCaption()} ${link}`;

    if (shareLinkInput) shareLinkInput.value = link;
    if (shareCaptionTa) shareCaptionTa.value = caption;
    if (shareQrImg) shareQrImg.src = buildQrUrl(link);

    openModal("share");
  };

  const initShare = () => {
    // Delegated clicks for future dynamic nodes
    on(document, "click", async (e) => {
      const shareBtn = e.target.closest("[data-ff-share-open]");
      if (shareBtn) {
        e.preventDefault();
        await openShareModal();
        return;
      }

      const copyBtn = e.target.closest("[data-ff-copy-link]");
      if (copyBtn) {
        e.preventDefault();
        const link = getBaseShareLink();
        const ok = await copyText(link);
        toast(ok ? "Link copied." : "Could not copy link.", { title: "Share" });
        return;
      }

      const capBtn = e.target.closest("[data-ff-copy-caption]");
      if (capBtn) {
        e.preventDefault();
        const link = getBaseShareLink();
        const caption = `${buildShareCaption()} ${link}`;
        const ok = await copyText(caption);
        toast(ok ? "Caption copied." : "Could not copy caption.", { title: "Share" });
        return;
      }

      const kitCapBtn = e.target.closest("[data-ff-copy-kit-caption]");
      if (kitCapBtn) {
        e.preventDefault();
        const text = kitCaptionTa ? kitCaptionTa.value : "";
        const ok = await copyText(text);
        toast(ok ? "Sponsor caption copied." : "Could not copy sponsor caption.", { title: "Sponsor kit" });
        return;
      }

      const successCapBtn = e.target.closest("[data-ff-success-copy-caption]");
      if (successCapBtn) {
        e.preventDefault();
        const text = successCaptionTa ? successCaptionTa.value : "";
        const ok = await copyText(text);
        toast(ok ? "Caption copied." : "Could not copy caption.", { title: "Share kit" });
        return;
      }

      const nativeBtn = e.target.closest("[data-ff-native-share]");
      if (nativeBtn) {
        e.preventDefault();
        const link = getBaseShareLink();
        const caption = `${buildShareCaption()} ${link}`;
        if (navigator.share) {
          try {
            await navigator.share({ text: caption, url: link, title: cfg.org?.name || "Fundraiser" });
          } catch (_) {}
        } else {
          const ok = await copyText(caption);
          toast(ok ? "Copied caption (native share not available)." : "Could not share.", { title: "Share" });
        }
        return;
      }
    });

    // Sponsor kit open
    on(document, "click", (e) => {
      const btn = e.target.closest("[data-ff-sponsor-kit-open]");
      if (!btn) return;
      e.preventDefault();
      const link = getBaseShareLink();
      if (kitLinkInput) kitLinkInput.value = link;

      // Render tiers in kit
      renderSponsorKitTiers();

      // Build sponsor-focused caption
      const org = cfg.org?.name || "our program";
      const tiers = (cfg.sponsors?.tiers || []).slice(0, 4);
      const tierLine = tiers.map((t) => `${t.name}: ${money(t.amount)}`).join(" • ");
      const cap =
        `Hi! Would you consider sponsoring ${org}? Your support helps fund travel, gym time, and gear.\n\n` +
        `Tiers: ${tierLine}\n\n` +
        `Sponsors get recognition on the sponsor wall + leaderboard.\n\n` +
        `Link: ${link}`;
      if (kitCaptionTa) kitCaptionTa.value = cap;

      openModal("sponsorKit");
    });
  };

  /* ---------------------------------------------
   * Scroll UI: progress bar, sticky CTA, back-to-top
   * -------------------------------------------*/
  const scrollProgressBar = qs("#scrollProgressBar");
  const sticky = qs("#stickyDonate[data-ff-sticky-cta]");
  const backToTop = qs("#backToTop");

  const updateScrollUi = () => {
    const doc = document.documentElement;
    const scrollTop = doc.scrollTop || document.body.scrollTop || 0;
    const scrollHeight = doc.scrollHeight || 1;
    const clientHeight = doc.clientHeight || 1;
    const max = Math.max(1, scrollHeight - clientHeight);
    const p = clamp(scrollTop / max, 0, 1);

    if (scrollProgressBar) scrollProgressBar.style.width = `${Math.round(p * 100)}%`;

    const showSticky = scrollTop > 520;
    if (sticky) sticky.hidden = !showSticky;

    if (backToTop) backToTop.hidden = scrollTop < 600;
  };

  const initScrollUi = () => {
    on(window, "scroll", updateScrollUi, { passive: true });
    on(window, "resize", updateScrollUi);
    on(backToTop, "click", () => window.scrollTo({ top: 0, behavior: "smooth" }));
    updateScrollUi();
  };

  /* ---------------------------------------------
   * Section spy (nav highlighting)
   * -------------------------------------------*/
  const initSectionSpy = () => {
    const navLinks = qsa('[data-spy]');
    if (!navLinks.length || !("IntersectionObserver" in window)) return;

    const map = new Map(); // id -> link
    navLinks.forEach((a) => {
      const id = a.getAttribute("data-spy");
      if (id) map.set(id, a);
    });

    const sections = Array.from(map.keys())
      .map((id) => qs(`#${CSS.escape(id)}`))
      .filter(Boolean);

    const activate = (id) => {
      navLinks.forEach((a) => a.classList.toggle("is-active", a.getAttribute("data-spy") === id));
    };

    const io = new IntersectionObserver(
      (entries) => {
        const visible = entries
          .filter((e) => e.isIntersecting)
          .sort((a, b) => b.intersectionRatio - a.intersectionRatio)[0];
        if (!visible) return;
        const id = visible.target.id;
        if (id) activate(id);
      },
      { root: null, threshold: [0.12, 0.22, 0.35] }
    );

    sections.forEach((s) => io.observe(s));
  };

  /* ---------------------------------------------
   * Fundraiser progress + header/footer binding
   * -------------------------------------------*/
  const elsProgress = {
    orgPill: qs("#orgPill"),
    orgName: qs("#orgName"),
    orgMeta: qs("#orgMeta"),
    brandLogo: qs("#brandLogo"),
    heroLogo: qs("#heroLogo"),
    heroOrgLine: qs("#heroOrgLine"),
    seasonPill: qs("#seasonPill"),
    sportPill: qs("#sportPill"),
    heroAccentLine: qs("#heroAccentLine"),
    footerBrandLogo: qs("#footerBrandLogo"),
    footerOrgName: qs("#footerOrgName"),
    footerTagline: qs("#footerTagline"),
    footerYear: qs("#footerYear"),
    footerLegalName: qs("#footerLegalName"),

    // Progress card
    raisedBig: qs("#raisedBig"),
    raisedRow: qs("#raisedRow"),
    goalRow: qs("#goalRow"),
    goalPill: qs("#goalPill"),
    pctText: qs("#pctText"),
    overallBar: qs("#overallBar"),
    progressMeta: qs("#progressMeta"),
    remainingText: qs("#remainingText"),
    deadlineText: qs("#deadlineText"),
    lastUpdatedText: qs("#lastUpdatedText"),

    donorsText: qs("#donorsText"),
    avgGiftText: qs("#avgGiftText"),
    daysLeftText: qs("#daysLeftText"),
    nextMilestoneText: qs("#nextMilestoneText"),

    // Topbar update pills
    lastUpdatedInline: qs("#lastUpdatedInline"),
    lastUpdatedPill: qs("#lastUpdatedPill"),

    // Sticky donate bar
    stickyOrg: qs("#stickyOrg"),
    stickyRaised: qs("#stickyRaised"),
    stickyGoal: qs("#stickyGoal"),
    stickyPct: qs("#stickyPct"),
    stickyDays: qs("#stickyDays"),
    stickyBar: qs("#stickyBar"),

    // Footer sponsor slots (optional)
    footerSponsorSlots: qs("#footerSponsorSlots"),
    footerSponsorSlotsNum: qs("#footerSponsorSlotsNum")
  };

  const computeFundraiserTotals = () => {
    // If server supplies fundraiser.raisedAmount, use it; else sum teams raised
    const teams = Array.isArray(cfg.teams) ? cfg.teams : [];
    const sumTeams = teams.reduce((acc, t) => acc + (Number(t.raised) || 0), 0);

    const goal = Number(cfg.fundraiser?.goalAmount) || 0;
    const raised = Number(cfg.fundraiser?.raisedAmount) || sumTeams;

    // Donors/avg gift may be provided; else estimate from gifts list if present; else 0
    const donors = Number(cfg.fundraiser?.donors) || 0;
    const avgGift = Number(cfg.fundraiser?.avgGift) || (donors > 0 ? raised / donors : 0);

    return { goal, raised, donors, avgGift };
  };

  const nextMilestone = (raised, goal) => {
    if (goal <= 0) return "—";
    const milestones = [0.25, 0.5, 0.75, 1];
    const r = raised / goal;
    const next = milestones.find((m) => r < m);
    if (!next) return "Goal hit";
    const amt = Math.max(0, Math.ceil(goal * next - raised));
    const pctLabel = `${Math.round(next * 100)}%`;
    return `${pctLabel} → ${money(amt)} to go`;
  };

  const bindOrg = () => {
    const orgName = cfg.org?.name || "Organization";
    const orgMeta = cfg.org?.meta || "";
    const seasonPill = cfg.org?.seasonPill || "Season Fund";
    const sportPill = cfg.org?.sportPill || "Youth program";
    const heroAccent = cfg.org?.heroAccentLine || "Keep kids playing.";
    const footerTagline = cfg.org?.footerTagline || DEFAULTS.org.footerTagline;

    setText(elsProgress.orgPill, "Fundraiser");
    setText(elsProgress.orgName, orgName);
    setText(elsProgress.orgMeta, orgMeta);
    setText(elsProgress.heroOrgLine, `${orgName} • Fundraiser`);
    setText(elsProgress.seasonPill, seasonPill);
    setText(elsProgress.sportPill, sportPill);
    setText(elsProgress.heroAccentLine, heroAccent);

    setText(elsProgress.footerOrgName, orgName);
    setText(elsProgress.footerTagline, footerTagline);
    setText(elsProgress.footerLegalName, orgName);
    setText(elsProgress.footerYear, String(new Date().getFullYear()));

    // Logos: keep current src unless config provides one
    const logoSrc = safeText(cfg.org?.logo || "").trim();
    if (logoSrc) {
      if (elsProgress.brandLogo) elsProgress.brandLogo.src = logoSrc;
      if (elsProgress.heroLogo) elsProgress.heroLogo.src = logoSrc;
      if (elsProgress.footerBrandLogo) elsProgress.footerBrandLogo.src = logoSrc;
    } else {
      // mirror header logo into footer logo if footer empty
      if (elsProgress.footerBrandLogo && elsProgress.brandLogo && elsProgress.brandLogo.src) {
        elsProgress.footerBrandLogo.src = elsProgress.brandLogo.src;
        elsProgress.footerBrandLogo.alt = "";
      }
    }

    // Sticky
    setText(elsProgress.stickyOrg, orgName);
  };

  const bindProgress = () => {
    const { goal, raised, donors, avgGift } = computeFundraiserTotals();
    const p = pct(raised, goal);
    const remaining = Math.max(0, goal - raised);
    const deadlineISO = cfg.fundraiser?.deadlineISO || "";
    const deadlineLabel = computeDeadlineLabel(deadlineISO);
    const daysLeft = computeDaysLeft(deadlineISO);

    setText(elsProgress.raisedBig, money(raised));
    setText(elsProgress.raisedRow, money(raised));
    setText(elsProgress.goalRow, money(goal));
    setText(elsProgress.goalPill, money(goal));
    setText(elsProgress.pctText, String(p));

    if (elsProgress.overallBar) elsProgress.overallBar.style.width = `${p}%`;

    const meter = qs('[data-ff-meter="overall"]');
    if (meter) {
      setAttr(meter, "aria-valuenow", String(p));
      setAttr(meter, "aria-valuetext", `${p}% funded`);
    }

    setText(elsProgress.remainingText, money(remaining));
    setText(elsProgress.deadlineText, deadlineLabel);
    setText(elsProgress.donorsText, String(donors || 0));
    setText(elsProgress.avgGiftText, avgGift ? money(avgGift, true) : money(0));
    setText(elsProgress.daysLeftText, daysLeft === null ? "—" : String(daysLeft));
    setText(elsProgress.nextMilestoneText, nextMilestone(raised, goal));

    // Updated pills
    const updated = new Date();
    const updatedLabel = new Intl.DateTimeFormat("en-US", { month: "short", day: "2-digit", hour: "numeric", minute: "2-digit" }).format(
      updated
    );
    setText(elsProgress.lastUpdatedInline, updatedLabel);
    setText(elsProgress.lastUpdatedText, `Updated — ${updatedLabel}`);

    // Sticky bar
    setText(elsProgress.stickyRaised, money(raised));
    setText(elsProgress.stickyGoal, money(goal));
    setText(elsProgress.stickyPct, `${p}%`);
    setText(elsProgress.stickyDays, daysLeft === null ? "—" : `${daysLeft} days left`);
    if (elsProgress.stickyBar) elsProgress.stickyBar.style.width = `${p}%`;

    const stickyProg = qs(".ff-sticky__bar[role='progressbar']");
    if (stickyProg) {
      setAttr(stickyProg, "aria-valuenow", String(p));
      setAttr(stickyProg, "aria-valuetext", `${p}% funded`);
    }
  };

  /* ---------------------------------------------
   * Impact cards + Allocation rendering
   * -------------------------------------------*/
  const impactGrid = qs("#impactGrid");
  const allocationList = qs("#allocationList");
  const impactPrefillPill = qs("#impactPrefillPill");
  const donatePrefillPill = qs("#donatePrefillPill");

  const renderImpact = () => {
    if (!impactGrid) return;
    const cards = Array.isArray(cfg.impact?.cards) ? cfg.impact.cards : [];
    const frag = document.createDocumentFragment();

    const mk = (c) => {
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "ff-card ff-card--lift ff-pad";
      btn.style.textAlign = "left";
      btn.dataset.ffImpact = c.id || "";
      btn.dataset.prefillAmount = String(c.amount || "");
      btn.dataset.prefillNote = safeText(c.note || "");
      btn.setAttribute("aria-label", `${c.title || "Impact"}: ${money(c.amount || 0)}`);

      const k = document.createElement("div");
      k.className = "ff-kicker";
      k.textContent = "Impact";

      const title = document.createElement("div");
      title.className = "ff-card__title";
      title.style.marginTop = "6px";
      title.textContent = safeText(c.title || "Impact");

      const desc = document.createElement("p");
      desc.className = "ff-help";
      desc.style.marginTop = "6px";
      desc.textContent = safeText(c.desc || "");

      const row = document.createElement("div");
      row.className = "ff-row ff-row--between";
      row.style.marginTop = "10px";

      const amt = document.createElement("strong");
      amt.className = "ff-num";
      amt.textContent = money(c.amount || 0);

      const pill = document.createElement("span");
      pill.className = "ff-pill";
      pill.textContent = "Prefill";

      row.appendChild(amt);
      row.appendChild(pill);

      btn.appendChild(k);
      btn.appendChild(title);
      btn.appendChild(desc);
      btn.appendChild(row);

      return btn;
    };

    if (!cards.length) {
      impactGrid.innerHTML = "";
      return;
    }

    cards.forEach((c) => frag.appendChild(mk(c)));
    impactGrid.innerHTML = "";
    impactGrid.appendChild(frag);
  };

  const renderAllocation = () => {
    if (!allocationList) return;
    const list = Array.isArray(cfg.allocation) ? cfg.allocation : [];

    const total = list.reduce((acc, it) => acc + (Number(it.pct) || 0), 0);
    // If not 100, normalize quietly
    const norm = total > 0 ? (x) => Math.round((x / total) * 100) : (x) => x;

    const frag = document.createDocumentFragment();
    list.forEach((it) => {
      const pctVal = Number(it.pct) || 0;
      const pctShow = total === 100 ? pctVal : norm(pctVal);

      const wrap = document.createElement("div");
      wrap.className = "ff-mini";

      const row = document.createElement("div");
      row.className = "ff-row ff-row--between";
      row.style.alignItems = "baseline";

      const label = document.createElement("strong");
      label.className = "ff-num";
      label.textContent = safeText(it.label || "Allocation");

      const pctEl = document.createElement("span");
      pctEl.className = "ff-pill";
      pctEl.textContent = `${pctShow}%`;

      row.appendChild(label);
      row.appendChild(pctEl);

      const meter = document.createElement("div");
      meter.className = "ff-meter";
      meter.style.marginTop = "10px";
      meter.setAttribute("role", "progressbar");
      meter.setAttribute("aria-valuemin", "0");
      meter.setAttribute("aria-valuemax", "100");
      meter.setAttribute("aria-valuenow", String(clamp(pctShow, 0, 100)));
      meter.setAttribute("aria-valuetext", `${pctShow}%`);

      const ticks = document.createElement("div");
      ticks.className = "ff-meter__ticks";
      ticks.setAttribute("aria-hidden", "true");
      ticks.innerHTML = '<i style="left:25%"></i><i style="left:50%"></i><i style="left:75%"></i><i style="left:100%"></i>';

      const bar = document.createElement("span");
      bar.style.width = `${clamp(pctShow, 0, 100)}%`;

      meter.appendChild(ticks);
      meter.appendChild(bar);

      wrap.appendChild(row);
      wrap.appendChild(meter);

      frag.appendChild(wrap);
    });

    allocationList.innerHTML = "";
    allocationList.appendChild(frag);
  };

  /* ---------------------------------------------
   * Sponsors: tiers + leaderboard + wall
   * -------------------------------------------*/
  const sponsorTiersEl = qs("#sponsorTiers");
  const sponsorLeaderboardEl = qs("#sponsorLeaderboard");
  const sponsorWallEl = qs("#sponsorWall");
  const sponsorSpotlight = qs("#sponsorSpotlight");
  const spotlightName = qs("#spotlightName");
  const spotlightLink = qs("#spotlightLink");

  const renderSponsorTiers = () => {
    if (!sponsorTiersEl) return;
    const tiers = Array.isArray(cfg.sponsors?.tiers) ? cfg.sponsors.tiers : [];

    const frag = document.createDocumentFragment();
    tiers.forEach((t) => {
      const item = document.createElement("button");
      item.type = "button";
      item.className = "ff-mini";
      item.setAttribute("role", "listitem");
      item.dataset.ffTier = t.id || "";
      item.dataset.prefillAmount = String(t.amount || "");
      item.dataset.tierName = safeText(t.name || "");
      item.dataset.tierId = safeText(t.id || "");

      const row = document.createElement("div");
      row.className = "ff-row ff-row--between";
      row.style.alignItems = "baseline";

      const left = document.createElement("div");
      const kicker = document.createElement("div");
      kicker.className = "ff-kicker";
      kicker.textContent = "Tier";
      const title = document.createElement("div");
      title.className = "ff-card__title";
      title.style.marginTop = "6px";
      title.textContent = safeText(t.name || "Sponsor");

      left.appendChild(kicker);
      left.appendChild(title);

      const amt = document.createElement("span");
      amt.className = "ff-pill ff-pill--accent";
      amt.textContent = money(t.amount || 0);

      row.appendChild(left);
      row.appendChild(amt);

      const perks = document.createElement("ul");
      perks.className = "ff-bul";
      perks.style.marginTop = "10px";
      (t.perks || []).slice(0, 4).forEach((p) => {
        const li = document.createElement("li");
        li.textContent = safeText(p);
        perks.appendChild(li);
      });

      const hint = document.createElement("p");
      hint.className = "ff-help";
      hint.style.marginTop = "10px";
      hint.textContent = "Tap to prefill checkout + apply recognition.";

      item.appendChild(row);
      if (perks.childNodes.length) item.appendChild(perks);
      item.appendChild(hint);

      frag.appendChild(item);
    });

    sponsorTiersEl.innerHTML = "";
    sponsorTiersEl.appendChild(frag);
  };

  const renderSponsorKitTiers = () => {
    if (!kitTierList) return;
    const tiers = Array.isArray(cfg.sponsors?.tiers) ? cfg.sponsors.tiers : [];

    const frag = document.createDocumentFragment();
    tiers.slice(0, 4).forEach((t) => {
      const row = document.createElement("div");
      row.className = "ff-mini";

      const top = document.createElement("div");
      top.className = "ff-row ff-row--between";
      top.style.alignItems = "baseline";

      const name = document.createElement("strong");
      name.className = "ff-num";
      name.textContent = safeText(t.name || "Tier");

      const amt = document.createElement("span");
      amt.className = "ff-pill";
      amt.textContent = money(t.amount || 0);

      top.appendChild(name);
      top.appendChild(amt);

      const perks = document.createElement("p");
      perks.className = "ff-help";
      perks.style.marginTop = "6px";
      perks.textContent = (t.perks || []).slice(0, 2).join(" • ") || "Recognition included.";

      row.appendChild(top);
      row.appendChild(perks);
      frag.appendChild(row);
    });

    kitTierList.innerHTML = "";
    kitTierList.appendChild(frag);
  };

  const renderSponsorLeaderboard = () => {
    if (!sponsorLeaderboardEl) return;
    const list = Array.isArray(cfg.sponsors?.leaderboard) ? cfg.sponsors.leaderboard : [];

    const sorted = list
      .slice()
      .sort((a, b) => (Number(b.amount) || 0) - (Number(a.amount) || 0))
      .slice(0, 10);

    if (!sorted.length) {
      sponsorLeaderboardEl.innerHTML = `<div class="ff-mini"><div class="ff-kicker">No sponsors yet</div><p class="ff-help">Be the first sponsor—tiers above prefill checkout.</p></div>`;
      if (sponsorSpotlight) sponsorSpotlight.hidden = true;
      return;
    }

    const top = sorted[0];
    if (sponsorSpotlight && spotlightName) {
      sponsorSpotlight.hidden = false;
      spotlightName.textContent = safeText(top.name || "Sponsor");
      if (spotlightLink) {
        const href = safeText(top.website || "").trim();
        spotlightLink.hidden = !href;
        if (href) spotlightLink.href = href;
      }
    }

    const frag = document.createDocumentFragment();
    sorted.forEach((s, i) => {
      const row = document.createElement("div");
      row.className = "ff-mini";
      row.setAttribute("role", "listitem");

      const topRow = document.createElement("div");
      topRow.className = "ff-row ff-row--between";

      const left = document.createElement("div");
      const kicker = document.createElement("div");
      kicker.className = "ff-kicker";
      kicker.textContent = `#${i + 1}`;
      const name = document.createElement("strong");
      name.className = "ff-num";
      name.textContent = safeText(s.name || "Sponsor");

      left.appendChild(kicker);
      left.appendChild(name);

      const amt = document.createElement("span");
      amt.className = "ff-pill ff-pill--accent";
      amt.textContent = money(s.amount || 0);

      topRow.appendChild(left);
      topRow.appendChild(amt);

      const link = safeText(s.website || "").trim();
      if (link) {
        const a = document.createElement("a");
        a.className = "ff-help";
        a.href = link;
        a.target = "_blank";
        a.rel = "noopener";
        a.style.display = "inline-block";
        a.style.marginTop = "6px";
        a.textContent = link.replace(/^https?:\/\//, "");
        row.appendChild(topRow);
        row.appendChild(a);
      } else {
        row.appendChild(topRow);
      }

      frag.appendChild(row);
    });

    sponsorLeaderboardEl.innerHTML = "";
    sponsorLeaderboardEl.appendChild(frag);
  };

  const renderSponsorWall = () => {
    if (!sponsorWallEl) return;
    const list = Array.isArray(cfg.sponsors?.wall) ? cfg.sponsors.wall : [];
    const items = list.slice(0, 12);

    if (!items.length) {
      sponsorWallEl.innerHTML = `<div class="ff-mini" style="grid-column:1/-1"><div class="ff-kicker">Sponsor wall</div><p class="ff-help">Sponsor logos appear here when provided at checkout.</p></div>`;
      return;
    }

    const frag = document.createDocumentFragment();
    items.forEach((s) => {
      const a = document.createElement("a");
      a.className = "ff-mini";
      a.setAttribute("role", "listitem");
      a.style.display = "grid";
      a.style.placeItems = "center";
      a.style.textDecoration = "none";
      a.href = safeText(s.website || "#");
      if (a.href === "#") a.removeAttribute("href");
      a.target = "_blank";
      a.rel = "noopener";

      const imgUrl = safeText(s.logoUrl || "").trim();
      if (imgUrl) {
        const img = document.createElement("img");
        img.loading = "lazy";
        img.decoding = "async";
        img.alt = safeText(s.name || "Sponsor");
        img.src = imgUrl;
        img.style.maxWidth = "100%";
        img.style.maxHeight = "56px";
        img.style.objectFit = "contain";
        a.appendChild(img);
      } else {
        const t = document.createElement("strong");
        t.className = "ff-num";
        t.textContent = safeText(s.name || "Sponsor");
        a.appendChild(t);
      }

      frag.appendChild(a);
    });

    sponsorWallEl.innerHTML = "";
    sponsorWallEl.appendChild(frag);
  };

  /* ---------------------------------------------
   * Donation state + bindings
   * -------------------------------------------*/
  const donationForm = qs("#donationForm");
  const amountInput = qs("#amountInput");
  const amountErr = qs("#amountErr");
  const emailInput = qs("#emailInput");
  const nameInput = qs("#nameInput");
  const noteInput = qs("#noteInput");
  const teamSelect = qs("#teamSelect");
  const teamHidden = qs("#selectedTeamId");
  const tierHidden = qs("#selectedTierId");
  const payMethodHidden = qs("#payMethodHidden");
  const freqHidden = qs("#frequencyHidden");
  const totalHidden = qs("#ffTotalHidden");
  const idemHidden = qs("#ffIdemHidden");

  const donateFreqSeg = qs("#donateFreqSeg");
  const paypalChip = qs("#paypalChip");
  const payChips = qsa("[data-pay-method]");

  const coverFeesCb = qs("#coverFees");
  const roundUpCb = qs("#roundUp");
  const coversNotice = qs("#coversNotice");
  const coversText = qs("#coversText");

  const formError = qs("#formError");
  const recognitionNotice = qs("#recognitionNotice");
  const sponsorUpsell = qs("#sponsorUpsell");
  const sponsorFieldsWrap = qs("#sponsorFieldsWrap");
  const tierNotice = qs("#tierNotice");
  const tierName = qs("#tierName");

  const summaryAmount = qs("#summaryAmount");
  const summaryFreq = qs("#summaryFreq");
  const summaryTeam = qs("#summaryTeam");
  const summaryTotal = qs("#summaryTotal");

  const stripePaymentWrap = qs("#stripePaymentWrap");
  const paypalPaymentWrap = qs("#paypalPaymentWrap");
  const paypalBtnMount = qs("#paypalBtn");

  const matchNotice = qs("#matchNotice");
  const matchCountdown = qs("#matchCountdown");
  const matchPills = {
    topbar: qs("#matchPill"),
    hero: qs("#heroMatchPill"),
    donate: qs("#donateMatchPill"),
    summary: qs("#summaryMatchPill"),
    kit: qs("#kitMatchPill")
  };

  const state = {
    amount: 0,
    frequency: "once", // once|monthly
    payMethod: "stripe", // stripe|paypal
    coverFees: false,
    roundUp: false,
    teamId: "all",
    tierId: "",
    tierName: "",
    prefill: false,
    matchActive: !!cfg.match?.active,
    matchEndsISO: safeText(cfg.match?.endsISO || "")
  };

  const setFormError = (msg) => {
    if (!formError) return;
    if (!msg) {
      formError.hidden = true;
      formError.textContent = "";
      return;
    }
    formError.hidden = false;
    formError.textContent = String(msg);
  };

  const feeGrossUp = (baseAmount) => {
    // Calculate donor-paid total such that net ~= baseAmount after fees
    // total = (base + flat) / (1 - pct)
    const pctFee = Number(cfg.fees?.pct) || 0;
    const flat = Number(cfg.fees?.flat) || 0;
    const base = Number(baseAmount) || 0;
    if (base <= 0) return { total: 0, fee: 0 };
    const total = (base + flat) / (1 - pctFee);
    const rounded = Math.round(total * 100) / 100;
    const fee = Math.max(0, Math.round((rounded - base) * 100) / 100);
    return { total: rounded, fee };
  };

  const computeTotal = () => {
    let amt = Number(state.amount) || 0;

    // round up
    let roundUpAdd = 0;
    if (state.roundUp) roundUpAdd = roundUpToNext(amt, 5);

    const base = Math.round((amt + roundUpAdd) * 100) / 100;

    // cover fees
    let total = base;
    let fee = 0;
    if (state.coverFees && cfg.fees?.enabled !== false) {
      const g = feeGrossUp(base);
      total = g.total;
      fee = g.fee;
    }

    return { base, roundUpAdd, fee, total: Math.round(total * 100) / 100 };
  };

  const updateFeeNotice = () => {
    if (!coversNotice || !coversText) return;
    const { base, roundUpAdd, fee, total } = computeTotal();

    if (!state.coverFees && !state.roundUp) {
      coversNotice.hidden = true;
      return;
    }

    const parts = [];
    if (state.roundUp && roundUpAdd > 0) parts.push(`Round up: +${money(roundUpAdd, true)}`);
    if (state.coverFees && fee > 0) parts.push(`Estimated fees covered: +${money(fee, true)}`);

    coversText.textContent = `${parts.join(" • ")} • Total today: ${money(total, true)}`;
    coversNotice.hidden = false;
  };

  const updateSummary = () => {
    const { total } = computeTotal();
    setText(summaryAmount, money(state.amount || 0, true));
    setText(summaryFreq, state.frequency === "monthly" ? "Monthly" : "One-time");
    setText(summaryTeam, teamLabel(state.teamId));
    setText(summaryTotal, money(total, true));

    if (totalHidden) totalHidden.value = String(total);
    if (freqHidden) freqHidden.value = state.frequency;
    if (teamHidden) teamHidden.value = state.teamId;
    if (tierHidden) tierHidden.value = state.tierId || "";
    if (payMethodHidden) payMethodHidden.value = state.payMethod;

    updateFeeNotice();
  };

  const teamLabel = (id) => {
    if (!id || id === "all") return "All teams";
    const t = (cfg.teams || []).find((x) => String(x.id) === String(id));
    return t ? String(t.name || id) : String(id);
  };

  const applyAmountToInput = (amt) => {
    const a = parseAmount(amt);
    state.amount = a;
    if (amountInput) amountInput.value = a > 0 ? String(a) : "";
    if (amountErr) amountErr.hidden = a > 0;
    updateSummary();
  };

  const applyTeam = (teamId) => {
    state.teamId = teamId || "all";
    if (teamSelect) teamSelect.value = state.teamId;
    updateSummary();
  };

  const applyTier = (tierId, tierNameStr, amt) => {
    state.tierId = tierId || "";
    state.tierName = tierNameStr || "";
    if (tierHidden) tierHidden.value = state.tierId;

    if (tierNotice && tierName) {
      if (state.tierId) {
        tierNotice.hidden = false;
        tierName.textContent = state.tierName || "Sponsor tier";
      } else {
        tierNotice.hidden = true;
      }
    }

    // Reveal sponsor details when tier selected
    if (sponsorFieldsWrap) sponsorFieldsWrap.hidden = !state.tierId;
    if (recognitionNotice) recognitionNotice.hidden = !state.tierId;
    if (sponsorUpsell) sponsorUpsell.hidden = !!state.tierId;

    if (amt) applyAmountToInput(amt);
    updateSummary();
  };

  const setPrefillPills = (onPill = true) => {
    if (impactPrefillPill) impactPrefillPill.hidden = !onPill;
    if (donatePrefillPill) donatePrefillPill.hidden = !onPill;
  };

  const setFrequency = (freq) => {
    state.frequency = freq === "monthly" ? "monthly" : "once";
    if (donateFreqSeg) {
      qsa("button[data-freq]", donateFreqSeg).forEach((b) => {
        const is = b.getAttribute("data-freq") === state.frequency;
        b.setAttribute("aria-pressed", String(is));
      });
    }
    updateSummary();
  };

  const setPayMethod = async (method) => {
    state.payMethod = method === "paypal" ? "paypal" : "stripe";
    payChips.forEach((b) => b.setAttribute("aria-pressed", String(b.getAttribute("data-pay-method") === state.payMethod)));

    // Toggle UI
    if (stripePaymentWrap) stripePaymentWrap.hidden = true; // optional inline (kept hidden by default)
    if (paypalPaymentWrap) paypalPaymentWrap.hidden = state.payMethod !== "paypal";

    updateSummary();

    if (state.payMethod === "paypal") {
      // Load PayPal SDK on demand (only if meta has client id)
      const ok = await (window.ffLoadPayPal ? window.ffLoadPayPal() : Promise.resolve(false));
      if (!ok) {
        toast("PayPal is not enabled for this campaign.", { title: "Payment" });
        // revert to stripe
        state.payMethod = "stripe";
        payChips.forEach((b) => b.setAttribute("aria-pressed", String(b.getAttribute("data-pay-method") === state.payMethod)));
        if (paypalPaymentWrap) paypalPaymentWrap.hidden = true;
        updateSummary();
        return;
      }

      // If you have PayPal endpoints, wire them here.
      // For now: show a friendly notice if no server integration exists.
      if (paypalBtnMount && window.paypal && !paypalBtnMount.dataset.rendered) {
        paypalBtnMount.dataset.rendered = "1";
        paypalBtnMount.innerHTML = `<div class="ff-notice"><div class="ff-kicker">PayPal setup needed</div><p class="ff-help" style="margin-top:6px">Add server endpoints for createOrder/capture, then render PayPal Buttons here.</p></div>`;
      }
    }
  };

  const initDonationBindings = () => {
    // Amount input
    on(amountInput, "input", () => {
      const a = parseAmount(amountInput.value);
      state.amount = a;
      if (amountErr) amountErr.hidden = a > 0;
      setPrefillPills(false);
      updateSummary();
    });

    // Frequency
    on(donateFreqSeg, "click", (e) => {
      const btn = e.target.closest("button[data-freq]");
      if (!btn) return;
      setFrequency(btn.getAttribute("data-freq"));
    });

    // Team select
    on(teamSelect, "change", () => {
      applyTeam(teamSelect.value || "all");
      setPrefillPills(true);
    });

    // Cover fees / round up
    on(coverFeesCb, "change", () => {
      state.coverFees = !!coverFeesCb.checked;
      updateSummary();
    });
    on(roundUpCb, "change", () => {
      state.roundUp = !!roundUpCb.checked;
      updateSummary();
    });

    // Pay method chip toggles
    on(document, "click", (e) => {
      const btn = e.target.closest("[data-pay-method]");
      if (!btn) return;
      e.preventDefault();
      setPayMethod(btn.getAttribute("data-pay-method"));
    });

    // Quick amount chips (hero/progress/sticky)
    on(document, "click", (e) => {
      const btn = e.target.closest("[data-quick-amount]");
      if (!btn) return;
      e.preventDefault();
      const amt = parseAmount(btn.getAttribute("data-quick-amount"));
      if (!amt) return;
      applyAmountToInput(amt);
      setPrefillPills(true);

      // visually toggle aria-pressed on chips within same group
      const group = btn.closest("[role='group']") || btn.parentElement;
      if (group) {
        qsa("[data-quick-amount]", group).forEach((b) => b.setAttribute("aria-pressed", String(b === btn)));
      }
    });

    // Impact prefill (buttons created by renderImpact)
    on(document, "click", (e) => {
      const card = e.target.closest("[data-ff-impact]");
      if (!card) return;
      e.preventDefault();
      const amt = parseAmount(card.dataset.prefillAmount);
      const note = safeText(card.dataset.prefillNote || "").trim();
      if (amt) applyAmountToInput(amt);
      if (noteInput && note) noteInput.value = note;
      setPrefillPills(true);
      toast("Prefilled from Impact.", { title: "Impact" });
      // Optional: scroll to donate on mobile
      // document.getElementById("donate")?.scrollIntoView({ behavior: "smooth" });
    });

    // Team-tag links/buttons (including dynamically rendered team cards)
    on(document, "click", (e) => {
      const el = e.target.closest("[data-ff-team-tag]");
      if (!el) return;

      // Many are anchors to #donate; let navigation happen, but apply tag first
      const tag = el.getAttribute("data-ff-team-tag") || "all";
      applyTeam(tag);
      setPrefillPills(true);
    });

    // Sponsor tier selects
    on(document, "click", (e) => {
      const el = e.target.closest("[data-ff-tier]");
      if (!el) return;
      e.preventDefault();
      const tierId = el.dataset.tierId || el.dataset.ffTier || "";
      const name = el.dataset.tierName || "Sponsor tier";
      const amt = parseAmount(el.dataset.prefillAmount);
      applyTier(tierId, name, amt);
      setPrefillPills(true);
      toast(`Selected ${name}.`, { title: "Sponsors" });
    });

    // Default: show sponsor upsell if no tier
    if (sponsorUpsell) sponsorUpsell.hidden = false;

    // Initialize hidden values
    if (idemHidden) idemHidden.value = uid();
    updateSummary();
  };

  /* ---------------------------------------------
   * Match UI (optional)
   * -------------------------------------------*/
  let matchTimer = null;

  const setMatchUi = (active) => {
    Object.values(matchPills).forEach((el) => el && (el.hidden = !active));
    if (matchNotice) matchNotice.hidden = !active;

    // Sticky match pill
    const stickyMatch = qs("#stickyMatch");
    if (stickyMatch) stickyMatch.hidden = !active;

    // topbar countdown pill
    const countdownPill = qs("#countdownPill");
    if (countdownPill) countdownPill.hidden = !active;
  };

  const tickMatchCountdown = () => {
    if (!state.matchActive || !state.matchEndsISO) return;
    const ends = new Date(state.matchEndsISO);
    if (Number.isNaN(ends.getTime())) return;

    const ms = ends.getTime() - Date.now();
    if (ms <= 0) {
      state.matchActive = false;
      setMatchUi(false);
      if (matchTimer) clearInterval(matchTimer);
      toast("Match window ended.", { title: "Match" });
      return;
    }

    const mins = Math.floor(ms / (1000 * 60));
    const hrs = Math.floor(mins / 60);
    const remM = mins % 60;

    const label = hrs > 0 ? `${hrs}h ${remM}m left` : `${remM}m left`;
    if (matchCountdown) matchCountdown.textContent = label;

    const countdownPill = qs("#countdownPill");
    if (countdownPill) countdownPill.hidden = false;
  };

  const initMatch = () => {
    setMatchUi(!!state.matchActive);
    if (state.matchActive && state.matchEndsISO) {
      tickMatchCountdown();
      matchTimer = setInterval(tickMatchCountdown, 30_000);
    }
  };

  /* ---------------------------------------------
   * Stripe Checkout Modal (PaymentElement)
   * -------------------------------------------*/
  const stripePk = meta("ff-stripe-pk");
  const checkoutEndpoint = meta("ff-checkout-endpoint") || "/payments/stripe/intent";
  const csrfToken = meta("csrf-token");

  const modalPaymentMount = qs("#modalPaymentElement");
  const checkoutLoading = qs("#checkoutLoading");
  const checkoutProcessing = qs("#checkoutProcessing");
  const checkoutModalError = qs("#checkoutModalError");
  const payNowBtn = qs("#payNowBtn");

  let stripe = null;
  let elements = null;
  let clientSecret = "";
  let stripeInitInFlight = false;

  const showCheckoutError = (msg) => {
    if (!checkoutModalError) return;
    if (!msg) {
      checkoutModalError.hidden = true;
      checkoutModalError.textContent = "";
      return;
    }
    checkoutModalError.hidden = false;
    checkoutModalError.textContent = String(msg);
  };

  const validateBeforeCheckout = () => {
    setFormError("");

    const amt = parseAmount(amountInput ? amountInput.value : state.amount);
    state.amount = amt;

    if (!amt) {
      if (amountErr) amountErr.hidden = false;
      setFormError("Enter a valid amount to continue.");
      return false;
    }

    const email = (emailInput && emailInput.value) || "";
    if (!isEmail(email)) {
      setFormError("Enter a valid email for your receipt.");
      emailInput && emailInput.focus();
      return false;
    }

    return true;
  };

  const buildCheckoutPayload = () => {
    const { base, roundUpAdd, fee, total } = computeTotal();
    const email = (emailInput && emailInput.value || "").trim();
    const name = (nameInput && nameInput.value || "").trim();
    const note = (noteInput && noteInput.value || "").trim();

    const payload = {
      // Core
      amount: Number(state.amount) || 0,
      total: Number(total) || 0,
      currency: cfg.fundraiser?.currency || "USD",
      frequency: state.frequency, // "once"|"monthly"
      pay_method: state.payMethod, // "stripe"|"paypal"
      idem_key: (idemHidden && idemHidden.value) || uid(),

      // Context
      org_id: orgId,
      campaign_id: campaignId,
      page,
      team_id: state.teamId || "all",
      tier_id: state.tierId || "",

      // Donor
      email,
      name,
      note,

      // Options
      cover_fees: !!state.coverFees,
      round_up: !!state.roundUp,
      round_up_add: Number(roundUpAdd) || 0,
      fee_estimate: Number(fee) || 0,
      base: Number(base) || 0,

      // Sponsor fields (optional)
      sponsor: {
        company: (qs("#companyInput")?.value || "").trim(),
        website: (qs("#websiteInput")?.value || "").trim(),
        logo_url: (qs("#logoUrlInput")?.value || "").trim(),
        public: !!qs("#sponsorPublic")?.checked,
        preferred: !!qs("#sponsorPreferred")?.checked
      },

      // Extras
      donor_anonymous: !!qs("#donorAnonymous")?.checked,
      updates_opt_in: !!qs("#updatesOptIn")?.checked,
      ref_code: (qs("#refCodeInput")?.value || "").trim(),

      // Match
      match_active: !!state.matchActive
    };

    return payload;
  };

  const postJSON = async (url, body) => {
    const headers = { "Content-Type": "application/json" };
    if (csrfToken) headers["X-CSRF-Token"] = csrfToken;

    const res = await fetch(url, {
      method: "POST",
      credentials: "same-origin",
      headers,
      body: JSON.stringify(body)
    });

    let data = null;
    try {
      data = await res.json();
    } catch (_) {}

    if (!res.ok) {
      const msg = (data && (data.error || data.message)) || `Request failed (${res.status})`;
      throw new Error(msg);
    }
    return data || {};
  };

  const ensureStripe = async () => {
    if (stripe) return stripe;
    if (!stripePk) throw new Error("Stripe is not configured (missing ff-stripe-pk).");
    if (!window.Stripe) throw new Error("Stripe.js is not available.");

    stripe = window.Stripe(stripePk);
    return stripe;
  };

  const mountPaymentElement = async () => {
    if (!modalPaymentMount) return;

    const theme = getTheme();
    const appearance = {
      theme: theme === "light" ? "stripe" : "night",
      labels: "floating"
    };

    elements = stripe.elements({ clientSecret, appearance });

    // Clear skeleton
    modalPaymentMount.innerHTML = "";

    const pe = elements.create("payment");
    pe.mount(modalPaymentMount);

    pe.on("ready", () => {
      if (payNowBtn) {
        payNowBtn.disabled = false;
        payNowBtn.setAttribute("aria-disabled", "false");
      }
    });
  };

  const openCheckout = async () => {
    if (stripeInitInFlight) return;
    stripeInitInFlight = true;

    try {
      showCheckoutError("");
      if (payNowBtn) {
        payNowBtn.disabled = true;
        payNowBtn.setAttribute("aria-disabled", "true");
      }
      if (checkoutProcessing) checkoutProcessing.hidden = true;

      if (!validateBeforeCheckout()) {
        stripeInitInFlight = false;
        return;
      }

      openModal("checkout");

      if (checkoutLoading) checkoutLoading.hidden = false;

      await ensureStripe();

      // Always rotate idempotency key per new modal open
      if (idemHidden) idemHidden.value = uid();

      const payload = buildCheckoutPayload();
      const resp = await postJSON(checkoutEndpoint, payload);

      // Expected response shape:
      // { client_secret: "...", public_message?: "...", donor?:{...}, donation?:{...} }
      // (You can include anything else; front-end ignores unknown fields.)
      clientSecret = String(resp.client_secret || "");

      if (!clientSecret) throw new Error("Checkout could not start (missing client_secret).");

      await mountPaymentElement();

      if (checkoutLoading) checkoutLoading.hidden = true;

      // Store some donor info for success screen
      window.FF.lastCheckout = { payload, resp };
    } catch (err) {
      showCheckoutError(err?.message || "Checkout failed to initialize.");
      if (checkoutLoading) checkoutLoading.hidden = true;
      toast(err?.message || "Checkout failed.", { title: "Checkout" });
    } finally {
      stripeInitInFlight = false;
    }
  };

  const confirmPayment = async () => {
    try {
      showCheckoutError("");
      if (!stripe || !elements) throw new Error("Payment form is not ready.");
      if (!validateBeforeCheckout()) return;

      if (checkoutProcessing) checkoutProcessing.hidden = false;
      if (payNowBtn) {
        payNowBtn.disabled = true;
        payNowBtn.setAttribute("aria-disabled", "true");
      }

      const result = await stripe.confirmPayment({
        elements,
        confirmParams: {
          // If your server needs a return URL, set it here
          return_url: window.location.href
        },
        redirect: "if_required"
      });

      if (result.error) {
        throw new Error(result.error.message || "Payment failed.");
      }

      // Success: show success modal and fill details
      closeModal("checkout");
      fillSuccessModal();
      openModal("success");

      // Optional: refresh UI stats (if you have live totals endpoint, call it here)
      toast("Donation successful.", { title: "Success" });

      // Reset idempotency for next time
      if (idemHidden) idemHidden.value = uid();
    } catch (err) {
      showCheckoutError(err?.message || "Payment could not be confirmed.");
      if (checkoutProcessing) checkoutProcessing.hidden = true;
      if (payNowBtn) {
        payNowBtn.disabled = false;
        payNowBtn.setAttribute("aria-disabled", "false");
      }
    }
  };

  const fillSuccessModal = () => {
    const email = (emailInput && emailInput.value) || "—";
    const { total } = computeTotal();

    setText(qs("#successEmail"), email);
    setText(qs("#successAmount"), money(total, true));
    setText(qs("#successFrequency"), state.frequency === "monthly" ? "Monthly" : "One-time");
    setText(qs("#successTeam"), teamLabel(state.teamId));

    // Caption
    const link = getBaseShareLink();
    const org = cfg.org?.name || "our program";
    const cap = `I just donated to ${org}. Help us hit our goal—donate here: ${link}`;
    if (successCaptionTa) successCaptionTa.value = cap;

    // Optional sponsor CTA
    const sponsorCta = qs("#successSponsorCta");
    if (sponsorCta) sponsorCta.hidden = false;
  };

  const initCheckout = () => {
    // Open checkout buttons
    qsa("[data-ff-open-checkout]").forEach((b) => on(b, "click", (e) => (e.preventDefault(), openCheckout())));

    // Pay now button
    on(payNowBtn, "click", (e) => (e.preventDefault(), confirmPayment()));

    // Reset element when closing modal
    on(modalEls.checkout, "click", (e) => {
      const backdrop = e.target.closest(".ff-modal__backdrop");
      if (!backdrop) return;
      // allow close handler elsewhere to run, but cleanup after
      setTimeout(() => {
        elements = null;
        clientSecret = "";
        if (modalPaymentMount) {
          // restore skeleton
          modalPaymentMount.innerHTML = `<div class="ff-skel" aria-hidden="true" style="height: 56px"></div>`;
        }
        if (payNowBtn) {
          payNowBtn.disabled = true;
          payNowBtn.setAttribute("aria-disabled", "true");
        }
        if (checkoutProcessing) checkoutProcessing.hidden = true;
        showCheckoutError("");
      }, 0);
    });
  };

  /* ---------------------------------------------
   * Donate CTA anchors (minor polish)
   * -------------------------------------------*/
  const initAnchors = () => {
    // Smooth scroll for in-page anchor links
    on(document, "click", (e) => {
      const a = e.target.closest('a[href^="#"]');
      if (!a) return;
      const href = a.getAttribute("href");
      if (!href || href === "#") return;

      const id = href.slice(1);
      const target = qs(`#${CSS.escape(id)}`);
      if (!target) return;

      // Let browser handle if user is using modifiers
      if (e.metaKey || e.ctrlKey || e.shiftKey || e.altKey) return;

      e.preventDefault();
      target.scrollIntoView({ behavior: "smooth", block: "start" });
    });
  };

  /* ---------------------------------------------
   * Boot
   * -------------------------------------------*/
  const boot = () => {
    applyPremiumVisibility();
    setTheme(getTheme());

    bindOrg();
    bindProgress();

    initAnnouncement();
    initTopbar();
    initDrawer();
    initModals();
    initShare();
    initScrollUi();
    initSectionSpy();
    initAnchors();

    renderImpact();
    renderAllocation();

    renderSponsorTiers();
    renderSponsorLeaderboard();
    renderSponsorWall();

    initDonationBindings();
    initMatch();
    initCheckout();

    // Theme toggle
    on(themeToggleBtn, "click", () => setTheme(getTheme() === "dark" ? "light" : "dark"));

    // When inline bootstrap renders teams (it emits ff:teams-rendered), keep summary consistent
    on(window, "ff:teams-rendered", () => {
      bindProgress();
      updateSummary();
    });

    // Initial fee notice / summary
    updateSummary();
  };

  // If config-ready is emitted by the inline script, boot immediately anyway (cfg already merged above)
  if (document.readyState === "loading") {
    on(document, "DOMContentLoaded", boot);
  } else {
    boot();
  }
})(); to include /* =========================================================
   FutureFunded • Premium Microinteractions v8
   - Tactile buttons + haptics
   - Toast feedback
   - Count-up numbers + smooth meters
   - Scroll spy + scroll progress bar
   - Section reveal animations
   - Modal motion + focus helper (non-invasive)
   - Tiny confetti on success (optional)
========================================================= */
(() => {
  const DOC = document;
  const $ = (s, r = DOC) => r.querySelector(s);
  const $$ = (s, r = DOC) => Array.from(r.querySelectorAll(s));

  const prefersReducedMotion = (() => {
    try { return window.matchMedia?.("(prefers-reduced-motion: reduce)")?.matches === true; }
    catch { return false; }
  })();

  const canVibrate = !!navigator.vibrate;
  const vibrate = (ms = 10) => { if (!prefersReducedMotion && canVibrate) navigator.vibrate(ms); };

  const toastRegion = $("#toastRegion");
  function toast(message, opts = {}) {
    const { variant = "info", timeout = 2400 } = opts;
    if (!toastRegion) return;

    const el = DOC.createElement("div");
    el.className = "ff-toast__item";
    el.setAttribute("role", variant === "error" ? "alert" : "status");
    el.setAttribute("aria-live", variant === "error" ? "assertive" : "polite");
    el.style.cssText = [
      "display:flex",
      "align-items:center",
      "gap:10px",
      "padding:10px 12px",
      "border-radius:14px",
      "border:1px solid var(--ff-b)",
      "background:rgba(17,24,39,.88)",
      "backdrop-filter: blur(10px)",
      "box-shadow: var(--ff-shadow2)",
      "margin-top:10px",
      "max-width:min(520px, calc(100vw - 24px))",
      "transform: translateY(8px)",
      "opacity:0"
    ].join(";");

    const dot = DOC.createElement("span");
    dot.setAttribute("aria-hidden", "true");
    dot.style.cssText = [
      "width:10px",
      "height:10px",
      "border-radius:999px",
      variant === "error" ? "background: rgba(239,68,68,.95)" :
      variant === "success" ? "background: rgba(34,197,94,.95)" :
      "background: rgba(249,115,22,.95)",
      "box-shadow: 0 0 0 4px rgba(249,115,22,.12)"
    ].join(";");

    const text = DOC.createElement("div");
    text.textContent = message;
    text.style.cssText = "font-weight:600; letter-spacing:.1px;";

    el.append(dot, text);
    toastRegion.appendChild(el);

    if (!prefersReducedMotion && el.animate) {
      el.animate(
        [{ opacity: 0, transform: "translateY(8px)" }, { opacity: 1, transform: "translateY(0)" }],
        { duration: 180, easing: "cubic-bezier(.2,.8,.2,1)", fill: "forwards" }
      );
    } else {
      el.style.opacity = "1";
      el.style.transform = "translateY(0)";
    }

    window.setTimeout(() => {
      if (!el.isConnected) return;
      const remove = () => el.remove();
      if (!prefersReducedMotion && el.animate) {
        const a = el.animate(
          [{ opacity: 1, transform: "translateY(0)" }, { opacity: 0, transform: "translateY(8px)" }],
          { duration: 180, easing: "cubic-bezier(.2,.8,.2,1)", fill: "forwards" }
        );
        a.onfinish = remove;
      } else remove();
    }, timeout);
  }

  // -------------------------------------------------------
  // 1) Tactile press interactions (buttons/chips/icons/tabs)
  // -------------------------------------------------------
  const PRESS_SEL = [
    ".ff-btn",
    ".ff-chip",
    ".ff-icon",
    ".ff-tab",
    ".ff-drawer__link"
  ].join(",");

  function isDisabled(el) {
    return el?.matches?.(":disabled,[aria-disabled='true']") || false;
  }

  function pressAnim(el) {
    if (!el || isDisabled(el)) return;
    if (prefersReducedMotion || !el.animate) {
      el.style.transform = "scale(.985)";
      return;
    }
    el.animate(
      [{ transform: "scale(1)" }, { transform: "scale(.985)" }],
      { duration: 90, easing: "cubic-bezier(.2,.8,.2,1)", fill: "forwards" }
    );
  }

  function releaseAnim(el) {
    if (!el || isDisabled(el)) return;
    if (prefersReducedMotion || !el.animate) {
      el.style.transform = "";
      return;
    }
    el.animate(
      [{ transform: getComputedStyle(el).transform || "scale(.985)" }, { transform: "scale(1)" }],
      { duration: 140, easing: "cubic-bezier(.2,.8,.2,1)", fill: "forwards" }
    );
  }

  DOC.addEventListener("pointerdown", (e) => {
    const el = e.target.closest(PRESS_SEL);
    if (!el) return;
    pressAnim(el);
  }, { passive: true });

  DOC.addEventListener("pointerup", (e) => {
    const el = e.target.closest(PRESS_SEL);
    if (!el) return;
    releaseAnim(el);
  }, { passive: true });

  DOC.addEventListener("pointercancel", (e) => {
    const el = e.target.closest(PRESS_SEL);
    if (!el) return;
    releaseAnim(el);
  }, { passive: true });

  // -------------------------------------------------------
  // 2) Smooth meter transitions (any ff-meter / sticky bar)
  // -------------------------------------------------------
  function primeMeterTransitions() {
    $$(".ff-meter span, #overallBar, #stickyBar, #scrollProgressBar").forEach((bar) => {
      bar.style.transition = prefersReducedMotion ? "none" : "width 700ms cubic-bezier(.2,.8,.2,1)";
      bar.style.willChange = "width";
    });
  }
  primeMeterTransitions();

  // -------------------------------------------------------
  // 3) Count-up animations on number text changes
  // -------------------------------------------------------
  const nfUSD0 = new Intl.NumberFormat("en-US", { style: "currency", currency: "USD", maximumFractionDigits: 0 });

  function parseNumberFromText(txt) {
    const s = String(txt || "");
    const cleaned = s.replace(/[^0-9.\-]/g, "");
    const n = Number(cleaned);
    return Number.isFinite(n) ? n : null;
  }

  function animateCount(el, to, fmt) {
    if (!el) return;
    const from = Number(el.dataset.ffAnimVal ?? "0");
    el.dataset.ffAnimVal = String(to);

    if (prefersReducedMotion) {
      el.textContent = fmt ? fmt(to) : String(to);
      return;
    }

    const start = performance.now();
    const dur = 650;
    const easeOut = (t) => 1 - Math.pow(1 - t, 3);

    function tick(now) {
      const p = Math.min(1, (now - start) / dur);
      const v = from + (to - from) * easeOut(p);
      el.textContent = fmt ? fmt(v) : String(Math.round(v));
      if (p < 1) requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);
  }

  const watchNumberIds = [
    "raisedBig","raisedRow","goalRow","pctText","goalPill",
    "stickyRaised","stickyGoal","stickyPct",
    "donorsText","avgGiftText",
    "summaryAmount","summaryTotal",
    "successAmount"
  ]
    .map((id) => `#${id}`)
    .join(",");

  function installNumberObserver() {
    const targets = $$(watchNumberIds).filter(Boolean);
    if (!targets.length) return;

    const obs = new MutationObserver((muts) => {
      for (const m of muts) {
        const el = m.target;
        const txt = el.textContent;
        const n = parseNumberFromText(txt);
        if (n == null) continue;

        // Currency-like IDs
        const looksMoney =
          /raised|goal|avg|amount|total|successAmount|stickyRaised|stickyGoal|summary/i.test(el.id);

        if (looksMoney) animateCount(el, n, (v) => nfUSD0.format(v));
        else animateCount(el, n, (v) => String(Math.round(v)));
      }
    });

    targets.forEach((el) => obs.observe(el, { characterData: true, subtree: true, childList: true }));
  }
  installNumberObserver();

  // -------------------------------------------------------
  // 4) Scroll progress bar + back-to-top reveal
  // -------------------------------------------------------
  const scrollBar = $("#scrollProgressBar");
  const backToTop = $("#backToTop");
  function onScroll() {
    const de = DOC.documentElement;
    const max = Math.max(1, de.scrollHeight - de.clientHeight);
    const pct = Math.min(1, Math.max(0, de.scrollTop / max));
    if (scrollBar) scrollBar.style.width = `${Math.round(pct * 100)}%`;

    if (backToTop) backToTop.hidden = de.scrollTop < 900;
  }
  window.addEventListener("scroll", () => requestAnimationFrame(onScroll), { passive: true });
  onScroll();

  if (backToTop) {
    backToTop.addEventListener("click", () => {
      vibrate(12);
      window.scrollTo({ top: 0, behavior: prefersReducedMotion ? "auto" : "smooth" });
    });
  }

  // -------------------------------------------------------
  // 5) Scroll spy (highlights nav links)
  // -------------------------------------------------------
  function installScrollSpy() {
    const navLinks = $$("[data-spy]");
    if (!navLinks.length || !("IntersectionObserver" in window)) return;

    const sections = navLinks
      .map((a) => DOC.getElementById(a.getAttribute("data-spy")))
      .filter(Boolean);

    const setActive = (id) => {
      navLinks.forEach((a) => {
        const on = a.getAttribute("data-spy") === id;
        a.style.opacity = on ? "1" : ".72";
        a.style.transform = on ? "translateY(-1px)" : "translateY(0)";
      });
    };

    const io = new IntersectionObserver((entries) => {
      const visible = entries
        .filter((e) => e.isIntersecting)
        .sort((a, b) => b.intersectionRatio - a.intersectionRatio)[0];
      if (visible?.target?.id) setActive(visible.target.id);
    }, { root: null, threshold: [0.12, 0.22, 0.35] });

    sections.forEach((s) => io.observe(s));
  }
  installScrollSpy();

  // -------------------------------------------------------
  // 6) Section reveal animations (cards fade/slide in)
  // -------------------------------------------------------
  function installReveal() {
    if (prefersReducedMotion || !("IntersectionObserver" in window)) return;
    const els = $$(".ff-card, .ff-mini, .ff-notice").slice(0, 220);

    const io = new IntersectionObserver((entries) => {
      entries.forEach((e) => {
        if (!e.isIntersecting) return;
        const el = e.target;
        if (el.dataset.ffRevealed) return;
        el.dataset.ffRevealed = "1";

        if (el.animate) {
          el.animate(
            [{ opacity: 0, transform: "translateY(10px)" }, { opacity: 1, transform: "translateY(0)" }],
            { duration: 420, easing: "cubic-bezier(.2,.8,.2,1)", fill: "forwards" }
          );
        }
        io.unobserve(el);
      });
    }, { threshold: 0.12 });

    els.forEach((el) => io.observe(el));
  }
  installReveal();

  // -------------------------------------------------------
  // 7) Copy link + “Copied” microfeedback (and share params)
  // -------------------------------------------------------
  function buildShareUrl(fromEl) {
    const u = new URL(window.location.href);
    // Normalize to canonical (no hash)
    u.hash = "";

    const teamTag = fromEl?.getAttribute?.("data-ff-team-tag");
    if (teamTag && teamTag !== "all") u.searchParams.set("team", teamTag);

    const amt = fromEl?.getAttribute?.("data-quick-amount");
    if (amt) u.searchParams.set("amount", amt);

    return u.toString();
  }

  async function copyText(text) {
    try {
      await navigator.clipboard.writeText(text);
      return true;
    } catch {
      // Fallback
      const ta = DOC.createElement("textarea");
      ta.value = text;
      ta.setAttribute("readonly", "");
      ta.style.position = "fixed";
      ta.style.top = "-9999px";
      DOC.body.appendChild(ta);
      ta.select();
      const ok = DOC.execCommand("copy");
      ta.remove();
      return ok;
    }
  }

  DOC.addEventListener("click", async (e) => {
    const btn = e.target.closest("[data-ff-copy-link]");
    if (!btn) return;

    const url = buildShareUrl(btn);
    const ok = await copyText(url);

    vibrate(10);
    if (ok) toast("Link copied.", { variant: "success" });
    else toast("Could not copy link.", { variant: "error" });

    // Optional: quick label swap
    const prev = btn.textContent;
    if (!prefersReducedMotion) btn.textContent = "Copied";
    window.setTimeout(() => { btn.textContent = prev; }, 900);

    // Keep share fields synced if modal is open
    const shareLink = $("#shareLink");
    const kitLink = $("#kitLink");
    if (shareLink) shareLink.value = url;
    if (kitLink) kitLink.value = url;
  });

  // -------------------------------------------------------
  // 8) “Prefill” confirmations (amount/team/tier)
  // -------------------------------------------------------
  function flashPrefill(pillId, msg) {
    const pill = pillId ? $(`#${pillId}`) : null;
    if (pill) {
      pill.hidden = false;
      if (!prefersReducedMotion && pill.animate) {
        pill.animate(
          [{ transform: "scale(.98)", opacity: 0.7 }, { transform: "scale(1)", opacity: 1 }],
          { duration: 220, easing: "cubic-bezier(.2,.8,.2,1)", fill: "forwards" }
        );
      }
      window.setTimeout(() => { pill.hidden = true; }, 1400);
    }
    if (msg) toast(msg, { variant: "success", timeout: 1800 });
  }

  // Example: quick amounts should feel premium even if another module handles actual logic.
  DOC.addEventListener("click", (e) => {
    const q = e.target.closest("[data-quick-amount]");
    if (!q) return;
    vibrate(8);
    flashPrefill("donatePrefillPill", "Amount prefilled.");
  });

  DOC.addEventListener("change", (e) => {
    if (e.target?.id === "teamSelect") {
      vibrate(8);
      flashPrefill("donatePrefillPill", "Team tag selected.");
    }
  });

  // -------------------------------------------------------
  // 9) Modal open animation (non-invasive)
  // -------------------------------------------------------
  function animateModalOpen(modal) {
    if (!modal || prefersReducedMotion) return;
    const panel = modal.querySelector("[data-ff-modal-panel]");
    if (!panel || !panel.animate) return;

    panel.animate(
      [{ opacity: 0, transform: "translateY(14px) scale(.985)" }, { opacity: 1, transform: "translateY(0) scale(1)" }],
      { duration: 220, easing: "cubic-bezier(.2,.8,.2,1)", fill: "forwards" }
    );
  }

  function observeModals() {
    const modals = $$(".ff-modal[data-ff-modal]");
    if (!modals.length) return;

    const obs = new MutationObserver((muts) => {
      for (const m of muts) {
        if (m.type !== "attributes" || m.attributeName !== "hidden") continue;
        const modal = m.target;
        if (!modal.hidden) {
          animateModalOpen(modal);
          // Focus inside for premium feel (but don’t trap)
          const panel = modal.querySelector("[data-ff-modal-panel]");
          window.setTimeout(() => panel?.focus?.(), 0);
        }
      }
    });

    modals.forEach((modal) => obs.observe(modal, { attributes: true }));
  }
  observeModals();

  // -------------------------------------------------------
  // 10) Confetti burst on success modal open (optional)
  // -------------------------------------------------------
  function confettiBurst(container) {
    if (prefersReducedMotion || !container) return;

    const canvas = DOC.createElement("canvas");
    canvas.width = container.clientWidth;
    canvas.height = 140;
    canvas.style.cssText = "width:100%; height:140px; display:block; margin-top:8px;";
    container.prepend(canvas);

    const ctx = canvas.getContext("2d");
    const colors = ["#f97316", "#22c55e", "#60a5fa", "#eab308", "#a78bfa"];
    const parts = Array.from({ length: 80 }).map(() => ({
      x: canvas.width * 0.5,
      y: 40,
      vx: (Math.random() - 0.5) * 6.2,
      vy: Math.random() * -6.4 - 2.6,
      g: 0.18 + Math.random() * 0.12,
      s: 2 + Math.random() * 3,
      r: Math.random() * Math.PI,
      vr: (Math.random() - 0.5) * 0.2,
      c: colors[(Math.random() * colors.length) | 0],
      life: 90 + ((Math.random() * 30) | 0)
    }));

    let t = 0;
    function frame() {
      t++;
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      parts.forEach((p) => {
        p.vy += p.g;
        p.x += p.vx;
        p.y += p.vy;
        p.r += p.vr;
        p.life -= 1;

        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(p.r);
        ctx.fillStyle = p.c;
        ctx.fillRect(-p.s, -p.s, p.s * 2, p.s * 2);
        ctx.restore();
      });

      // Remove “dead” particles
      for (let i = parts.length - 1; i >= 0; i--) {
        if (parts[i].life <= 0 || parts[i].y > canvas.height + 20) parts.splice(i, 1);
      }

      if (t < 120 && parts.length) requestAnimationFrame(frame);
      else canvas.remove();
    }
    requestAnimationFrame(frame);
  }

  const successModal = $("#successModal");
  if (successModal) {
    const obs = new MutationObserver(() => {
      if (!successModal.hidden) {
        const panel = successModal.querySelector("[data-ff-modal-panel]");
        confettiBurst(panel);
      }
    });
    obs.observe(successModal, { attributes: true, attributeFilter: ["hidden"] });
  }

  // -------------------------------------------------------
  // Bonus: if your teams bootstrap fires events, stagger cards
  // -------------------------------------------------------
  window.addEventListener("ff:teams-rendered", (ev) => {
    if (prefersReducedMotion) return;
    const cards = $$("[data-team-card]").slice(0, 24);
    cards.forEach((card, i) => {
      if (!card.animate) return;
      card.animate(
        [{ opacity: 0, transform: "translateY(10px)" }, { opacity: 1, transform: "translateY(0)" }],
        { duration: 360, delay: i * 22, easing: "cubic-bezier(.2,.8,.2,1)", fill: "forwards" }
      );
    });
  });
})(); and function initRipples(){
  const targets = document.querySelectorAll(".ff-btn, .ff-chip");
  targets.forEach((el) => el.classList.add("ff-ripple"));

  document.addEventListener("pointerdown", (e) => {
    const btn = e.target.closest(".ff-btn, .ff-chip");
    if (!btn) return;
    if (window.matchMedia && window.matchMedia("(prefers-reduced-motion: reduce)").matches) return;

    const r = btn.getBoundingClientRect();
    const ink = document.createElement("span");
    ink.className = "ff-ripple__ink";
    ink.style.left = `${e.clientX - r.left}px`;
    ink.style.top  = `${e.clientY - r.top}px`;

    btn.appendChild(ink);
    ink.addEventListener("animationend", () => ink.remove(), { once:true });
  }, { passive:true });
}
  function animateNumber(el, from, to, ms, formatFn){
  if (!el) return;
  const start = performance.now();
  const dur = Math.max(220, ms || 520);
  const f = typeof formatFn === "function" ? formatFn : (n) => String(Math.round(n));

  const tick = (t) => {
    const p = Math.min(1, (t - start) / dur);
    const eased = 1 - Math.pow(1 - p, 3); // easeOutCubic
    const v = from + (to - from) * eased;
    el.textContent = f(v);
    if (p < 1) requestAnimationFrame(tick);
  };
  requestAnimationFrame(tick);
}

/* Call this after you compute totals/progress */
function premiumAnimateKPIs({ raised, donors, avgGift, pct }){
  animateNumber(document.getElementById("raisedBig"), 0, raised, 680, (n)=>money(n));
  animateNumber(document.getElementById("raisedRow"), 0, raised, 680, (n)=>money(n));
  animateNumber(document.getElementById("donorsText"), 0, donors, 520, (n)=>String(Math.round(n)));
  animateNumber(document.getElementById("avgGiftText"), 0, avgGift, 520, (n)=>money(n));
  animateNumber(document.getElementById("pctText"), 0, pct, 520, (n)=>String(Math.round(n)));
} premiumAnimateKPIs({ raised, donors, avgGift, pct }); const __ffMilestonesHit = new Set();

function pingMilestone(pct){
  const m = [25,50,75,100].find(x => Math.round(pct) >= x && !__ffMilestonesHit.has(x));
  if (!m) return;

  __ffMilestonesHit.add(m);
  const meter = document.querySelector('[data-ff-meter="overall"]');
  if (!meter) return;
  meter.classList.add("is-ping");
  setTimeout(()=>meter.classList.remove("is-ping"), 560);

  toast(`Milestone hit: ${m}% funded. Share to keep momentum.`);
} pingMilestone(pct);
 
 function flashPill(id){
  const el = document.getElementById(id);
  if (!el) return;
  el.hidden = false;
  el.classList.remove("is-flash");
  // force reflow
  void el.offsetWidth;
  el.classList.add("is-flash");
}flashPill("donatePrefillPill");
flashPill("impactPrefillPill"); async function copyText(text){
  try {
    await navigator.clipboard.writeText(String(text || ""));
    return true;
  } catch {
    // fallback
    const ta = document.createElement("textarea");
    ta.value = String(text || "");
    ta.style.position = "fixed";
    ta.style.left = "-9999px";
    document.body.appendChild(ta);
    ta.select();
    try { document.execCommand("copy"); } catch {}
    ta.remove();
    return true;
  }
}

function markCopied(btn){
  if (!btn) return;
  const old = btn.textContent;
  btn.textContent = "Copied ✓";
  btn.disabled = true;
  setTimeout(() => {
    btn.textContent = old;
    btn.disabled = false;
  }, 1200);
} function initCopyUX(getShareUrl){
  document.addEventListener("click", async (e) => {
    const btn = e.target.closest("[data-ff-copy-link]");
    if (!btn) return;
    e.preventDefault();
    const url = typeof getShareUrl === "function" ? getShareUrl() : location.href;
    await copyText(url);
    markCopied(btn);
    toast("Link copied.");
  });
}function initReveal(){
  const els = document.querySelectorAll(".ff-section, .ff-card, .ff-mini");
  els.forEach(el => el.classList.add("ff-reveal"));

  if (!("IntersectionObserver" in window)) {
    els.forEach(el => el.classList.add("is-inview"));
    return;
  }

  const io = new IntersectionObserver((entries) => {
    entries.forEach((en) => {
      if (en.isIntersecting) en.target.classList.add("is-inview");
    });
  }, { threshold: 0.12 });

  els.forEach(el => io.observe(el));
}

 function initScrollProgress(){
  const bar = document.getElementById("scrollProgressBar");
  if (!bar) return;

  let raf = 0;
  const tick = () => {
    raf = 0;
    const doc = document.documentElement;
    const max = (doc.scrollHeight - doc.clientHeight) || 1;
    const pct = clamp((window.scrollY / max) * 100, 0, 100);
    bar.style.width = `${pct}%`;
  };

  const onScroll = () => {
    if (raf) return;
    raf = requestAnimationFrame(tick);
  };

  tick();
  window.addEventListener("scroll", onScroll, { passive:true });
  window.addEventListener("resize", onScroll);
}
 function initStickySmart(){
  const sticky = document.getElementById("stickyDonate");
  const donate = document.getElementById("donate");
  if (!sticky || !donate) return;

  let donateInView = false;

  if ("IntersectionObserver" in window) {
    const io = new IntersectionObserver((entries) => {
      donateInView = entries.some(en => en.isIntersecting);
      if (donateInView) sticky.hidden = true;
    }, { threshold: 0.25 });
    io.observe(donate);
  }

  const showAfter = 420; // px scrolled
  window.addEventListener("scroll", () => {
    if (donateInView) return;
    sticky.hidden = window.scrollY < showAfter;
  }, { passive:true });
}

 function confettiBurst(){
  if (window.matchMedia && window.matchMedia("(prefers-reduced-motion: reduce)").matches) return;

  const host = document.getElementById("toastRegion") || document.body;
  const n = 18;
  for (let i=0;i<n;i++){
    const p = document.createElement("i");
    p.style.position = "fixed";
    p.style.left = `${Math.random()*100}vw`;
    p.style.top  = `-10px`;
    p.style.width = "8px";
    p.style.height = "12px";
    p.style.borderRadius = "3px";
    p.style.background = "rgba(249,115,22,.9)"; // uses your accent vibe
    p.style.zIndex = 9999;
    p.style.opacity = "0.95";
    p.style.transform = `rotate(${Math.random()*60-30}deg)`;
    p.style.pointerEvents = "none";

    const dx = (Math.random()*2-1) * 14;
    const dy = 90 + Math.random()*140;
    const dur = 760 + Math.random()*520;

    host.appendChild(p);

    const start = performance.now();
    const anim = (t) => {
      const k = Math.min(1, (t-start)/dur);
      const y = k*dy;
      const x = k*dx;
      p.style.transform = `translate(${x}px, ${y}px) rotate(${(k*240)}deg)`;
      p.style.opacity = String(0.95 * (1-k));
      if (k < 1) requestAnimationFrame(anim);
      else p.remove();
    };
    requestAnimationFrame(anim);
  }
}function toast(msg, type){
  const region = document.getElementById("toastRegion");
  if (!region) return;
  const t = document.createElement("div");
  t.className = "ff-toast__item";
  t.setAttribute("role","status");
  t.textContent = String(msg || "");
  region.appendChild(t);
  setTimeout(()=> t.classList.add("is-in"), 10);
  setTimeout(()=> {
    t.classList.remove("is-in");
    setTimeout(()=>t.remove(), 240);
  }, type === "error" ? 2600 : 1800);
}function initPremiumMicrointeractions(getShareUrl){
  initRipples();
  initReveal();
  initScrollProgress();
  initStickySmart();
  initCopyUX(getShareUrl);
}initPremiumMicrointeractions(() => location.href.split("#")[0]);




