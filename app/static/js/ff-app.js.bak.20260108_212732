/* ============================================================================
  FutureFunded • Flagship v8 — ff-app.js (from scratch)
  - Works with the provided index.html (keeps IDs + data-ff hooks)
  - No dependencies (except Stripe.js which is already loaded)
  - Graceful: if elements/config are missing, it no-ops safely
============================================================================ */
(() => {
  "use strict";

  /* ---------------------------------------------
   * Helpers
   * -------------------------------------------*/
  const qs = (sel, root = document) => root.querySelector(sel);
  const qsa = (sel, root = document) => Array.from(root.querySelectorAll(sel));
  const on = (el, evt, fn, opts) => el && el.addEventListener(evt, fn, opts);
  const clamp = (n, a, b) => Math.max(a, Math.min(b, n));
  const safeText = (v) => (v === null || v === undefined ? "" : String(v));
  const isEmail = (s) => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(String(s || "").trim());
  const nowISO = () => new Date().toISOString();

  const fmtUSD0 = new Intl.NumberFormat("en-US", {
    style: "currency",
    currency: "USD",
    maximumFractionDigits: 0
  });
  const fmtUSD2 = new Intl.NumberFormat("en-US", {
    style: "currency",
    currency: "USD",
    maximumFractionDigits: 2
  });

  const parseAmount = (raw) => {
    // Accept: "75", "$75", "75.00", "1,000"
    const s = String(raw || "")
      .replace(/[^\d.]/g, "")
      .trim();
    if (!s) return 0;
    const n = Number(s);
    if (!Number.isFinite(n) || n <= 0) return 0;
    // cents ok, but keep sane
    return Math.round(n * 100) / 100;
  };

  const roundUpToNext = (amt, step) => {
    const a = Number(amt) || 0;
    const s = Number(step) || 5;
    if (a <= 0) return 0;
    const next = Math.ceil(a / s) * s;
    return Math.round((next - a) * 100) / 100;
  };

  const pct = (raised, goal) => {
    const r = Number(raised) || 0;
    const g = Number(goal) || 0;
    if (g <= 0) return 0;
    return clamp(Math.round((r / g) * 100), 0, 100);
  };

  const computeDaysLeft = (deadlineISO) => {
    if (!deadlineISO) return null;
    const d = new Date(deadlineISO);
    if (Number.isNaN(d.getTime())) return null;
    const ms = d.getTime() - Date.now();
    return Math.max(0, Math.ceil(ms / (1000 * 60 * 60 * 24)));
  };

  const computeDeadlineLabel = (deadlineISO) => {
    if (!deadlineISO) return "—";
    const d = new Date(deadlineISO);
    if (Number.isNaN(d.getTime())) return "—";
    // "Feb 28, 2026"
    const f = new Intl.DateTimeFormat("en-US", { month: "short", day: "2-digit", year: "numeric" });
    return f.format(d);
  };

  const money = (n, preferCents = false) => {
    const v = Number(n) || 0;
    if (preferCents && v % 1 !== 0) return fmtUSD2.format(v);
    return fmtUSD0.format(v);
  };

  const uid = () => {
    try {
      if (crypto && crypto.randomUUID) return crypto.randomUUID();
    } catch (_) {}
    return `ff_${Math.random().toString(16).slice(2)}_${Date.now()}`;
  };

  const meta = (name) => {
    const el = qs(`meta[name="${name}"]`);
    return el ? (el.content || "").trim() : "";
  };

  const setHidden = (el, h) => el && (el.hidden = !!h);
  const setText = (el, t) => el && (el.textContent = safeText(t));
  const setAttr = (el, k, v) => el && el.setAttribute(k, safeText(v));
  const delAttr = (el, k) => el && el.removeAttribute(k);

  const toastRegion = qs("#toastRegion");
  const toast = (msg, opts = {}) => {
    if (!toastRegion) return;
    const id = uid();
    const div = document.createElement("div");
    div.className = "ff-toast__item";
    div.setAttribute("role", "status");
    div.setAttribute("aria-live", "polite");
    div.dataset.toastId = id;

    const strong = document.createElement("strong");
    strong.textContent = opts.title ? String(opts.title) : "Notice";
    const p = document.createElement("p");
    p.className = "ff-help";
    p.style.margin = "6px 0 0";
    p.textContent = String(msg || "");

    const btn = document.createElement("button");
    btn.className = "ff-icon";
    btn.type = "button";
    btn.setAttribute("aria-label", "Dismiss notification");
    btn.innerHTML = "<span aria-hidden='true'>✕</span>";
    btn.addEventListener("click", () => div.remove());

    const row = document.createElement("div");
    row.className = "ff-row ff-row--between";
    row.style.alignItems = "flex-start";
    row.style.gap = "10px";

    const left = document.createElement("div");
    left.appendChild(strong);
    left.appendChild(p);

    row.appendChild(left);
    row.appendChild(btn);

    div.appendChild(row);
    toastRegion.appendChild(div);

    const ttl = Number(opts.ttlMs ?? 3600);
    if (ttl > 0) setTimeout(() => div.remove(), ttl);
  };

  const copyText = async (text) => {
    const val = String(text || "");
    try {
      if (navigator.clipboard && navigator.clipboard.writeText) {
        await navigator.clipboard.writeText(val);
        return true;
      }
    } catch (_) {}
    // fallback
    try {
      const ta = document.createElement("textarea");
      ta.value = val;
      ta.style.position = "fixed";
      ta.style.top = "-9999px";
      ta.style.left = "-9999px";
      document.body.appendChild(ta);
      ta.focus();
      ta.select();
      const ok = document.execCommand("copy");
      ta.remove();
      return !!ok;
    } catch (_) {
      return false;
    }
  };

  /* ---------------------------------------------
   * Config
   * -------------------------------------------*/
  const shell = qs("[data-ff-shell]");
  const tier = (shell && shell.getAttribute("data-ff-tier")) || "standard";
  const orgId = (shell && shell.getAttribute("data-ff-org")) || "default";
  const campaignId = (shell && shell.getAttribute("data-ff-campaign")) || "season";
  const page = (shell && shell.getAttribute("data-ff-page")) || "fundraiser";

  const DEFAULTS = {
    org: {
      name: "FutureFunded",
      meta: "Youth program",
      seasonPill: "Season Fund",
      sportPill: "Youth program",
      heroAccentLine: "Keep kids playing.",
      footerTagline: "Fuel the season. Fund the future.",
      logo: ""
    },
    fundraiser: {
      goalAmount: 25000,
      deadlineISO: "",
      currency: "USD",
      announcement: "" // if non-empty, shows announcement bar
    },
    impact: {
      cards: [
        { id: "gym", title: "Gym time", desc: "Cover practice space for the week.", amount: 75, note: "Helping with gym time." },
        { id: "travel", title: "Travel", desc: "Gas, vans, and tournament weekends.", amount: 150, note: "Helping with travel." },
        { id: "gear", title: "Gear", desc: "Shoes, uniforms, and safe equipment.", amount: 250, note: "Helping with gear." },
        { id: "scholarship", title: "Scholarship", desc: "Support families who need help.", amount: 500, note: "Helping with scholarships." }
      ]
    },
    allocation: [
      { label: "Travel + tournaments", pct: 45 },
      { label: "Gym time + training", pct: 35 },
      { label: "Gear + uniforms", pct: 20 }
    ],
    sponsors: {
      tiers: [
        { id: "bronze", name: "Bronze", amount: 250, perks: ["Name on sponsor wall", "Thank-you post"] },
        { id: "silver", name: "Silver", amount: 500, perks: ["Logo on sponsor wall", "Thank-you post"] },
        { id: "gold", name: "Gold", amount: 1000, perks: ["Logo + link", "Leaderboard placement", "Thank-you post"] }
      ],
      leaderboard: [], // [{name, amount, website, logoUrl}]
      wall: [] // [{name, website, logoUrl}]
    },
    match: {
      active: false,
      endsISO: "" // optional
    },
    fees: {
      // Default Stripe-ish blended estimate (you should override from server if you want exact)
      pct: 0.029,
      flat: 0.3,
      enabled: true
    },
    share: {
      caption: "" // if blank, we generate from org name/goal
    }
  };

  const cfg = (() => {
    const c = window.__FF_CONFIG || {};
    // shallow-ish merge with defaults (good enough for front-end config)
    const merged = {
      ...DEFAULTS,
      ...c,
      org: { ...DEFAULTS.org, ...(c.org || {}) },
      fundraiser: { ...DEFAULTS.fundraiser, ...(c.fundraiser || {}) },
      impact: { ...DEFAULTS.impact, ...(c.impact || {}) },
      sponsors: {
        ...DEFAULTS.sponsors,
        ...(c.sponsors || {}),
        tiers: Array.isArray((c.sponsors || {}).tiers) ? c.sponsors.tiers : DEFAULTS.sponsors.tiers,
        leaderboard: Array.isArray((c.sponsors || {}).leaderboard) ? c.sponsors.leaderboard : DEFAULTS.sponsors.leaderboard,
        wall: Array.isArray((c.sponsors || {}).wall) ? c.sponsors.wall : DEFAULTS.sponsors.wall
      },
      match: { ...DEFAULTS.match, ...(c.match || {}) },
      fees: { ...DEFAULTS.fees, ...(c.fees || {}) },
      allocation: Array.isArray(c.allocation) ? c.allocation : DEFAULTS.allocation,
      teams: Array.isArray(c.teams) ? c.teams : []
    };
    return merged;
  })();

  // Expose a stable read-only config handle (useful for debugging/integrations)
  window.FF = window.FF || {};
  window.FF.config = cfg;

  /* ---------------------------------------------
   * Premium-only toggles (data-ff-premium-only)
   * -------------------------------------------*/
  const applyPremiumVisibility = () => {
    const premium = tier === "premium";
    qsa("[data-ff-premium-only]").forEach((el) => {
      // Keep "hidden" attributes for placeholders unless premium.
      // If premium: only unhide if element isn't explicitly hidden by author for other reasons.
      if (!premium) el.hidden = true;
    });
  };

  /* ---------------------------------------------
   * Theme
   * -------------------------------------------*/
  const THEME_KEY = "ff_theme_v8";
  const themeToggleBtn = qs("[data-ff-theme-toggle]");

  const getTheme = () => {
    const t = (localStorage.getItem(THEME_KEY) || "").trim();
    if (t === "dark" || t === "light") return t;
    const t2 = (localStorage.getItem("ff_theme") || "").trim();
    if (t2 === "dark" || t2 === "light") return t2;
    return document.documentElement.getAttribute("data-theme") || "dark";
  };

  const setTheme = (t) => {
    const theme = t === "light" ? "light" : "dark";
    document.documentElement.setAttribute("data-theme", theme);
    try {
      localStorage.setItem(THEME_KEY, theme);
    } catch (_) {}
    if (themeToggleBtn) {
      themeToggleBtn.setAttribute("aria-pressed", String(theme === "light"));
      themeToggleBtn.textContent = theme === "light" ? "☀" : "☾";
    }
  };

  /* ---------------------------------------------
   * Announcement bar
   * -------------------------------------------*/
  const ann = qs("[data-ff-announcement]");
  const annText = qs("#announcementText");
  const annDismiss = qs("[data-ff-announcement-dismiss]");
  const ANN_KEY = `ff_ann_dismissed_v8:${orgId}:${campaignId}`;

  const initAnnouncement = () => {
    const text = safeText(cfg.fundraiser.announcement || "").trim();
    if (!ann || !annText) return;

    let dismissed = false;
    try {
      dismissed = localStorage.getItem(ANN_KEY) === "1";
    } catch (_) {}

    if (!text || dismissed) {
      ann.hidden = true;
      return;
    }

    annText.textContent = text;
    ann.hidden = false;

    on(annDismiss, "click", () => {
      ann.hidden = true;
      try {
        localStorage.setItem(ANN_KEY, "1");
      } catch (_) {}
    });
  };

  /* ---------------------------------------------
   * Topbar dismiss
   * -------------------------------------------*/
  const topbar = qs("[data-ff-topbar]");
  const topbarDismiss = qs("[data-ff-topbar-dismiss]");
  const TOPBAR_KEY = `ff_topbar_dismissed_v8:${orgId}:${campaignId}`;

  const initTopbar = () => {
    if (!topbar) return;
    let dismissed = false;
    try {
      dismissed = localStorage.getItem(TOPBAR_KEY) === "1";
    } catch (_) {}
    if (dismissed) topbar.style.display = "none";
    on(topbarDismiss, "click", () => {
      topbar.style.display = "none";
      try {
        localStorage.setItem(TOPBAR_KEY, "1");
      } catch (_) {}
    });
  };

  /* ---------------------------------------------
   * Drawer (mobile)
   * -------------------------------------------*/
  const drawer = qs("[data-ff-drawer]");
  const drawerPanel = qs("[data-ff-drawer-panel]");
  const drawerOpenBtn = qs("[data-ff-drawer-open]");
  const drawerCloseBtns = qsa("[data-ff-drawer-close]");

  const focusableSel =
    'a[href], button:not([disabled]), textarea, input, select, details summary, [tabindex]:not([tabindex="-1"])';

  const trapFocus = (container, e) => {
    const items = qsa(focusableSel, container).filter((el) => !el.hidden && el.offsetParent !== null);
    if (!items.length) return;
    const first = items[0];
    const last = items[items.length - 1];
    if (e.key === "Tab" && e.shiftKey && document.activeElement === first) {
      e.preventDefault();
      last.focus();
    } else if (e.key === "Tab" && !e.shiftKey && document.activeElement === last) {
      e.preventDefault();
      first.focus();
    }
  };

  let lastFocus = null;

  const openDrawer = () => {
    if (!drawer) return;
    lastFocus = document.activeElement;
    drawer.hidden = false;
    drawer.setAttribute("aria-hidden", "false");
    if (drawerOpenBtn) drawerOpenBtn.setAttribute("aria-expanded", "true");
    document.body.style.overflow = "hidden";
    setTimeout(() => drawerPanel && drawerPanel.focus(), 0);
  };

  const closeDrawer = () => {
    if (!drawer) return;
    drawer.hidden = true;
    drawer.setAttribute("aria-hidden", "true");
    if (drawerOpenBtn) drawerOpenBtn.setAttribute("aria-expanded", "false");
    document.body.style.overflow = "";
    if (lastFocus && lastFocus.focus) lastFocus.focus();
  };

  const initDrawer = () => {
    on(drawerOpenBtn, "click", openDrawer);
    drawerCloseBtns.forEach((b) => on(b, "click", closeDrawer));
    on(document, "keydown", (e) => {
      if (!drawer || drawer.hidden) return;
      if (e.key === "Escape") closeDrawer();
      if (e.key === "Tab") trapFocus(drawer, e);
    });
  };

  /* ---------------------------------------------
   * Modals (share, sponsor kit, checkout, success)
   * -------------------------------------------*/
  const modalEls = {
    share: qs('#shareModal[data-ff-modal="share"]'),
    sponsorKit: qs('#sponsorKitModal[data-ff-modal="sponsorKit"]'),
    checkout: qs('#checkoutModal[data-ff-modal="checkout"]'),
    success: qs('#successModal[data-ff-modal="success"]')
  };
  const modalCloseBtns = qsa("[data-ff-modal-close]");

  const openModal = (name) => {
    const m = modalEls[name];
    if (!m) return;
    lastFocus = document.activeElement;
    m.hidden = false;
    m.setAttribute("aria-hidden", "false");
    document.body.style.overflow = "hidden";
    const panel = qs("[data-ff-modal-panel]", m);
    setTimeout(() => panel && panel.focus(), 0);
  };

  const closeModal = (name) => {
    const m = modalEls[name];
    if (!m) return;
    m.hidden = true;
    m.setAttribute("aria-hidden", "true");
    document.body.style.overflow = "";
    if (lastFocus && lastFocus.focus) lastFocus.focus();
  };

  const closeAllModals = () => {
    Object.keys(modalEls).forEach(closeModal);
  };

  const initModals = () => {
    modalCloseBtns.forEach((b) =>
      on(b, "click", () => {
        // close nearest modal
        const m = b.closest(".ff-modal");
        if (!m) return;
        const name = m.getAttribute("data-ff-modal");
        if (name) closeModal(name);
      })
    );

    on(document, "keydown", (e) => {
      if (e.key !== "Escape") return;
      // Close whichever modal is open (topmost)
      const open = Object.entries(modalEls).find(([, el]) => el && !el.hidden);
      if (open) closeModal(open[0]);
    });

    // Focus trap for any open modal
    on(document, "keydown", (e) => {
      if (e.key !== "Tab") return;
      const open = Object.values(modalEls).find((el) => el && !el.hidden);
      if (!open) return;
      trapFocus(open, e);
    });
  };

  /* ---------------------------------------------
   * Share system
   * -------------------------------------------*/
  const shareOpenBtns = qsa("[data-ff-share-open]");
  const copyLinkBtns = qsa("[data-ff-copy-link]");
  const nativeShareBtns = qsa("[data-ff-native-share]");

  const shareLinkInput = qs("#shareLink");
  const shareCaptionTa = qs("#shareCaption");
  const shareQrImg = qs("#shareQr");
  const successCaptionTa = qs("#successCaption");
  const successCopyCaptionBtn = qs("[data-ff-success-copy-caption]");
  const copyCaptionBtn = qs("[data-ff-copy-caption]");

  const kitLinkInput = qs("#kitLink");
  const kitCaptionTa = qs("#kitCaption");
  const kitTierList = qs("#kitTierList");
  const copyKitCaptionBtn = qs("[data-ff-copy-kit-caption]");

  const getBaseShareLink = () => {
    // Keep URL clean, preserve campaign/page
    try {
      const u = new URL(window.location.href);
      // Keep any embed/whitelabel params if you want; otherwise drop them here
      u.hash = "";
      return u.toString();
    } catch (_) {
      return window.location.href.split("#")[0];
    }
  };

  const buildShareCaption = () => {
    const org = cfg.org?.name || "our program";
    const goal = money(cfg.fundraiser?.goalAmount || 0);
    return (
      (cfg.share && cfg.share.caption) ||
      `Support ${org}—we’re raising ${goal} for the season. Any amount helps. Donate here:`
    );
  };

  const qrEndpoint = meta("ff-qr-endpoint") || "https://api.qrserver.com/v1/create-qr-code/";

  const buildQrUrl = (data) => {
    const base = qrEndpoint.endsWith("/") ? qrEndpoint : `${qrEndpoint}`;
    const size = "220x220";
    const margin = "10";
    const u = new URL(base);
    u.searchParams.set("size", size);
    u.searchParams.set("margin", margin);
    u.searchParams.set("data", data);
    return u.toString();
  };

  const openShareModal = async (opts = {}) => {
    const link = opts.link || getBaseShareLink();
    const caption = `${buildShareCaption()} ${link}`;

    if (shareLinkInput) shareLinkInput.value = link;
    if (shareCaptionTa) shareCaptionTa.value = caption;
    if (shareQrImg) shareQrImg.src = buildQrUrl(link);

    openModal("share");
  };

  const initShare = () => {
    // Delegated clicks for future dynamic nodes
    on(document, "click", async (e) => {
      const shareBtn = e.target.closest("[data-ff-share-open]");
      if (shareBtn) {
        e.preventDefault();
        await openShareModal();
        return;
      }

      const copyBtn = e.target.closest("[data-ff-copy-link]");
      if (copyBtn) {
        e.preventDefault();
        const link = getBaseShareLink();
        const ok = await copyText(link);
        toast(ok ? "Link copied." : "Could not copy link.", { title: "Share" });
        return;
      }

      const capBtn = e.target.closest("[data-ff-copy-caption]");
      if (capBtn) {
        e.preventDefault();
        const link = getBaseShareLink();
        const caption = `${buildShareCaption()} ${link}`;
        const ok = await copyText(caption);
        toast(ok ? "Caption copied." : "Could not copy caption.", { title: "Share" });
        return;
      }

      const kitCapBtn = e.target.closest("[data-ff-copy-kit-caption]");
      if (kitCapBtn) {
        e.preventDefault();
        const text = kitCaptionTa ? kitCaptionTa.value : "";
        const ok = await copyText(text);
        toast(ok ? "Sponsor caption copied." : "Could not copy sponsor caption.", { title: "Sponsor kit" });
        return;
      }

      const successCapBtn = e.target.closest("[data-ff-success-copy-caption]");
      if (successCapBtn) {
        e.preventDefault();
        const text = successCaptionTa ? successCaptionTa.value : "";
        const ok = await copyText(text);
        toast(ok ? "Caption copied." : "Could not copy caption.", { title: "Share kit" });
        return;
      }

      const nativeBtn = e.target.closest("[data-ff-native-share]");
      if (nativeBtn) {
        e.preventDefault();
        const link = getBaseShareLink();
        const caption = `${buildShareCaption()} ${link}`;
        if (navigator.share) {
          try {
            await navigator.share({ text: caption, url: link, title: cfg.org?.name || "Fundraiser" });
          } catch (_) {}
        } else {
          const ok = await copyText(caption);
          toast(ok ? "Copied caption (native share not available)." : "Could not share.", { title: "Share" });
        }
        return;
      }
    });

    // Sponsor kit open
    on(document, "click", (e) => {
      const btn = e.target.closest("[data-ff-sponsor-kit-open]");
      if (!btn) return;
      e.preventDefault();
      const link = getBaseShareLink();
      if (kitLinkInput) kitLinkInput.value = link;

      // Render tiers in kit
      renderSponsorKitTiers();

      // Build sponsor-focused caption
      const org = cfg.org?.name || "our program";
      const tiers = (cfg.sponsors?.tiers || []).slice(0, 4);
      const tierLine = tiers.map((t) => `${t.name}: ${money(t.amount)}`).join(" • ");
      const cap =
        `Hi! Would you consider sponsoring ${org}? Your support helps fund travel, gym time, and gear.\n\n` +
        `Tiers: ${tierLine}\n\n` +
        `Sponsors get recognition on the sponsor wall + leaderboard.\n\n` +
        `Link: ${link}`;
      if (kitCaptionTa) kitCaptionTa.value = cap;

      openModal("sponsorKit");
    });
  };

  /* ---------------------------------------------
   * Scroll UI: progress bar, sticky CTA, back-to-top
   * -------------------------------------------*/
  const scrollProgressBar = qs("#scrollProgressBar");
  const sticky = qs("#stickyDonate[data-ff-sticky-cta]");
  const backToTop = qs("#backToTop");

  const updateScrollUi = () => {
    const doc = document.documentElement;
    const scrollTop = doc.scrollTop || document.body.scrollTop || 0;
    const scrollHeight = doc.scrollHeight || 1;
    const clientHeight = doc.clientHeight || 1;
    const max = Math.max(1, scrollHeight - clientHeight);
    const p = clamp(scrollTop / max, 0, 1);

    if (scrollProgressBar) scrollProgressBar.style.width = `${Math.round(p * 100)}%`;

    const showSticky = scrollTop > 520;
    if (sticky) sticky.hidden = !showSticky;

    if (backToTop) backToTop.hidden = scrollTop < 600;
  };

  const initScrollUi = () => {
    on(window, "scroll", updateScrollUi, { passive: true });
    on(window, "resize", updateScrollUi);
    on(backToTop, "click", () => window.scrollTo({ top: 0, behavior: "smooth" }));
    updateScrollUi();
  };

  /* ---------------------------------------------
   * Section spy (nav highlighting)
   * -------------------------------------------*/
  const initSectionSpy = () => {
    const navLinks = qsa('[data-spy]');
    if (!navLinks.length || !("IntersectionObserver" in window)) return;

    const map = new Map(); // id -> link
    navLinks.forEach((a) => {
      const id = a.getAttribute("data-spy");
      if (id) map.set(id, a);
    });

    const sections = Array.from(map.keys())
      .map((id) => qs(`#${CSS.escape(id)}`))
      .filter(Boolean);

    const activate = (id) => {
      navLinks.forEach((a) => a.classList.toggle("is-active", a.getAttribute("data-spy") === id));
    };

    const io = new IntersectionObserver(
      (entries) => {
        const visible = entries
          .filter((e) => e.isIntersecting)
          .sort((a, b) => b.intersectionRatio - a.intersectionRatio)[0];
        if (!visible) return;
        const id = visible.target.id;
        if (id) activate(id);
      },
      { root: null, threshold: [0.12, 0.22, 0.35] }
    );

    sections.forEach((s) => io.observe(s));
  };

  /* ---------------------------------------------
   * Fundraiser progress + header/footer binding
   * -------------------------------------------*/
  const elsProgress = {
    orgPill: qs("#orgPill"),
    orgName: qs("#orgName"),
    orgMeta: qs("#orgMeta"),
    brandLogo: qs("#brandLogo"),
    heroLogo: qs("#heroLogo"),
    heroOrgLine: qs("#heroOrgLine"),
    seasonPill: qs("#seasonPill"),
    sportPill: qs("#sportPill"),
    heroAccentLine: qs("#heroAccentLine"),
    footerBrandLogo: qs("#footerBrandLogo"),
    footerOrgName: qs("#footerOrgName"),
    footerTagline: qs("#footerTagline"),
    footerYear: qs("#footerYear"),
    footerLegalName: qs("#footerLegalName"),

    // Progress card
    raisedBig: qs("#raisedBig"),
    raisedRow: qs("#raisedRow"),
    goalRow: qs("#goalRow"),
    goalPill: qs("#goalPill"),
    pctText: qs("#pctText"),
    overallBar: qs("#overallBar"),
    progressMeta: qs("#progressMeta"),
    remainingText: qs("#remainingText"),
    deadlineText: qs("#deadlineText"),
    lastUpdatedText: qs("#lastUpdatedText"),

    donorsText: qs("#donorsText"),
    avgGiftText: qs("#avgGiftText"),
    daysLeftText: qs("#daysLeftText"),
    nextMilestoneText: qs("#nextMilestoneText"),

    // Topbar update pills
    lastUpdatedInline: qs("#lastUpdatedInline"),
    lastUpdatedPill: qs("#lastUpdatedPill"),

    // Sticky donate bar
    stickyOrg: qs("#stickyOrg"),
    stickyRaised: qs("#stickyRaised"),
    stickyGoal: qs("#stickyGoal"),
    stickyPct: qs("#stickyPct"),
    stickyDays: qs("#stickyDays"),
    stickyBar: qs("#stickyBar"),

    // Footer sponsor slots (optional)
    footerSponsorSlots: qs("#footerSponsorSlots"),
    footerSponsorSlotsNum: qs("#footerSponsorSlotsNum")
  };

  const computeFundraiserTotals = () => {
    // If server supplies fundraiser.raisedAmount, use it; else sum teams raised
    const teams = Array.isArray(cfg.teams) ? cfg.teams : [];
    const sumTeams = teams.reduce((acc, t) => acc + (Number(t.raised) || 0), 0);

    const goal = Number(cfg.fundraiser?.goalAmount) || 0;
    const raised = Number(cfg.fundraiser?.raisedAmount) || sumTeams;

    // Donors/avg gift may be provided; else estimate from gifts list if present; else 0
    const donors = Number(cfg.fundraiser?.donors) || 0;
    const avgGift = Number(cfg.fundraiser?.avgGift) || (donors > 0 ? raised / donors : 0);

    return { goal, raised, donors, avgGift };
  };

  const nextMilestone = (raised, goal) => {
    if (goal <= 0) return "—";
    const milestones = [0.25, 0.5, 0.75, 1];
    const r = raised / goal;
    const next = milestones.find((m) => r < m);
    if (!next) return "Goal hit";
    const amt = Math.max(0, Math.ceil(goal * next - raised));
    const pctLabel = `${Math.round(next * 100)}%`;
    return `${pctLabel} → ${money(amt)} to go`;
  };

  const bindOrg = () => {
    const orgName = cfg.org?.name || "Organization";
    const orgMeta = cfg.org?.meta || "";
    const seasonPill = cfg.org?.seasonPill || "Season Fund";
    const sportPill = cfg.org?.sportPill || "Youth program";
    const heroAccent = cfg.org?.heroAccentLine || "Keep kids playing.";
    const footerTagline = cfg.org?.footerTagline || DEFAULTS.org.footerTagline;

    setText(elsProgress.orgPill, "Fundraiser");
    setText(elsProgress.orgName, orgName);
    setText(elsProgress.orgMeta, orgMeta);
    setText(elsProgress.heroOrgLine, `${orgName} • Fundraiser`);
    setText(elsProgress.seasonPill, seasonPill);
    setText(elsProgress.sportPill, sportPill);
    setText(elsProgress.heroAccentLine, heroAccent);

    setText(elsProgress.footerOrgName, orgName);
    setText(elsProgress.footerTagline, footerTagline);
    setText(elsProgress.footerLegalName, orgName);
    setText(elsProgress.footerYear, String(new Date().getFullYear()));

    // Logos: keep current src unless config provides one
    const logoSrc = safeText(cfg.org?.logo || "").trim();
    if (logoSrc) {
      if (elsProgress.brandLogo) elsProgress.brandLogo.src = logoSrc;
      if (elsProgress.heroLogo) elsProgress.heroLogo.src = logoSrc;
      if (elsProgress.footerBrandLogo) elsProgress.footerBrandLogo.src = logoSrc;
    } else {
      // mirror header logo into footer logo if footer empty
      if (elsProgress.footerBrandLogo && elsProgress.brandLogo && elsProgress.brandLogo.src) {
        elsProgress.footerBrandLogo.src = elsProgress.brandLogo.src;
        elsProgress.footerBrandLogo.alt = "";
      }
    }

    // Sticky
    setText(elsProgress.stickyOrg, orgName);
  };

  const bindProgress = () => {
    const { goal, raised, donors, avgGift } = computeFundraiserTotals();
    const p = pct(raised, goal);
    const remaining = Math.max(0, goal - raised);
    const deadlineISO = cfg.fundraiser?.deadlineISO || "";
    const deadlineLabel = computeDeadlineLabel(deadlineISO);
    const daysLeft = computeDaysLeft(deadlineISO);

    setText(elsProgress.raisedBig, money(raised));
    setText(elsProgress.raisedRow, money(raised));
    setText(elsProgress.goalRow, money(goal));
    setText(elsProgress.goalPill, money(goal));
    setText(elsProgress.pctText, String(p));

    if (elsProgress.overallBar) elsProgress.overallBar.style.width = `${p}%`;

    const meter = qs('[data-ff-meter="overall"]');
    if (meter) {
      setAttr(meter, "aria-valuenow", String(p));
      setAttr(meter, "aria-valuetext", `${p}% funded`);
    }

    setText(elsProgress.remainingText, money(remaining));
    setText(elsProgress.deadlineText, deadlineLabel);
    setText(elsProgress.donorsText, String(donors || 0));
    setText(elsProgress.avgGiftText, avgGift ? money(avgGift, true) : money(0));
    setText(elsProgress.daysLeftText, daysLeft === null ? "—" : String(daysLeft));
    setText(elsProgress.nextMilestoneText, nextMilestone(raised, goal));

    // Updated pills
    const updated = new Date();
    const updatedLabel = new Intl.DateTimeFormat("en-US", { month: "short", day: "2-digit", hour: "numeric", minute: "2-digit" }).format(
      updated
    );
    setText(elsProgress.lastUpdatedInline, updatedLabel);
    setText(elsProgress.lastUpdatedText, `Updated — ${updatedLabel}`);

    // Sticky bar
    setText(elsProgress.stickyRaised, money(raised));
    setText(elsProgress.stickyGoal, money(goal));
    setText(elsProgress.stickyPct, `${p}%`);
    setText(elsProgress.stickyDays, daysLeft === null ? "—" : `${daysLeft} days left`);
    if (elsProgress.stickyBar) elsProgress.stickyBar.style.width = `${p}%`;

    const stickyProg = qs(".ff-sticky__bar[role='progressbar']");
    if (stickyProg) {
      setAttr(stickyProg, "aria-valuenow", String(p));
      setAttr(stickyProg, "aria-valuetext", `${p}% funded`);
    }
  };

  /* ---------------------------------------------
   * Impact cards + Allocation rendering
   * -------------------------------------------*/
  const impactGrid = qs("#impactGrid");
  const allocationList = qs("#allocationList");
  const impactPrefillPill = qs("#impactPrefillPill");
  const donatePrefillPill = qs("#donatePrefillPill");

  const renderImpact = () => {
    if (!impactGrid) return;
    const cards = Array.isArray(cfg.impact?.cards) ? cfg.impact.cards : [];
    const frag = document.createDocumentFragment();

    const mk = (c) => {
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "ff-card ff-card--lift ff-pad";
      btn.style.textAlign = "left";
      btn.dataset.ffImpact = c.id || "";
      btn.dataset.prefillAmount = String(c.amount || "");
      btn.dataset.prefillNote = safeText(c.note || "");
      btn.setAttribute("aria-label", `${c.title || "Impact"}: ${money(c.amount || 0)}`);

      const k = document.createElement("div");
      k.className = "ff-kicker";
      k.textContent = "Impact";

      const title = document.createElement("div");
      title.className = "ff-card__title";
      title.style.marginTop = "6px";
      title.textContent = safeText(c.title || "Impact");

      const desc = document.createElement("p");
      desc.className = "ff-help";
      desc.style.marginTop = "6px";
      desc.textContent = safeText(c.desc || "");

      const row = document.createElement("div");
      row.className = "ff-row ff-row--between";
      row.style.marginTop = "10px";

      const amt = document.createElement("strong");
      amt.className = "ff-num";
      amt.textContent = money(c.amount || 0);

      const pill = document.createElement("span");
      pill.className = "ff-pill";
      pill.textContent = "Prefill";

      row.appendChild(amt);
      row.appendChild(pill);

      btn.appendChild(k);
      btn.appendChild(title);
      btn.appendChild(desc);
      btn.appendChild(row);

      return btn;
    };

    if (!cards.length) {
      impactGrid.innerHTML = "";
      return;
    }

    cards.forEach((c) => frag.appendChild(mk(c)));
    impactGrid.innerHTML = "";
    impactGrid.appendChild(frag);
  };

  const renderAllocation = () => {
    if (!allocationList) return;
    const list = Array.isArray(cfg.allocation) ? cfg.allocation : [];

    const total = list.reduce((acc, it) => acc + (Number(it.pct) || 0), 0);
    // If not 100, normalize quietly
    const norm = total > 0 ? (x) => Math.round((x / total) * 100) : (x) => x;

    const frag = document.createDocumentFragment();
    list.forEach((it) => {
      const pctVal = Number(it.pct) || 0;
      const pctShow = total === 100 ? pctVal : norm(pctVal);

      const wrap = document.createElement("div");
      wrap.className = "ff-mini";

      const row = document.createElement("div");
      row.className = "ff-row ff-row--between";
      row.style.alignItems = "baseline";

      const label = document.createElement("strong");
      label.className = "ff-num";
      label.textContent = safeText(it.label || "Allocation");

      const pctEl = document.createElement("span");
      pctEl.className = "ff-pill";
      pctEl.textContent = `${pctShow}%`;

      row.appendChild(label);
      row.appendChild(pctEl);

      const meter = document.createElement("div");
      meter.className = "ff-meter";
      meter.style.marginTop = "10px";
      meter.setAttribute("role", "progressbar");
      meter.setAttribute("aria-valuemin", "0");
      meter.setAttribute("aria-valuemax", "100");
      meter.setAttribute("aria-valuenow", String(clamp(pctShow, 0, 100)));
      meter.setAttribute("aria-valuetext", `${pctShow}%`);

      const ticks = document.createElement("div");
      ticks.className = "ff-meter__ticks";
      ticks.setAttribute("aria-hidden", "true");
      ticks.innerHTML = '<i style="left:25%"></i><i style="left:50%"></i><i style="left:75%"></i><i style="left:100%"></i>';

      const bar = document.createElement("span");
      bar.style.width = `${clamp(pctShow, 0, 100)}%`;

      meter.appendChild(ticks);
      meter.appendChild(bar);

      wrap.appendChild(row);
      wrap.appendChild(meter);

      frag.appendChild(wrap);
    });

    allocationList.innerHTML = "";
    allocationList.appendChild(frag);
  };

  /* ---------------------------------------------
   * Sponsors: tiers + leaderboard + wall
   * -------------------------------------------*/
  const sponsorTiersEl = qs("#sponsorTiers");
  const sponsorLeaderboardEl = qs("#sponsorLeaderboard");
  const sponsorWallEl = qs("#sponsorWall");
  const sponsorSpotlight = qs("#sponsorSpotlight");
  const spotlightName = qs("#spotlightName");
  const spotlightLink = qs("#spotlightLink");

  const renderSponsorTiers = () => {
    if (!sponsorTiersEl) return;
    const tiers = Array.isArray(cfg.sponsors?.tiers) ? cfg.sponsors.tiers : [];

    const frag = document.createDocumentFragment();
    tiers.forEach((t) => {
      const item = document.createElement("button");
      item.type = "button";
      item.className = "ff-mini";
      item.setAttribute("role", "listitem");
      item.dataset.ffTier = t.id || "";
      item.dataset.prefillAmount = String(t.amount || "");
      item.dataset.tierName = safeText(t.name || "");
      item.dataset.tierId = safeText(t.id || "");

      const row = document.createElement("div");
      row.className = "ff-row ff-row--between";
      row.style.alignItems = "baseline";

      const left = document.createElement("div");
      const kicker = document.createElement("div");
      kicker.className = "ff-kicker";
      kicker.textContent = "Tier";
      const title = document.createElement("div");
      title.className = "ff-card__title";
      title.style.marginTop = "6px";
      title.textContent = safeText(t.name || "Sponsor");

      left.appendChild(kicker);
      left.appendChild(title);

      const amt = document.createElement("span");
      amt.className = "ff-pill ff-pill--accent";
      amt.textContent = money(t.amount || 0);

      row.appendChild(left);
      row.appendChild(amt);

      const perks = document.createElement("ul");
      perks.className = "ff-bul";
      perks.style.marginTop = "10px";
      (t.perks || []).slice(0, 4).forEach((p) => {
        const li = document.createElement("li");
        li.textContent = safeText(p);
        perks.appendChild(li);
      });

      const hint = document.createElement("p");
      hint.className = "ff-help";
      hint.style.marginTop = "10px";
      hint.textContent = "Tap to prefill checkout + apply recognition.";

      item.appendChild(row);
      if (perks.childNodes.length) item.appendChild(perks);
      item.appendChild(hint);

      frag.appendChild(item);
    });

    sponsorTiersEl.innerHTML = "";
    sponsorTiersEl.appendChild(frag);
  };

  const renderSponsorKitTiers = () => {
    if (!kitTierList) return;
    const tiers = Array.isArray(cfg.sponsors?.tiers) ? cfg.sponsors.tiers : [];

    const frag = document.createDocumentFragment();
    tiers.slice(0, 4).forEach((t) => {
      const row = document.createElement("div");
      row.className = "ff-mini";

      const top = document.createElement("div");
      top.className = "ff-row ff-row--between";
      top.style.alignItems = "baseline";

      const name = document.createElement("strong");
      name.className = "ff-num";
      name.textContent = safeText(t.name || "Tier");

      const amt = document.createElement("span");
      amt.className = "ff-pill";
      amt.textContent = money(t.amount || 0);

      top.appendChild(name);
      top.appendChild(amt);

      const perks = document.createElement("p");
      perks.className = "ff-help";
      perks.style.marginTop = "6px";
      perks.textContent = (t.perks || []).slice(0, 2).join(" • ") || "Recognition included.";

      row.appendChild(top);
      row.appendChild(perks);
      frag.appendChild(row);
    });

    kitTierList.innerHTML = "";
    kitTierList.appendChild(frag);
  };

  const renderSponsorLeaderboard = () => {
    if (!sponsorLeaderboardEl) return;
    const list = Array.isArray(cfg.sponsors?.leaderboard) ? cfg.sponsors.leaderboard : [];

    const sorted = list
      .slice()
      .sort((a, b) => (Number(b.amount) || 0) - (Number(a.amount) || 0))
      .slice(0, 10);

    if (!sorted.length) {
      sponsorLeaderboardEl.innerHTML = `<div class="ff-mini"><div class="ff-kicker">No sponsors yet</div><p class="ff-help">Be the first sponsor—tiers above prefill checkout.</p></div>`;
      if (sponsorSpotlight) sponsorSpotlight.hidden = true;
      return;
    }

    const top = sorted[0];
    if (sponsorSpotlight && spotlightName) {
      sponsorSpotlight.hidden = false;
      spotlightName.textContent = safeText(top.name || "Sponsor");
      if (spotlightLink) {
        const href = safeText(top.website || "").trim();
        spotlightLink.hidden = !href;
        if (href) spotlightLink.href = href;
      }
    }

    const frag = document.createDocumentFragment();
    sorted.forEach((s, i) => {
      const row = document.createElement("div");
      row.className = "ff-mini";
      row.setAttribute("role", "listitem");

      const topRow = document.createElement("div");
      topRow.className = "ff-row ff-row--between";

      const left = document.createElement("div");
      const kicker = document.createElement("div");
      kicker.className = "ff-kicker";
      kicker.textContent = `#${i + 1}`;
      const name = document.createElement("strong");
      name.className = "ff-num";
      name.textContent = safeText(s.name || "Sponsor");

      left.appendChild(kicker);
      left.appendChild(name);

      const amt = document.createElement("span");
      amt.className = "ff-pill ff-pill--accent";
      amt.textContent = money(s.amount || 0);

      topRow.appendChild(left);
      topRow.appendChild(amt);

      const link = safeText(s.website || "").trim();
      if (link) {
        const a = document.createElement("a");
        a.className = "ff-help";
        a.href = link;
        a.target = "_blank";
        a.rel = "noopener";
        a.style.display = "inline-block";
        a.style.marginTop = "6px";
        a.textContent = link.replace(/^https?:\/\//, "");
        row.appendChild(topRow);
        row.appendChild(a);
      } else {
        row.appendChild(topRow);
      }

      frag.appendChild(row);
    });

    sponsorLeaderboardEl.innerHTML = "";
    sponsorLeaderboardEl.appendChild(frag);
  };

  const renderSponsorWall = () => {
    if (!sponsorWallEl) return;
    const list = Array.isArray(cfg.sponsors?.wall) ? cfg.sponsors.wall : [];
    const items = list.slice(0, 12);

    if (!items.length) {
      sponsorWallEl.innerHTML = `<div class="ff-mini" style="grid-column:1/-1"><div class="ff-kicker">Sponsor wall</div><p class="ff-help">Sponsor logos appear here when provided at checkout.</p></div>`;
      return;
    }

    const frag = document.createDocumentFragment();
    items.forEach((s) => {
      const a = document.createElement("a");
      a.className = "ff-mini";
      a.setAttribute("role", "listitem");
      a.style.display = "grid";
      a.style.placeItems = "center";
      a.style.textDecoration = "none";
      a.href = safeText(s.website || "#");
      if (a.href === "#") a.removeAttribute("href");
      a.target = "_blank";
      a.rel = "noopener";

      const imgUrl = safeText(s.logoUrl || "").trim();
      if (imgUrl) {
        const img = document.createElement("img");
        img.loading = "lazy";
        img.decoding = "async";
        img.alt = safeText(s.name || "Sponsor");
        img.src = imgUrl;
        img.style.maxWidth = "100%";
        img.style.maxHeight = "56px";
        img.style.objectFit = "contain";
        a.appendChild(img);
      } else {
        const t = document.createElement("strong");
        t.className = "ff-num";
        t.textContent = safeText(s.name || "Sponsor");
        a.appendChild(t);
      }

      frag.appendChild(a);
    });

    sponsorWallEl.innerHTML = "";
    sponsorWallEl.appendChild(frag);
  };

  /* ---------------------------------------------
   * Donation state + bindings
   * -------------------------------------------*/
  const donationForm = qs("#donationForm");
  const amountInput = qs("#amountInput");
  const amountErr = qs("#amountErr");
  const emailInput = qs("#emailInput");
  const nameInput = qs("#nameInput");
  const noteInput = qs("#noteInput");
  const teamSelect = qs("#teamSelect");
  const teamHidden = qs("#selectedTeamId");
  const tierHidden = qs("#selectedTierId");
  const payMethodHidden = qs("#payMethodHidden");
  const freqHidden = qs("#frequencyHidden");
  const totalHidden = qs("#ffTotalHidden");
  const idemHidden = qs("#ffIdemHidden");

  const donateFreqSeg = qs("#donateFreqSeg");
  const paypalChip = qs("#paypalChip");
  const payChips = qsa("[data-pay-method]");

  const coverFeesCb = qs("#coverFees");
  const roundUpCb = qs("#roundUp");
  const coversNotice = qs("#coversNotice");
  const coversText = qs("#coversText");

  const formError = qs("#formError");
  const recognitionNotice = qs("#recognitionNotice");
  const sponsorUpsell = qs("#sponsorUpsell");
  const sponsorFieldsWrap = qs("#sponsorFieldsWrap");
  const tierNotice = qs("#tierNotice");
  const tierName = qs("#tierName");

  const summaryAmount = qs("#summaryAmount");
  const summaryFreq = qs("#summaryFreq");
  const summaryTeam = qs("#summaryTeam");
  const summaryTotal = qs("#summaryTotal");

  const stripePaymentWrap = qs("#stripePaymentWrap");
  const paypalPaymentWrap = qs("#paypalPaymentWrap");
  const paypalBtnMount = qs("#paypalBtn");

  const matchNotice = qs("#matchNotice");
  const matchCountdown = qs("#matchCountdown");
  const matchPills = {
    topbar: qs("#matchPill"),
    hero: qs("#heroMatchPill"),
    donate: qs("#donateMatchPill"),
    summary: qs("#summaryMatchPill"),
    kit: qs("#kitMatchPill")
  };

  const state = {
    amount: 0,
    frequency: "once", // once|monthly
    payMethod: "stripe", // stripe|paypal
    coverFees: false,
    roundUp: false,
    teamId: "all",
    tierId: "",
    tierName: "",
    prefill: false,
    matchActive: !!cfg.match?.active,
    matchEndsISO: safeText(cfg.match?.endsISO || "")
  };

  const setFormError = (msg) => {
    if (!formError) return;
    if (!msg) {
      formError.hidden = true;
      formError.textContent = "";
      return;
    }
    formError.hidden = false;
    formError.textContent = String(msg);
  };

  const feeGrossUp = (baseAmount) => {
    // Calculate donor-paid total such that net ~= baseAmount after fees
    // total = (base + flat) / (1 - pct)
    const pctFee = Number(cfg.fees?.pct) || 0;
    const flat = Number(cfg.fees?.flat) || 0;
    const base = Number(baseAmount) || 0;
    if (base <= 0) return { total: 0, fee: 0 };
    const total = (base + flat) / (1 - pctFee);
    const rounded = Math.round(total * 100) / 100;
    const fee = Math.max(0, Math.round((rounded - base) * 100) / 100);
    return { total: rounded, fee };
  };

  const computeTotal = () => {
    let amt = Number(state.amount) || 0;

    // round up
    let roundUpAdd = 0;
    if (state.roundUp) roundUpAdd = roundUpToNext(amt, 5);

    const base = Math.round((amt + roundUpAdd) * 100) / 100;

    // cover fees
    let total = base;
    let fee = 0;
    if (state.coverFees && cfg.fees?.enabled !== false) {
      const g = feeGrossUp(base);
      total = g.total;
      fee = g.fee;
    }

    return { base, roundUpAdd, fee, total: Math.round(total * 100) / 100 };
  };

  const updateFeeNotice = () => {
    if (!coversNotice || !coversText) return;
    const { base, roundUpAdd, fee, total } = computeTotal();

    if (!state.coverFees && !state.roundUp) {
      coversNotice.hidden = true;
      return;
    }

    const parts = [];
    if (state.roundUp && roundUpAdd > 0) parts.push(`Round up: +${money(roundUpAdd, true)}`);
    if (state.coverFees && fee > 0) parts.push(`Estimated fees covered: +${money(fee, true)}`);

    coversText.textContent = `${parts.join(" • ")} • Total today: ${money(total, true)}`;
    coversNotice.hidden = false;
  };

  const updateSummary = () => {
    const { total } = computeTotal();
    setText(summaryAmount, money(state.amount || 0, true));
    setText(summaryFreq, state.frequency === "monthly" ? "Monthly" : "One-time");
    setText(summaryTeam, teamLabel(state.teamId));
    setText(summaryTotal, money(total, true));

    if (totalHidden) totalHidden.value = String(total);
    if (freqHidden) freqHidden.value = state.frequency;
    if (teamHidden) teamHidden.value = state.teamId;
    if (tierHidden) tierHidden.value = state.tierId || "";
    if (payMethodHidden) payMethodHidden.value = state.payMethod;

    updateFeeNotice();
  };

  const teamLabel = (id) => {
    if (!id || id === "all") return "All teams";
    const t = (cfg.teams || []).find((x) => String(x.id) === String(id));
    return t ? String(t.name || id) : String(id);
  };

  const applyAmountToInput = (amt) => {
    const a = parseAmount(amt);
    state.amount = a;
    if (amountInput) amountInput.value = a > 0 ? String(a) : "";
    if (amountErr) amountErr.hidden = a > 0;
    updateSummary();
  };

  const applyTeam = (teamId) => {
    state.teamId = teamId || "all";
    if (teamSelect) teamSelect.value = state.teamId;
    updateSummary();
  };

  const applyTier = (tierId, tierNameStr, amt) => {
    state.tierId = tierId || "";
    state.tierName = tierNameStr || "";
    if (tierHidden) tierHidden.value = state.tierId;

    if (tierNotice && tierName) {
      if (state.tierId) {
        tierNotice.hidden = false;
        tierName.textContent = state.tierName || "Sponsor tier";
      } else {
        tierNotice.hidden = true;
      }
    }

    // Reveal sponsor details when tier selected
    if (sponsorFieldsWrap) sponsorFieldsWrap.hidden = !state.tierId;
    if (recognitionNotice) recognitionNotice.hidden = !state.tierId;
    if (sponsorUpsell) sponsorUpsell.hidden = !!state.tierId;

    if (amt) applyAmountToInput(amt);
    updateSummary();
  };

  const setPrefillPills = (onPill = true) => {
    if (impactPrefillPill) impactPrefillPill.hidden = !onPill;
    if (donatePrefillPill) donatePrefillPill.hidden = !onPill;
  };

  const setFrequency = (freq) => {
    state.frequency = freq === "monthly" ? "monthly" : "once";
    if (donateFreqSeg) {
      qsa("button[data-freq]", donateFreqSeg).forEach((b) => {
        const is = b.getAttribute("data-freq") === state.frequency;
        b.setAttribute("aria-pressed", String(is));
      });
    }
    updateSummary();
  };

  const setPayMethod = async (method) => {
    state.payMethod = method === "paypal" ? "paypal" : "stripe";
    payChips.forEach((b) => b.setAttribute("aria-pressed", String(b.getAttribute("data-pay-method") === state.payMethod)));

    // Toggle UI
    if (stripePaymentWrap) stripePaymentWrap.hidden = true; // optional inline (kept hidden by default)
    if (paypalPaymentWrap) paypalPaymentWrap.hidden = state.payMethod !== "paypal";

    updateSummary();

    if (state.payMethod === "paypal") {
      // Load PayPal SDK on demand (only if meta has client id)
      const ok = await (window.ffLoadPayPal ? window.ffLoadPayPal() : Promise.resolve(false));
      if (!ok) {
        toast("PayPal is not enabled for this campaign.", { title: "Payment" });
        // revert to stripe
        state.payMethod = "stripe";
        payChips.forEach((b) => b.setAttribute("aria-pressed", String(b.getAttribute("data-pay-method") === state.payMethod)));
        if (paypalPaymentWrap) paypalPaymentWrap.hidden = true;
        updateSummary();
        return;
      }

      // If you have PayPal endpoints, wire them here.
      // For now: show a friendly notice if no server integration exists.
      if (paypalBtnMount && window.paypal && !paypalBtnMount.dataset.rendered) {
        paypalBtnMount.dataset.rendered = "1";
        paypalBtnMount.innerHTML = `<div class="ff-notice"><div class="ff-kicker">PayPal setup needed</div><p class="ff-help" style="margin-top:6px">Add server endpoints for createOrder/capture, then render PayPal Buttons here.</p></div>`;
      }
    }
  };

  const initDonationBindings = () => {
    // Amount input
    on(amountInput, "input", () => {
      const a = parseAmount(amountInput.value);
      state.amount = a;
      if (amountErr) amountErr.hidden = a > 0;
      setPrefillPills(false);
      updateSummary();
    });

    // Frequency
    on(donateFreqSeg, "click", (e) => {
      const btn = e.target.closest("button[data-freq]");
      if (!btn) return;
      setFrequency(btn.getAttribute("data-freq"));
    });

    // Team select
    on(teamSelect, "change", () => {
      applyTeam(teamSelect.value || "all");
      setPrefillPills(true);
    });

    // Cover fees / round up
    on(coverFeesCb, "change", () => {
      state.coverFees = !!coverFeesCb.checked;
      updateSummary();
    });
    on(roundUpCb, "change", () => {
      state.roundUp = !!roundUpCb.checked;
      updateSummary();
    });

    // Pay method chip toggles
    on(document, "click", (e) => {
      const btn = e.target.closest("[data-pay-method]");
      if (!btn) return;
      e.preventDefault();
      setPayMethod(btn.getAttribute("data-pay-method"));
    });

    // Quick amount chips (hero/progress/sticky)
    on(document, "click", (e) => {
      const btn = e.target.closest("[data-quick-amount]");
      if (!btn) return;
      e.preventDefault();
      const amt = parseAmount(btn.getAttribute("data-quick-amount"));
      if (!amt) return;
      applyAmountToInput(amt);
      setPrefillPills(true);

      // visually toggle aria-pressed on chips within same group
      const group = btn.closest("[role='group']") || btn.parentElement;
      if (group) {
        qsa("[data-quick-amount]", group).forEach((b) => b.setAttribute("aria-pressed", String(b === btn)));
      }
    });

    // Impact prefill (buttons created by renderImpact)
    on(document, "click", (e) => {
      const card = e.target.closest("[data-ff-impact]");
      if (!card) return;
      e.preventDefault();
      const amt = parseAmount(card.dataset.prefillAmount);
      const note = safeText(card.dataset.prefillNote || "").trim();
      if (amt) applyAmountToInput(amt);
      if (noteInput && note) noteInput.value = note;
      setPrefillPills(true);
      toast("Prefilled from Impact.", { title: "Impact" });
      // Optional: scroll to donate on mobile
      // document.getElementById("donate")?.scrollIntoView({ behavior: "smooth" });
    });

    // Team-tag links/buttons (including dynamically rendered team cards)
    on(document, "click", (e) => {
      const el = e.target.closest("[data-ff-team-tag]");
      if (!el) return;

      // Many are anchors to #donate; let navigation happen, but apply tag first
      const tag = el.getAttribute("data-ff-team-tag") || "all";
      applyTeam(tag);
      setPrefillPills(true);
    });

    // Sponsor tier selects
    on(document, "click", (e) => {
      const el = e.target.closest("[data-ff-tier]");
      if (!el) return;
      e.preventDefault();
      const tierId = el.dataset.tierId || el.dataset.ffTier || "";
      const name = el.dataset.tierName || "Sponsor tier";
      const amt = parseAmount(el.dataset.prefillAmount);
      applyTier(tierId, name, amt);
      setPrefillPills(true);
      toast(`Selected ${name}.`, { title: "Sponsors" });
    });

    // Default: show sponsor upsell if no tier
    if (sponsorUpsell) sponsorUpsell.hidden = false;

    // Initialize hidden values
    if (idemHidden) idemHidden.value = uid();
    updateSummary();
  };

  /* ---------------------------------------------
   * Match UI (optional)
   * -------------------------------------------*/
  let matchTimer = null;

  const setMatchUi = (active) => {
    Object.values(matchPills).forEach((el) => el && (el.hidden = !active));
    if (matchNotice) matchNotice.hidden = !active;

    // Sticky match pill
    const stickyMatch = qs("#stickyMatch");
    if (stickyMatch) stickyMatch.hidden = !active;

    // topbar countdown pill
    const countdownPill = qs("#countdownPill");
    if (countdownPill) countdownPill.hidden = !active;
  };

  const tickMatchCountdown = () => {
    if (!state.matchActive || !state.matchEndsISO) return;
    const ends = new Date(state.matchEndsISO);
    if (Number.isNaN(ends.getTime())) return;

    const ms = ends.getTime() - Date.now();
    if (ms <= 0) {
      state.matchActive = false;
      setMatchUi(false);
      if (matchTimer) clearInterval(matchTimer);
      toast("Match window ended.", { title: "Match" });
      return;
    }

    const mins = Math.floor(ms / (1000 * 60));
    const hrs = Math.floor(mins / 60);
    const remM = mins % 60;

    const label = hrs > 0 ? `${hrs}h ${remM}m left` : `${remM}m left`;
    if (matchCountdown) matchCountdown.textContent = label;

    const countdownPill = qs("#countdownPill");
    if (countdownPill) countdownPill.hidden = false;
  };

  const initMatch = () => {
    setMatchUi(!!state.matchActive);
    if (state.matchActive && state.matchEndsISO) {
      tickMatchCountdown();
      matchTimer = setInterval(tickMatchCountdown, 30_000);
    }
  };
/* -------------------------
 * Stripe checkout (v3: mount in modal host #modalPaymentElement)
 * Extracted from your App JS
 * ------------------------- */
(() => {
  'use strict';

  /* -------------------------
   * Minimal dependencies (these exist in your app already)
   * If you already have these, remove duplicates.
   * ------------------------- */
  const $ = (sel, root = document) => root.querySelector(sel);

  const meta = (name) =>
    document.querySelector(`meta[name="${name}"]`)?.getAttribute('content') || '';

  const getCsrfToken = () => meta('csrf-token') || meta('csrf') || meta('x-csrf-token') || '';
  const getCheckoutEndpoint = () => meta('ff-checkout-endpoint') || '/payments/stripe/intent';
  const getStripePk = () => meta('ff-stripe-pk') || meta('stripe-pk') || '';

  const isEmail = (v) => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(String(v || '').trim());

  const uuid = () =>
    window.crypto?.randomUUID
      ? crypto.randomUUID()
      : 'ff_' + Date.now().toString(16) + '_' + Math.random().toString(16).slice(2);

  async function fetchJson(url, { method = 'GET', payload, headers = {}, timeoutMs = 15000 } = {}) {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const res = await fetch(url, {
        method,
        credentials: 'same-origin',
        headers: {
          Accept: 'application/json',
          ...(payload ? { 'Content-Type': 'application/json' } : {}),
          ...headers,
        },
        body: payload ? JSON.stringify(payload) : undefined,
        signal: ctrl.signal,
      });

      const ct = (res.headers.get('content-type') || '').toLowerCase();
      const data = ct.includes('application/json') ? await res.json().catch(() => null) : null;

      if (!res.ok || data?.ok === false) {
        const msg = data?.error?.message || data?.message || `Request failed (${res.status})`;
        throw new Error(msg);
      }
      if (!data) throw new Error('Expected JSON response.');
      return data;
    } finally {
      clearTimeout(t);
    }
  }

  // These are in your app; keep using your real versions if present.
  const show = (el, v = true) => {
    if (!el) return;
    el.hidden = !v;
    el.setAttribute('aria-hidden', v ? 'false' : 'true');
  };
  const setText = (el, v) => {
    if (!el) return;
    el.textContent = String(v ?? '');
  };

  // If you have CONFIG + currencyCode + money0 already, keep those.
  // Minimal fallback:
  const currencyCode = () => (meta('ff-currency') || 'USD').toUpperCase();
  const money0 = (n) => {
    const v = Number(n) || 0;
    try {
      return new Intl.NumberFormat(undefined, {
        style: 'currency',
        currency: currencyCode(),
        minimumFractionDigits: 0,
        maximumFractionDigits: 0,
      }).format(v);
    } catch {
      return '$' + String(Math.round(v));
    }
  };

  // Your app modal + toast functions must exist.
  // openModal(id), closeModal(id), toast(title, body)
  // If not present, wire them before using this Stripe module.

  const canonicalUrl = () => {
    const u = new URL(window.location.href);
    u.hash = '';
    return u.toString();
  };

  /* -------------------------
   * DOM refs (only the ones Stripe flow needs)
   * ------------------------- */
  const E = {
    // donate form fields
    donationForm: $('#donationForm'),
    amountInput: $('#amountInput'),
    emailInput: $('#emailInput'),
    nameInput: $('#nameInput'),
    noteInput: $('#noteInput'),
    donorAnonymous: $('#donorAnonymous'),
    updatesOptIn: $('#updatesOptIn'),
    coverFees: $('#coverFees'),
    roundUp: $('#roundUp'),

    // hidden fields + selectors
    frequencyHidden: $('#frequencyHidden'),
    ffTotalHidden: $('#ffTotalHidden'),
    ffIdemHidden: $('#ffIdemHidden'),
    teamSelect: $('#teamSelect'),
    selectedTierId: $('#selectedTierId'),
    refCodeInput: $('#refCodeInput'),

    // errors
    formError: $('#formError'),

    // checkout modal
    checkoutLoading: $('#checkoutLoading'),
    checkoutModalError: $('#checkoutModalError'),
    payNowBtn: $('#payNowBtn'),
    modalPaymentElementHost: $('#modalPaymentElement'),

    // summary in checkout modal
    checkoutSummary: $('#checkoutSummary'),
    checkoutSummaryAmount: $('#checkoutSummaryAmount'),
    checkoutSummaryFrequency: $('#checkoutSummaryFrequency'),
    checkoutSummaryTeam: $('#checkoutSummaryTeam'),

    // success modal fields (optional)
    successEmail: $('#successEmail'),
    successAmount: $('#successAmount'),
    successFrequency: $('#successFrequency'),
    successTeam: $('#successTeam'),
  };

  /* -------------------------
   * State
   * ------------------------- */
  const state = {
    checkout: { busy: false, clientSecret: '', paymentIntentId: '' },
  };

  /* -------------------------
   * Stripe globals
   * ------------------------- */
  let stripe = null;
  let elements = null;
  let paymentEl = null;

  function setCheckoutError(msg) {
    if (!E.checkoutModalError) return;
    if (!msg) {
      E.checkoutModalError.textContent = '';
      show(E.checkoutModalError, false);
      return;
    }
    E.checkoutModalError.textContent = String(msg);
    show(E.checkoutModalError, true);
  }

  function setCheckoutLoading(v) {
    show(E.checkoutLoading, !!v);
  }

  function teardownStripeElements() {
    try {
      paymentEl?.unmount?.();
    } catch {}
    paymentEl = null;
    elements = null;
    if (E.modalPaymentElementHost) E.modalPaymentElementHost.innerHTML = '';
  }

  function resetCheckoutUi() {
    setCheckoutError('');
    setCheckoutLoading(false);
    teardownStripeElements();
    state.checkout.busy = false;
    state.checkout.clientSecret = '';
    state.checkout.paymentIntentId = '';
    if (E.payNowBtn) {
      E.payNowBtn.disabled = true;
      E.payNowBtn.setAttribute('aria-disabled', 'true');
      E.payNowBtn.textContent = 'Pay now';
    }
    show(E.checkoutSummary, false);
  }

  async function ensureStripe() {
    if (stripe) return stripe;
    const pk = getStripePk();
    if (!pk) throw new Error('Missing Stripe publishable key.');
    if (!window.Stripe) throw new Error('Stripe.js not loaded.');
    stripe = window.Stripe(pk);
    return stripe;
  }

  function selectedFrequency() {
    return E.frequencyHidden?.value === 'monthly' ? 'monthly' : 'once';
  }

  function validateForm({ amount, email }) {
    const errs = [];
    if (!(amount > 0)) errs.push('Enter a valid amount.');
    if (!isEmail(email)) errs.push('Enter a valid email for your receipt.');
    return errs;
  }

  function setFormError(msg) {
    if (!E.formError) return;
    if (!msg) {
      E.formError.textContent = '';
      show(E.formError, false);
      return;
    }
    E.formError.textContent = String(msg);
    show(E.formError, true);
  }

  function buildCheckoutPayload() {
    // NOTE: This is your exact “working” integer rounding behavior.
    // If you want cents support later, change Math.round() to parse dollars->cents.
    const base = Math.max(1, Math.round(Number(E.amountInput?.value || 0) || 0));
    const email = String(E.emailInput?.value || '').trim();
    const name = String(E.nameInput?.value || '').trim();
    const message = String(E.noteInput?.value || '').trim();
    const anonymous = !!E.donorAnonymous?.checked;
    const updatesOptIn = !!E.updatesOptIn?.checked;

    let total = Math.max(1, Math.round(Number(E.ffTotalHidden?.value || base) || base));

    const teamKey = String(E.teamSelect?.value || 'all');
    const tierId = String(E.selectedTierId?.value || '');
    const ref = String(E.refCodeInput?.value || '').trim();
    const freq = selectedFrequency();

    const idem = uuid();
    if (E.ffIdemHidden) E.ffIdemHidden.value = idem;

    return {
      amount: total,
      amount_base: base,
      currency: currencyCode(),
      email,
      name,
      message,
      anonymous,
      updates_opt_in: updatesOptIn,
      cover_fees: !!E.coverFees?.checked,
      round_up: !!E.roundUp?.checked,
      team: teamKey === 'all' ? '' : teamKey,
      tier: tierId,
      ref,
      frequency: freq,
      idem_key: idem,
      page_url: canonicalUrl(),
    };
  }

  async function createIntent(payload) {
    const url = getCheckoutEndpoint();
    const csrf = getCsrfToken();

    return fetchJson(url, {
      method: 'POST',
      payload,
      headers: {
        ...(csrf ? { 'X-CSRF-Token': csrf } : {}),
        'X-Idempotency-Key': payload.idem_key || '',
      },
    });
  }

  async function openCheckout(payload) {
    setCheckoutError('');
    setCheckoutLoading(true);

    // requires your modal system
    openModal('checkoutModal');

    const data = await createIntent(payload);
    const clientSecret = data.clientSecret || data.client_secret || '';
    const paymentIntentId = data.paymentIntentId || data.payment_intent_id || '';
    if (!clientSecret) throw new Error('Missing client secret from server.');

    await ensureStripe();
    teardownStripeElements();

    elements = stripe.elements({
      clientSecret,
      appearance: {
        theme: document.documentElement.getAttribute('data-theme') === 'light' ? 'stripe' : 'night',
        variables: { colorPrimary: String(window.CONFIG?.brand?.accent || '#f97316') },
      },
    });

    if (!E.modalPaymentElementHost) throw new Error('Missing #modalPaymentElement host.');
    paymentEl = elements.create('payment');
    paymentEl.mount('#modalPaymentElement');

    state.checkout.clientSecret = clientSecret;
    state.checkout.paymentIntentId = paymentIntentId;
    state.checkout.busy = false;

    // summary in modal
    if (E.checkoutSummaryAmount) setText(E.checkoutSummaryAmount, money0(payload.amount));
    if (E.checkoutSummaryFrequency)
      setText(E.checkoutSummaryFrequency, payload.frequency === 'monthly' ? 'Monthly' : 'Once');
    if (E.checkoutSummaryTeam) {
      const team = payload.team ? payload.team : 'All teams';
      setText(E.checkoutSummaryTeam, team);
    }
    show(E.checkoutSummary, true);

    if (E.payNowBtn) {
      E.payNowBtn.disabled = false;
      E.payNowBtn.setAttribute('aria-disabled', 'false');
      E.payNowBtn.textContent = 'Pay now';
    }

    setCheckoutLoading(false);
  }

  async function confirmPayment() {
    if (!elements || !stripe) return;
    if (state.checkout.busy) return;
    state.checkout.busy = true;

    setCheckoutError('');
    if (E.payNowBtn) {
      E.payNowBtn.disabled = true;
      E.payNowBtn.setAttribute('aria-disabled', 'true');
      E.payNowBtn.textContent = 'Processing…';
    }

    try {
      const res = await stripe.confirmPayment({
        elements,
        redirect: 'if_required',
        confirmParams: { return_url: window.location.href },
      });

      if (res.error) throw new Error(res.error.message || 'Payment failed.');

      closeModal('checkoutModal'); // triggers reset via event
      const email = String(E.emailInput?.value || '').trim();
      const amount = money0(Number(E.ffTotalHidden?.value || E.amountInput?.value || 0));
      const freq = selectedFrequency() === 'monthly' ? 'Monthly' : 'Once';

      const teamKey = String(E.teamSelect?.value || 'all');
      const teamName = teamKey === 'all' ? 'All teams' : teamKey;

      setText(E.successEmail, email || '—');
      setText(E.successAmount, amount);
      setText(E.successFrequency, freq);
      setText(E.successTeam, teamName);

      openModal('successModal');
      if (typeof confettiBurst === 'function') confettiBurst();
      if (typeof toast === 'function') toast('Donation complete', 'Receipt sent by email.');
      if (typeof refreshStatus === 'function') await refreshStatus({ silent: true });
    } catch (err) {
      setCheckoutError(err?.message || 'Payment failed.');
    } finally {
      state.checkout.busy = false;
      if (E.payNowBtn) {
        E.payNowBtn.disabled = false;
        E.payNowBtn.setAttribute('aria-disabled', 'false');
        E.payNowBtn.textContent = 'Pay now';
      }
    }
  }

  function initCheckout() {
    E.payNowBtn?.addEventListener('click', confirmPayment);

    // Any time checkout modal closes, teardown safely.
    document.addEventListener('ff:modal:closed', (ev) => {
      if (ev?.detail?.id === 'checkoutModal') resetCheckoutUi();
    });
  }

  function initDonationForm() {
    if (!E.donationForm) return;

    E.donationForm.addEventListener('submit', async (e) => {
      e.preventDefault();
      setFormError('');

      if (typeof updateSummary === 'function') updateSummary();
      const payload = buildCheckoutPayload();

      const errs = validateForm({ amount: payload.amount, email: payload.email });
      if (errs.length) {
        setFormError(errs.join(' '));
        if (typeof toast === 'function') toast('Fix the form', errs[0] || 'Please check your info.');
        return;
      }

      try {
        await openCheckout(payload);
      } catch (err) {
        closeModal('checkoutModal');
        resetCheckoutUi();
        setFormError(err?.message || 'Checkout failed.');
        if (typeof toast === 'function')
          toast('Checkout error', err?.message || 'Please try again.');
      }
    });
  }

  // Call these from your main init()
  window.initStripeCheckoutV3 = function initStripeCheckoutV3() {
    initDonationForm();
    initCheckout();
  };
})();

  /* ---------------------------------------------
   * Donate CTA anchors (minor polish)
   * -------------------------------------------*/
  const initAnchors = () => {
    // Smooth scroll for in-page anchor links
    on(document, "click", (e) => {
      const a = e.target.closest('a[href^="#"]');
      if (!a) return;
      const href = a.getAttribute("href");
      if (!href || href === "#") return;

      const id = href.slice(1);
      const target = qs(`#${CSS.escape(id)}`);
      if (!target) return;

      // Let browser handle if user is using modifiers
      if (e.metaKey || e.ctrlKey || e.shiftKey || e.altKey) return;

      e.preventDefault();
      target.scrollIntoView({ behavior: "smooth", block: "start" });
    });
  };
  

  /* ---------------------------------------------
   * Boot
   * -------------------------------------------*/
  const boot = () => {
    applyPremiumVisibility();
    setTheme(getTheme());

    bindOrg();
    bindProgress();

    initAnnouncement();
    initTopbar();
    initDrawer();
    initModals();
    initShare();
    initScrollUi();
    initSectionSpy();
    initAnchors();

    renderImpact();
    renderAllocation();

    renderSponsorTiers();
    renderSponsorLeaderboard();
    renderSponsorWall();

    initDonationBindings();
    initMatch();
    initCheckout();

    // Theme toggle
    on(themeToggleBtn, "click", () => setTheme(getTheme() === "dark" ? "light" : "dark"));

    // When inline bootstrap renders teams (it emits ff:teams-rendered), keep summary consistent
    on(window, "ff:teams-rendered", () => {
      bindProgress();
      updateSummary();
    });

    // Initial fee notice / summary
    updateSummary();
  };

  // If config-ready is emitted by the inline script, boot immediately anyway (cfg already merged above)
  if (document.readyState === "loading") {
    on(document, "DOMContentLoaded", boot);
  } else {
    boot();
  }
})();

