/*! ff-app.js — FutureFunded Flagship v12 (drop-in, refactor + elite upgrades + Gallery v2) */
(() => {
  "use strict";

  /* =========================================================
   * 0) Micro-kernel utilities (fast, safe, dependency-free)
   * =======================================================*/
  const qs = (sel, root = document) => root.querySelector(sel);
  const qsa = (sel, root = document) => Array.from(root.querySelectorAll(sel));
  const on = (el, ev, fn, opt) => el && el.addEventListener(ev, fn, opt);
  const clamp = (n, a, b) => Math.min(b, Math.max(a, n));
  const safeText = (v) => (v == null ? "" : String(v));
  const toInt = (v, def = 0) => {
    const n = Number.parseInt(v, 10);
    return Number.isFinite(n) ? n : def;
  };
  const toNum = (v, def = 0) => {
    const n = Number(v);
    return Number.isFinite(n) ? n : def;
  };
  const now = () => Date.now();

  const debounce = (fn, ms = 200) => {
    let t = null;
    return (...args) => {
      clearTimeout(t);
      t = setTimeout(() => fn(...args), ms);
    };
  };

  const throttle = (fn, ms = 120) => {
    let last = 0;
    let pending = null;
    return (...args) => {
      const t = now();
      if (t - last >= ms) {
        last = t;
        fn(...args);
        return;
      }
      clearTimeout(pending);
      pending = setTimeout(() => {
        last = now();
        fn(...args);
      }, Math.max(0, ms - (t - last)));
    };
  };

  const idle = (fn, timeout = 700) => {
    if ("requestIdleCallback" in window) return window.requestIdleCallback(fn, { timeout });
    return setTimeout(fn, Math.min(120, timeout));
  };

  const meta = (name) => {
    const el = qs(`meta[name="${CSS.escape(name)}"]`);
    return el ? el.content || "" : "";
  };

  const parseJSON = (txt, fallback) => {
    try {
      return JSON.parse(txt);
    } catch {
      return fallback;
    }
  };

  const escapeHTML = (s) =>
    safeText(s).replace(/[&<>"']/g, (m) => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }[m]));

  const emailOk = (s) => {
    const v = safeText(s).trim();
    if (!v) return false;
    if (v.length > 320) return false;
    return /^[^\s@]+@[^\s@]+\.[^\s@]{2,}$/.test(v);
  };

  const parseMoneyToCents = (raw) => {
    const s = safeText(raw).trim();
    if (!s) return 0;
    const cleaned = s.replace(/[^\d.]/g, "");
    if (!cleaned) return 0;
    const parts = cleaned.split(".");
    const whole = parts[0] || "0";
    const frac = (parts[1] || "").slice(0, 2).padEnd(2, "0");
    const cents = toInt(whole, 0) * 100 + toInt(frac, 0);
    return Math.max(0, cents);
  };

  const formatCurrency = (cents, currency = "USD", locale = "en-US") => {
    const n = (toNum(cents, 0) / 100) || 0;
    try {
      return new Intl.NumberFormat(locale, { style: "currency", currency, maximumFractionDigits: 0 }).format(n);
    } catch {
      return `$${Math.round(n).toLocaleString("en-US")}`;
    }
  };

  const formatCurrencyExact = (cents, currency = "USD", locale = "en-US") => {
    const n = (toNum(cents, 0) / 100) || 0;
    try {
      return new Intl.NumberFormat(locale, { style: "currency", currency, minimumFractionDigits: 2, maximumFractionDigits: 2 }).format(n);
    } catch {
      return `$${n.toFixed(2)}`;
    }
  };

  const pick = (obj, path, def) => {
    try {
      const parts = path.split(".");
      let cur = obj;
      for (const p of parts) cur = cur?.[p];
      return cur == null ? def : cur;
    } catch {
      return def;
    }
  };

  const setHidden = (el, v) => {
    if (!el) return;
    el.hidden = !!v;
    el.setAttribute("aria-hidden", v ? "true" : "false");
  };

  const setBusy = (el, v) => el && el.setAttribute("aria-busy", v ? "true" : "false");
  const setAriaPressed = (btn, v) => btn && btn.setAttribute("aria-pressed", v ? "true" : "false");

  const prefersReducedMotion = () => {
    try {
      return window.matchMedia && window.matchMedia("(prefers-reduced-motion: reduce)").matches;
    } catch {
      return false;
    }
  };

  const scrollIntoViewSmart = (el) => {
    if (!el) return;
    const behavior = prefersReducedMotion() ? "auto" : "smooth";
    try {
      el.scrollIntoView({ behavior, block: "start" });
    } catch {
      el.scrollIntoView(true);
    }
  };

  /* =========================================================
   * 1) Toasts (premium micro-feel, ARIA-safe)
   * =======================================================*/
  const toastHost = () => qs('[data-ff-toasts]');
  const toast = (msg, kind = "info") => {
    const host = toastHost();
    if (!host) return;
    const t = document.createElement("div");
    t.className = `ff-toast ff-toast--${kind}`;
    t.setAttribute("role", "status");
    t.setAttribute("aria-live", "polite");
    t.innerHTML = `<div class="ff-kicker">${escapeHTML(kind)}</div><div class="ff-help">${escapeHTML(msg)}</div>`;
    host.appendChild(t);

    requestAnimationFrame(() => {
      t.style.opacity = "1";
      t.style.transform = "translateY(0)";
    });

    setTimeout(() => {
      t.style.opacity = "0";
      t.style.transform = "translateY(-2px)";
    }, 2400);

    setTimeout(() => {
      try {
        host.removeChild(t);
      } catch {}
    }, 2900);
  };

  /* =========================================================
   * 2) Analytics bridge (gtag/dataLayer/plausible-safe)
   * =======================================================*/
  const track = (event, props = {}) => {
    const payload = { event, ...props, ts: new Date().toISOString() };

    // dataLayer
    try {
      if (Array.isArray(window.dataLayer)) window.dataLayer.push(payload);
    } catch {}

    // gtag
    try {
      if (typeof window.gtag === "function") window.gtag("event", event, props);
    } catch {}

    // plausible
    try {
      if (typeof window.plausible === "function") window.plausible(event, { props });
    } catch {}

    // optional debug
    if (document.documentElement.getAttribute("data-ff-debug") === "true") {
      try {
        // eslint-disable-next-line no-console
        console.log("[FF]", payload);
      } catch {}
    }
  };

  /* =========================================================
   * 3) Config & environment (deep-merge + normalization)
   * =======================================================*/
  const deepMerge = (a, b) => {
    if (!b || typeof b !== "object") return a;
    const out = Array.isArray(a) ? [...a] : { ...a };
    for (const [k, v] of Object.entries(b)) {
      const o = out[k];
      if (v && typeof v === "object" && !Array.isArray(v) && o && typeof o === "object" && !Array.isArray(o)) out[k] = deepMerge(o, v);
      else out[k] = v;
    }
    return out;
  };

  const shell = qs("[data-ff-shell]");
  const shellEnv = {
    tier: shell?.getAttribute("data-ff-tier") || "standard",
    orgId: shell?.getAttribute("data-ff-org") || "default",
    campaignId: shell?.getAttribute("data-ff-campaign") || "season",
    env: shell?.getAttribute("data-ff-env") || "prod",
    embed: shell?.getAttribute("data-ff-embed") === "true",
    whiteLabel: shell?.getAttribute("data-ff-whitelabel") === "true",
    version: shell?.getAttribute("data-ff-version") || "12.0.0",
  };

  const cfgEl = qs("#ffConfig");
  const cfg = cfgEl ? parseJSON(cfgEl.textContent || "{}", {}) : {};

  /* =========================================================
   * Gallery config (correct v2 shape)
   * - Put this inside #ffConfig JSON:
   *   "gallery": {
   *     "enabled": true,
   *     "title": "Season Highlights",
   *     "items": [
   *       { "id":"g1", "src":"https://.../full.jpg", "thumb":"https://.../thumb.jpg", "alt":"Team photo", "caption":"Opening night", "tag":"events" }
   *     ]
   *   }
   * =======================================================*/
  const DEFAULTS = {
    org: {
      name: "Organization",
      meta: "City • State",
      seasonPill: "Season Fund",
      sportPill: "Youth program",
      heroAccentLine: "Keep kids playing.",
      footerTagline: "Fuel the season. Fund the future.",
      announcement: "",
    },
    fundraiser: {
      goalAmount: 25000,
      deadlineISO: "",
      raisedAmount: null, // if null, derive from teams/sponsors/gifts
      updatedISO: "",
      match: null, // { active:true, multiplier:1, remaining:5000, endsISO:"..." }
      allocation: [
        { label: "Gym time + training", pct: 35 },
        { label: "Tournaments + fees", pct: 30 },
        { label: "Travel support", pct: 25 },
        { label: "Scholarships", pct: 10 },
      ],
      impact: [],
      sponsorTiers: [],
      sponsors: [],
      recentGifts: [],
      popularAmountCents: 7500,
    },
    teams: [],
    gallery: {
      enabled: false,
      title: "Gallery",
      items: [],
      featuredFirst: true,
      shareParam: "g",
    },
    flagship: {
      version: "12.0.0",
      features: {
        pwa: false,
        shareAttribution: true,
        monthlyGivingPlaceholder: true,
        formAutosave: true,
        gallery: true,
      },
      defaults: {
        currency: "USD",
        locale: "en-US",
        timezone: "America/Chicago",
      },
      analytics: {
        utm: { enabled: true, sourceParam: "src", campaignParam: "cmp" },
      },
      accessibility: {
        reducedMotionRespect: true,
        focusRestore: true,
      },
    },
  };

  const C = deepMerge(DEFAULTS, cfg);

  // normalize cents for tiers/impact
  C.fundraiser.sponsorTiers = (C.fundraiser.sponsorTiers || []).map((t) => ({
    ...t,
    amountCents: t.amountCents ?? (toInt(t.amount, 0) * 100),
  }));
  C.fundraiser.impact = (C.fundraiser.impact || []).map((x) => ({
    ...x,
    amountCents: x.amountCents ?? (toInt(x.amount, 0) * 100),
  }));

  const locale = pick(C, "flagship.defaults.locale", "en-US");
  const currency = pick(C, "flagship.defaults.currency", "USD");

  // endpoints / keys
  const stripePk = meta("ff-stripe-pk");
  const checkoutEndpoint = meta("ff-checkout-endpoint") || "/payments/stripe/intent";
  const csrfToken = meta("csrf-token");
  const qrEndpoint = meta("ff-qr-endpoint") || "https://api.qrserver.com/v1/create-qr-code/";

  const paypalClientId = meta("ff-paypal-client-id");
  const paypalCurrency = meta("ff-paypal-currency") || currency;
  const paypalIntent = meta("ff-paypal-intent") || "capture";
  const paypalCreateEndpoint = meta("ff-paypal-create-endpoint") || "/payments/paypal/order";
  const paypalCaptureEndpoint = meta("ff-paypal-capture-endpoint") || "/payments/paypal/capture";

  const captureMode = document.documentElement.getAttribute("data-ff-capture") === "true";

  /* =========================================================
   * 4) State (single source of truth)
   * =======================================================*/
  const S = {
    org: {
      name: safeText(C.org?.name || DEFAULTS.org.name),
      meta: safeText(C.org?.meta || DEFAULTS.org.meta),
      seasonPill: safeText(C.org?.seasonPill || DEFAULTS.org.seasonPill),
      sportPill: safeText(C.org?.sportPill || DEFAULTS.org.sportPill),
      heroAccentLine: safeText(C.org?.heroAccentLine || DEFAULTS.org.heroAccentLine),
      footerTagline: safeText(C.org?.footerTagline || DEFAULTS.org.footerTagline),
    },
    fundraiser: {
      goalCents: toInt(pick(C, "fundraiser.goalAmount", 0), 0) * 100,
      deadlineISO: safeText(pick(C, "fundraiser.deadlineISO", "")),
      updatedISO: safeText(pick(C, "fundraiser.updatedISO", "")),
      match: pick(C, "fundraiser.match", null),
      allocation: Array.isArray(pick(C, "fundraiser.allocation", null)) ? C.fundraiser.allocation : DEFAULTS.fundraiser.allocation,
      impact: Array.isArray(pick(C, "fundraiser.impact", null)) ? C.fundraiser.impact : [],
      sponsorTiers: Array.isArray(pick(C, "fundraiser.sponsorTiers", null)) ? C.fundraiser.sponsorTiers : [],
      sponsors: Array.isArray(pick(C, "fundraiser.sponsors", null)) ? C.fundraiser.sponsors : [],
      recentGifts: Array.isArray(pick(C, "fundraiser.recentGifts", null)) ? C.fundraiser.recentGifts : [],
      popularAmountCents: toInt(pick(C, "fundraiser.popularAmountCents", DEFAULTS.fundraiser.popularAmountCents), DEFAULTS.fundraiser.popularAmountCents),
      raisedCents: null,
    },
    teams: Array.isArray(C.teams) ? C.teams.slice() : [],
    gallery: {
      enabled: !!pick(C, "gallery.enabled", false) && !!pick(C, "flagship.features.gallery", true),
      title: safeText(pick(C, "gallery.title", "Gallery")),
      items: Array.isArray(pick(C, "gallery.items", null)) ? C.gallery.items : [],
      featuredFirst: !!pick(C, "gallery.featuredFirst", true),
      shareParam: safeText(pick(C, "gallery.shareParam", "g")) || "g",
      filter: "all",
      query: "",
      openId: "",
    },
    ui: {
      impactFilter: "all",
      impactQuery: "",
      sponsorSort: "rank",
      teamSort: "featured",
      teamQuery: "",
      selectedTeamId: null,
      selectedTeamName: "",
      giftType: "one-time",
      purpose: "donation", // donation|sponsorship|membership|impact
      sku: "",
      impactId: "",
      recognition: "public",
      stripeReady: false,
      stripeBusy: false,
      paypalReady: false,
      paypalVisible: false,
      lastIntentKey: "",
      clientSecret: "",
      elements: null,
      stripe: null,
      paymentElement: null,
      payMounted: false,
    },
    utm: {},
  };

  /* =========================================================
   * 5) DOM cache (existing IDs/attrs + optional Gallery hooks)
   * =======================================================*/
  const D = {
    // Branding
    orgName: qs("#orgName"),
    orgMeta: qs("#orgMeta"),
    footerOrgName: qs("#footerOrgName"),
    footerOrgMeta: qs("#footerOrgMeta"),
    orgPill: qs("#orgPill"),
    seasonPill: qs("#seasonPill"),
    sportPill: qs("#sportPill"),
    heroAccentLine: qs("#heroAccentLine"),

    // Progress
    raisedBig: qs("#raisedBig"),
    raisedRow: qs("#raisedRow"),
    goalRow: qs("#goalRow"),
    goalPill: qs("#goalPill"),
    remainingText: qs("#remainingText"),
    deadlineText: qs("#deadlineText"),
    pctText: qs("#pctText"),
    overallBar: qs("#overallBar"),
    lastUpdatedInline: qs("#lastUpdatedInline"),
    lastUpdatedText: qs("#lastUpdatedText"),
    lastUpdatedPill: qs("#lastUpdatedPill"),
    countdownPill: qs("#countdownPill"),

    // Match
    matchPill: qs("#matchPill"),
    heroMatchPill: qs("#heroMatchPill"),
    matchDetailRow: qs("#matchDetailRow"),
    matchRemainingPill: qs("#matchRemainingPill"),
    matchEndsPill: qs("#matchEndsPill"),
    matchStatus: qs("#matchStatus"),
    sponsorMatchPill: qs("[data-ff-sponsor-match-pill]"),

    // QR
    qrImgs: qsa("[data-ff-qr]"),
    downloadQrBtns: qsa("[data-ff-download-qr]"),

    // Recent gifts
    recentGiftsHost: qs("[data-ff-recent-gifts]"),
    refreshBtns: qsa("[data-ff-refresh]"),

    // Impact
    impactGrid: qs("[data-ff-impact-grid]"),
    impactEmpty: qs("[data-ff-impact-empty]"),
    impactSearch: qs("[data-ff-impact-search]"),
    impactFilterBtns: qsa("[data-ff-impact-filter]"),
    allocationList: qs("[data-ff-allocation-list]"),
    allocationUpdated: qs("[data-ff-allocation-updated]"),
    allocationUpdatedText: qs("[data-ff-allocation-updated-text]"),

    // Sponsors
    sponsorTiersHost: qs("[data-ff-sponsor-tiers]"),
    sponsorPodium: qs("[data-ff-sponsor-podium]"),
    sponsorList: qs("[data-ff-sponsor-leaderboard]"),
    sponsorSortBtns: qsa("[data-ff-sponsor-sort] [data-ff-sort]"),
    sponsorWall: qs("[data-ff-sponsor-wall]"),
    sponsorWallViewBtns: qsa("[data-ff-sponsor-wall-view] [data-ff-wall]"),
    refreshSponsorsBtn: qs("[data-ff-refresh-sponsors]"),

    // Teams
    teamsGrid: qs("[data-ff-teams-grid]"),
    teamsStatus: qs("[data-ff-teams-status]"),
    teamSearch: qs("[data-ff-team-search]"),
    teamSortBtns: qsa("[data-ff-team-sort] [data-ff-sort]"),
    selectedTeamPill: qs("[data-ff-selected-team-pill]"),
    attribBox: qs("[data-ff-attrib-box]"),
    attribTitle: qs("[data-ff-attrib-title]"),
    attribHelp: qs("[data-ff-attrib-help]"),
    attribClearBtns: qsa("[data-ff-attrib-clear]"),
    summaryTeamRow: qs("#summaryTeamRow"),
    summaryTeam: qs("#summaryTeam"),

    // Donate
    donationForm: qs("#donationForm"),
    amount: qs("#amount"),
    email: qs("#email"),
    fullName: qs("#fullName"),
    message: qs("#message"),
    anonymous: qs("#anonymous"),
    coverFees: qs("#coverFees"),
    payBtn: qs("#payBtn"),
    payError: qs("#payError"),
    payErrorText: qs("#payErrorText"),
    paySuccess: qs("#paySuccess"),
    paySuccessText: qs("#paySuccessText"),
    summaryAmount: qs("#summaryAmount"),
    summaryFees: qs("#summaryFees"),
    summaryTotal: qs("#summaryTotal"),
    receiptEmail: qs("#receiptEmail"),
    checkoutStatusText: qs("#checkoutStatusText"),
    checkoutMethodPill: qs("#checkoutMethodPill"),
    checkoutMethodText: qs("#checkoutMethodText"),
    paymentElementHost: qs("#paymentElement"),
    paypalMount: qs("#paypalMount"),
    paypalButtonsHost: qs("#paypalButtons"),
    paymentLive: qs("[data-ff-payment-live]"),

    // Recognition
    recognitionBtns: qsa("[data-ff-recognition]"),
    recognitionPreviewText: qs("#recognitionPreviewText"),

    // Chips / Prefills
    quickAmountBtns: qsa("[data-ff-quick-amount]"),
    clearAmountBtn: qs("[data-ff-clear-amount]"),
    popularAmountPill: qs("[data-ff-popular-amount]"),
    popularAmountText: qs("#popularAmountText"),
    prefills: qsa("[data-ff-prefill]"),
    giftTypeBtns: qsa("[data-ff-gift-type]"),

    // Share / proof
    shareLink: qs("#shareLink"),
    proofDonorName: qs("#proofDonorName"),
    proofAmount: qs("#proofAmount"),
    proofCampaign: qs("#proofCampaign"),
    copyCaptionBtn: qs("[data-ff-copy-caption]"),
    proofCaption: qs("#proofCaption"),

    // Announcement
    announce: qs("[data-ff-announcement]"),
    announcementText: qs("#announcementText"),

    // Misc
    trustChips: qsa("[data-ff-trust-chip]"),

    // Gallery (optional hooks — safe if not present)
    gallerySection: qs("[data-ff-gallery]") || qs("#gallery"),
    galleryTitle: qs("[data-ff-gallery-title]") || qs("#galleryTitle"),
    galleryGrid: qs("[data-ff-gallery-grid]") || qs("#galleryGrid"),
    galleryEmpty: qs("[data-ff-gallery-empty]") || qs("#galleryEmpty"),
    gallerySearch: qs("[data-ff-gallery-search]") || qs("#gallerySearch"),
    galleryFilterBtns: qsa("[data-ff-gallery-filter]"),
  };

  /* =========================================================
   * 6) Attribution / UTM + share URL + QR
   * =======================================================*/
  const attribKey = () => `ff_attrib_${shellEnv.orgId}_${shellEnv.campaignId}`;
  const readUtm = () => {
    const url = new URL(window.location.href);
    const p = url.searchParams;

    const utm = {};
    for (const k of ["utm_source", "utm_medium", "utm_campaign", "utm_content", "utm_term"]) if (p.has(k)) utm[k] = p.get(k) || "";

    const srcParam = pick(C, "flagship.analytics.utm.sourceParam", "src");
    const cmpParam = pick(C, "flagship.analytics.utm.campaignParam", "cmp");
    if (p.has(srcParam)) utm[srcParam] = p.get(srcParam) || "";
    if (p.has(cmpParam)) utm[cmpParam] = p.get(cmpParam) || "";

    const teamId = p.get("team") || p.get("t") || "";
    if (teamId) utm.team = teamId;

    try {
      const ref = document.referrer || "";
      if (ref) utm.referrer = ref;
    } catch {}

    S.utm = utm;

    // restore persisted attribution if URL has none (privacy-respectful)
    try {
      if (!utm.team) {
        const saved = parseJSON(localStorage.getItem(attribKey()) || "null", null);
        const priorTeam = saved?.utm?.team || "";
        if (priorTeam) utm.team = priorTeam;
      }
    } catch {}

    if (utm.team) setSelectedTeam(utm.team, { silent: true });

    try {
      localStorage.setItem(attribKey(), JSON.stringify({ ts: new Date().toISOString(), utm }));
    } catch {}
  };

  const buildShareUrl = () => {
    const url = new URL(window.location.href);

    // strip transient checkout params
    for (const k of ["payment_intent", "payment_intent_client_secret", "redirect_status"]) url.searchParams.delete(k);

    // team attribution
    if (pick(C, "flagship.features.shareAttribution", true) && S.ui.selectedTeamId) url.searchParams.set("team", S.ui.selectedTeamId);
    else url.searchParams.delete("team");

    // gallery deep-link (if open)
    if (S.gallery.openId) url.searchParams.set(S.gallery.shareParam, S.gallery.openId);
    else url.searchParams.delete(S.gallery.shareParam);

    // keep custom src/cmp if present in S.utm
    const srcParam = pick(C, "flagship.analytics.utm.sourceParam", "src");
    const cmpParam = pick(C, "flagship.analytics.utm.campaignParam", "cmp");
    if (S.utm[srcParam] && !url.searchParams.get(srcParam)) url.searchParams.set(srcParam, S.utm[srcParam]);
    if (S.utm[cmpParam] && !url.searchParams.get(cmpParam)) url.searchParams.set(cmpParam, S.utm[cmpParam]);

    return url.toString();
  };

  const buildQrSrc = (dataUrl, size = 180) => {
    const ep = qrEndpoint;
    const u = new URL(ep, window.location.origin);
    if (ep.includes("?")) return ep + (ep.endsWith("&") || ep.endsWith("?") ? "" : "&") + `size=${size}x${size}&data=${encodeURIComponent(dataUrl)}`;
    u.searchParams.set("size", `${size}x${size}`);
    u.searchParams.set("data", dataUrl);
    return u.toString();
  };

  const setShareFields = () => {
    const url = buildShareUrl();
    if (D.shareLink) D.shareLink.value = url;
    const src = buildQrSrc(url, 180);
    for (const img of D.qrImgs) if (img && img.getAttribute("src") !== src) img.setAttribute("src", src);
  };

  /* =========================================================
   * 7) Brand + announcement
   * =======================================================*/
  const applyBrand = () => {
    const name = S.org.name;
    const metaText = S.org.meta;

    if (D.orgName) D.orgName.textContent = name;
    if (D.orgMeta) D.orgMeta.textContent = metaText;
    if (D.footerOrgName) D.footerOrgName.textContent = name;
    if (D.footerOrgMeta) D.footerOrgMeta.textContent = metaText;

    if (D.orgPill) D.orgPill.textContent = "Fundraiser";
    if (D.seasonPill) D.seasonPill.textContent = S.org.seasonPill;
    if (D.sportPill) D.sportPill.textContent = S.org.sportPill;
    if (D.heroAccentLine) D.heroAccentLine.textContent = S.org.heroAccentLine;

    const heroOrgLine = qs("#heroOrgLine");
    if (heroOrgLine) heroOrgLine.textContent = `${name} • Fundraiser`;
  };

  const applyAnnouncement = () => {
    const ann = pick(C, "org.announcement", "") || pick(C, "fundraiser.announcement", "");
    if (!D.announce || !D.announcementText) return;
    if (!ann) return setHidden(D.announce, true);

    // dismissal persistence
    const dismissKey = `ff_announce_dismiss_${shellEnv.orgId}_${shellEnv.campaignId}`;
    try {
      if (localStorage.getItem(dismissKey)) return setHidden(D.announce, true);
    } catch {}

    D.announcementText.textContent = safeText(ann);
    setHidden(D.announce, false);

    const dismiss = qs("[data-ff-announcement-dismiss]");
    if (dismiss && !dismiss.__ff_bound) {
      dismiss.__ff_bound = true;
      on(dismiss, "click", () => {
        setHidden(D.announce, true);
        try {
          localStorage.setItem(dismissKey, String(now()));
        } catch {}
      });
    }
  };

  /* =========================================================
   * 8) Fundraising math + progress UI
   * =======================================================*/
  const parseISO = (iso) => {
    if (!iso) return null;
    const d = new Date(iso);
    return Number.isFinite(d.getTime()) ? d : null;
  };

  const deriveRaisedCents = () => {
    const explicit = pick(C, "fundraiser.raisedAmount", null);
    if (explicit != null) return toInt(explicit, 0) * 100;

    if (Array.isArray(S.teams) && S.teams.length) {
      let sum = 0;
      for (const t of S.teams) sum += toInt(t.raised, 0) * 100;
      return sum;
    }

    let sum = 0;
    for (const s of S.fundraiser.sponsors || []) sum += toInt(s.amountCents ?? (toInt(s.amount, 0) * 100), 0);
    for (const g of S.fundraiser.recentGifts || []) sum += toInt(g.amountCents ?? (toInt(g.amount, 0) * 100), 0);
    return sum;
  };

  const setProgressUI = () => {
    const raised = toInt(S.fundraiser.raisedCents, 0);
    const goal = toInt(S.fundraiser.goalCents, 0);
    const pct = goal > 0 ? clamp(Math.round((raised / goal) * 100), 0, 999) : 0;
    const remaining = Math.max(0, goal - raised);

    const raisedTxt = formatCurrency(raised, currency, locale);
    const goalTxt = formatCurrency(goal, currency, locale);

    if (D.raisedBig) D.raisedBig.textContent = raisedTxt;
    if (D.raisedRow) D.raisedRow.textContent = raisedTxt;
    if (D.goalRow) D.goalRow.textContent = goalTxt;
    if (D.goalPill) D.goalPill.textContent = goalTxt;

    if (D.remainingText) D.remainingText.textContent = formatCurrency(remaining, currency, locale);
    if (D.pctText) D.pctText.textContent = String(pct);

    if (D.overallBar) {
      D.overallBar.style.width = `${clamp((goal > 0 ? (raised / goal) * 100 : 0), 0, 100).toFixed(2)}%`;
      const meter = qs('[data-ff-meter="overall"]');
      if (meter) {
        meter.setAttribute("aria-valuenow", String(clamp(pct, 0, 100)));
        meter.setAttribute("aria-valuetext", `${clamp(pct, 0, 100)}% funded`);
      }
    }
  };

  /* =========================================================
   * 9) Deadline + countdown + staleness pill
   * =======================================================*/
  const humanCountdown = (ms) => {
    const s = Math.max(0, Math.floor(ms / 1000));
    const d = Math.floor(s / 86400);
    const h = Math.floor((s % 86400) / 3600);
    const m = Math.floor((s % 3600) / 60);

    if (d >= 7) return `${d}d`;
    if (d > 0) return `${d}d ${h}h`;
    if (h > 0) return `${h}h ${m}m`;
    if (m > 0) return `${m}m`;
    return `soon`;
  };

  let countdownTimer = null;

  const startDeadlineLoop = () => {
    const deadline = parseISO(S.fundraiser.deadlineISO);

    if (D.deadlineText) {
      if (!deadline) D.deadlineText.textContent = "No deadline";
      else {
        try {
          D.deadlineText.textContent = deadline.toLocaleDateString(locale, { month: "short", day: "numeric", year: "numeric" });
        } catch {
          D.deadlineText.textContent = deadline.toISOString().slice(0, 10);
        }
      }
    }

    if (!deadline || !D.countdownPill) return;

    const tick = () => {
      const ms = deadline.getTime() - now();
      const near = ms > 0 && ms <= 1000 * 60 * 60 * 24 * 10;

      if (ms <= 0) {
        D.countdownPill.hidden = false;
        D.countdownPill.textContent = "Ended";
        return;
      }

      if (near) {
        D.countdownPill.hidden = false;
        D.countdownPill.textContent = `Ends in ${humanCountdown(ms)}`;
      } else {
        D.countdownPill.hidden = true;
      }
    };

    tick();
    clearInterval(countdownTimer);
    countdownTimer = setInterval(tick, 15000);
  };

  const applyUpdated = () => {
    const d = parseISO(S.fundraiser.updatedISO) || new Date();
    let label = "just now";

    try {
      const mins = Math.max(0, Math.round((now() - d.getTime()) / 60000));
      if (mins < 2) label = "just now";
      else if (mins < 60) label = `${mins}m ago`;
      else {
        const hrs = Math.round(mins / 60);
        label = hrs < 24 ? `${hrs}h ago` : d.toLocaleDateString(locale, { month: "short", day: "numeric" });
      }

      if (D.lastUpdatedPill) D.lastUpdatedPill.dataset.status = mins > 180 ? "stale" : "fresh";
    } catch {
      label = d.toISOString().slice(0, 10);
    }

    if (D.lastUpdatedInline) D.lastUpdatedInline.textContent = label;
    if (D.lastUpdatedText) D.lastUpdatedText.textContent = `Updated — ${label}`;
    if (D.lastUpdatedPill) {
      const num = qs(".ff-num", D.lastUpdatedPill);
      if (num) num.textContent = label;
    }
  };

  /* =========================================================
   * 10) Match UI
   * =======================================================*/
  const applyMatch = () => {
    const m = S.fundraiser.match;
    const isActive = !!m?.active;

    if (D.matchPill) D.matchPill.hidden = !isActive;
    if (D.heroMatchPill) D.heroMatchPill.hidden = !isActive;
    if (D.sponsorMatchPill) D.sponsorMatchPill.hidden = !isActive;
    if (D.matchDetailRow) D.matchDetailRow.hidden = !isActive;

    if (D.matchStatus) D.matchStatus.textContent = isActive ? "On" : "Off";
    if (!isActive) return;

    const remainingCents = toInt(m.remainingCents ?? (toInt(m.remaining, 0) * 100), 0);
    const ends = parseISO(m.endsISO || "");
    if (D.matchRemainingPill) D.matchRemainingPill.textContent = `Remaining ${formatCurrency(remainingCents, currency, locale)}`;
    if (D.matchEndsPill) D.matchEndsPill.textContent = ends ? `Ends ${humanCountdown(ends.getTime() - now())}` : "Ends —";
  };

  /* =========================================================
   * 11) Allocation
   * =======================================================*/
  const renderAllocation = () => {
    if (!D.allocationList) return;
    const items = Array.isArray(S.fundraiser.allocation) ? S.fundraiser.allocation : [];
    if (!items.length) {
      D.allocationList.innerHTML = `<div class="ff-help">Allocation coming soon.</div>`;
      return;
    }

    const total = items.reduce((a, x) => a + toNum(x.pct, 0), 0) || 100;
    D.allocationList.innerHTML = items
      .map((x) => {
        const pct = clamp(Math.round((toNum(x.pct, 0) / total) * 100), 0, 100);
        return `<div class="ff-slimitem"><span class="ff-help">${escapeHTML(safeText(x.label || ""))}</span><strong class="ff-help ff-num">${pct}%</strong></div>`;
      })
      .join("");

    const upd = pick(C, "fundraiser.allocationUpdatedISO", "") || pick(C, "fundraiser.updatedISO", "");
    if (D.allocationUpdated && D.allocationUpdatedText) {
      if (!upd) return (D.allocationUpdated.hidden = true);
      D.allocationUpdated.hidden = false;
      const d = parseISO(upd);
      D.allocationUpdatedText.textContent = d ? d.toLocaleDateString(locale, { month: "short", day: "numeric" }) : safeText(upd);
    }
  };

  /* =========================================================
   * 12) Impact grid
   * =======================================================*/
  const impactCats = new Set(["gear", "travel", "fees", "scholarship"]);

  const normalizeImpactList = () => {
    const items = Array.isArray(S.fundraiser.impact) ? S.fundraiser.impact : [];
    return items
      .filter((x) => x && x.id && x.title)
      .map((x) => ({
        id: safeText(x.id),
        cat: impactCats.has(safeText(x.cat)) ? safeText(x.cat) : "gear",
        title: safeText(x.title),
        desc: safeText(x.desc || ""),
        amountCents: toInt(x.amountCents ?? (toInt(x.amount, 0) * 100), 0),
      }));
  };

  const scrollToDonate = () => {
    const el = qs("#donate");
    if (!el) return;
    scrollIntoViewSmart(el);
    setTimeout(() => D.amount?.focus?.(), 160);
  };

  const setAmountInput = (cents) => {
    const dollars = Math.round(toInt(cents, 0) / 100);
    if (!D.amount) return;
    D.amount.value = dollars > 0 ? String(dollars) : "";
    D.amount.dispatchEvent(new Event("input", { bubbles: true }));
  };

  const setPrefill = ({ amountCents, purpose = "donation", sku = "", impactId = "" }) => {
    if (amountCents != null) setAmountInput(amountCents);
    S.ui.purpose = purpose;
    S.ui.sku = sku;
    S.ui.impactId = impactId || "";

    if (D.proofAmount) D.proofAmount.textContent = formatCurrency(amountCents || 0, currency, locale);

    track("prefill", { purpose, sku: sku || "", impact_id: impactId || "", amount_cents: toInt(amountCents, 0) });
  };

  const renderImpact = () => {
    if (!D.impactGrid) return;

    const items = normalizeImpactList();
    const filter = S.ui.impactFilter;
    const q = safeText(S.ui.impactQuery).trim().toLowerCase();

    const filtered = items.filter((x) => {
      if (filter !== "all" && x.cat !== filter) return false;
      if (!q) return true;
      return (x.title + " " + x.desc + " " + x.cat).toLowerCase().includes(q);
    });

    if (!filtered.length) {
      setHidden(D.impactEmpty, false);
      D.impactGrid.innerHTML = "";
      return;
    }
    setHidden(D.impactEmpty, true);

    D.impactGrid.innerHTML = filtered
      .map((x) => {
        const amt = formatCurrency(x.amountCents, currency, locale);
        return `
          <article class="ff-mini" role="listitem" tabindex="0"
            data-ff-impact-item data-impact-id="${escapeHTML(x.id)}" aria-label="${escapeHTML(x.title)}">
            <div class="ff-row ff-row--between ff-ais">
              <div style="min-width:0">
                <div class="ff-kicker">${escapeHTML(x.cat.toUpperCase())}</div>
                <div class="ff-card__title">${escapeHTML(x.title)}</div>
                <p class="ff-help" style="margin-top:6px">${escapeHTML(x.desc)}</p>
              </div>
              <span class="ff-pill ff-pill--accent">${escapeHTML(amt)}</span>
            </div>
            <div class="ff-row ff-wrap" style="margin-top:10px" role="group" aria-label="Actions">
              <button class="ff-btn ff-btn--primary ff-btn--sm" type="button"
                data-ff-impact-cta data-impact-id="${escapeHTML(x.id)}" data-impact-cents="${escapeHTML(String(x.amountCents))}">
                Prefill ${escapeHTML(amt)}
              </button>
              <button class="ff-btn ff-btn--ghost ff-btn--sm" type="button" data-ff-impact-share data-impact-id="${escapeHTML(x.id)}">
                Share need
              </button>
            </div>
          </article>
        `;
      })
      .join("");

    // keybind on card
    qsa("[data-ff-impact-item]", D.impactGrid).forEach((el) => {
      if (el.__ff_bound) return;
      el.__ff_bound = true;
      on(el, "keydown", (e) => {
        if (e.key !== "Enter" && e.key !== " ") return;
        e.preventDefault();
        const id = el.getAttribute("data-impact-id") || "";
        const item = items.find((x) => x.id === id);
        if (!item) return;
        setPrefill({ amountCents: item.amountCents, purpose: "impact", impactId: id });
        scrollToDonate();
        toast("Checkout prefilled.", "success");
      });
    });

    qsa("[data-ff-impact-cta]", D.impactGrid).forEach((btn) => {
      if (btn.__ff_bound) return;
      btn.__ff_bound = true;
      on(btn, "click", () => {
        const cents = toInt(btn.getAttribute("data-impact-cents"), 0);
        const id = btn.getAttribute("data-impact-id") || "";
        setPrefill({ amountCents: cents, purpose: "impact", impactId: id });
        scrollToDonate();
        toast("Checkout prefilled.", "success");
      });
    });

    qsa("[data-ff-impact-share]", D.impactGrid).forEach((btn) => {
      if (btn.__ff_bound) return;
      btn.__ff_bound = true;
      on(btn, "click", async () => {
        const id = btn.getAttribute("data-impact-id") || "";
        const url = new URL(buildShareUrl());
        url.searchParams.set("need", id);

        const shareData = { title: document.title, text: "Support this specific need.", url: url.toString() };
        try {
          if (navigator.share) {
            await navigator.share(shareData);
            toast("Shared.", "success");
            track("share", { kind: "impact", id });
            return;
          }
        } catch {}

        try {
          await navigator.clipboard.writeText(url.toString());
          toast("Need link copied.", "success");
          track("share_copy", { kind: "impact", id });
        } catch {
          toast("Copy failed. Use Share dialog.", "error");
        }
      });
    });
  };

  const bindImpactControls = () => {
    if (D.impactSearch && !D.impactSearch.__ff_bound) {
      D.impactSearch.__ff_bound = true;
      on(
        D.impactSearch,
        "input",
        debounce(() => {
          S.ui.impactQuery = D.impactSearch.value || "";
          renderImpact();
        }, 120)
      );
    }

    for (const btn of D.impactFilterBtns) {
      if (btn.__ff_bound) continue;
      btn.__ff_bound = true;
      on(btn, "click", () => {
        const f = btn.getAttribute("data-ff-impact-filter") || "all";
        S.ui.impactFilter = f;
        for (const b of D.impactFilterBtns) b.classList.toggle("is-selected", b === btn);
        for (const b of D.impactFilterBtns) setAriaPressed(b, b === btn);
        renderImpact();
      });
    }
  };

  /* =========================================================
   * 13) Sponsors
   * =======================================================*/
  const sponsorBadge = (name) => {
    const initials = safeText(name)
      .split(/\s+/)
      .filter(Boolean)
      .slice(0, 2)
      .map((p) => p[0].toUpperCase())
      .join("");
    return initials || "S";
  };

  const normalizeSponsors = () => {
    const raw = Array.isArray(S.fundraiser.sponsors) ? S.fundraiser.sponsors : [];
    return raw
      .map((s) => ({
        name: safeText(s.name || "Sponsor"),
        amountCents: toInt(s.amountCents ?? (toInt(s.amount, 0) * 100), 0),
        logo: safeText(s.logo || ""),
        url: safeText(s.url || ""),
        ts: parseISO(s.tsISO || s.timestamp || "")?.getTime() || 0,
      }))
      .filter((x) => x.amountCents > 0)
      .sort((a, b) => b.amountCents - a.amountCents);
  };

  const renderSponsorTiers = () => {
    if (!D.sponsorTiersHost) return;
    const tiers = Array.isArray(S.fundraiser.sponsorTiers) ? S.fundraiser.sponsorTiers : [];

    if (!tiers.length) {
      D.sponsorTiersHost.innerHTML = `<li class="ff-mini"><div class="ff-help">Sponsor tiers coming soon.</div></li>`;
      return;
    }

    D.sponsorTiersHost.innerHTML = tiers
      .map((t) => {
        const amt = formatCurrency(t.amountCents, currency, locale);
        const perk = safeText(t.perk || "Recognition on wall + leaderboard");
        return `
          <li class="ff-mini" role="listitem" aria-label="${escapeHTML(t.title)}">
            <div class="ff-row ff-row--between ff-ais">
              <div style="min-width:0">
                <div class="ff-kicker">Tier</div>
                <div class="ff-card__title">${escapeHTML(t.title)}</div>
                <p class="ff-help" style="margin-top:6px">${escapeHTML(perk)}</p>
              </div>
              <span class="ff-pill ff-pill--accent">${escapeHTML(amt)}</span>
            </div>
            <div class="ff-row ff-wrap" style="margin-top:10px" role="group" aria-label="Actions">
              <button class="ff-btn ff-btn--primary ff-btn--sm" type="button"
                data-ff-sponsor-cta data-ff-prefill-amount="${escapeHTML(String(Math.round(t.amountCents / 100)))}">
                Sponsor ${escapeHTML(amt)}
              </button>
            </div>
          </li>
        `;
      })
      .join("");

    bindSponsorPrefills(D.sponsorTiersHost);
  };

  const sponsorItem = (s, idx, compact = false) => {
    const amt = formatCurrency(s.amountCents, currency, locale);
    const label = escapeHTML(s.name);
    const badge = sponsorBadge(s.name);

    const left = s.logo
      ? `<img src="${escapeHTML(s.logo)}" alt="${label} logo" loading="lazy" decoding="async"
           style="width:44px;height:44px;border-radius:12px;object-fit:cover;border:1px solid var(--ff-border)" />`
      : `<div aria-hidden="true"
           style="width:44px;height:44px;border-radius:12px;display:grid;place-items:center;border:1px solid var(--ff-border);
                  background:color-mix(in oklab,var(--ff-control-bg) 80%,transparent);font-weight:700">${escapeHTML(badge)}</div>`;

    const right = compact ? `<span class="ff-pill ff-pill--accent">${escapeHTML(amt)}</span>` : `<strong class="ff-help ff-num">${escapeHTML(amt)}</strong>`;

    const content = `
      <div class="ff-row ff-row--between ff-ais" style="gap:12px">
        <div class="ff-row ff-ais" style="gap:12px;min-width:0">
          ${left}
          <div style="min-width:0">
            <div class="ff-kicker">${compact ? `Rank #${idx + 1}` : "Sponsor"}</div>
            <div class="ff-card__title" style="white-space:nowrap;overflow:hidden;text-overflow:ellipsis;max-width:420px">${label}</div>
          </div>
        </div>
        ${right}
      </div>
    `;

    if (s.url) return `<li class="ff-mini" role="listitem"><a href="${escapeHTML(s.url)}" target="_blank" rel="noopener noreferrer" style="text-decoration:none;color:inherit;display:block">${content}</a></li>`;
    return `<li class="ff-mini" role="listitem">${content}</li>`;
  };

  const renderSponsorWall = (byRank) => {
    if (!D.sponsorWall) return;
    const viewBtn = qsa("[data-ff-sponsor-wall-view] [data-ff-wall]").find((b) => b.classList.contains("is-selected"));
    const mode = viewBtn?.getAttribute("data-ff-wall") || "logos";

    const sponsors = Array.isArray(byRank) ? byRank : normalizeSponsors();
    if (!sponsors.length) {
      D.sponsorWall.innerHTML = `<div class="ff-mini"><div class="ff-help">Logos appear after successful payments.</div></div>`;
      return;
    }

    if (mode === "list") {
      D.sponsorWall.innerHTML = `<ol class="ff-stack" aria-label="Sponsor list">${sponsors.slice(0, 12).map((s, i) => sponsorItem(s, i, true)).join("")}</ol>`;
      return;
    }

    const tiles = sponsors.slice(0, 12).map((s) => {
      const label = escapeHTML(s.name);
      const badge = sponsorBadge(s.name);
      const body = s.logo
        ? `<img src="${escapeHTML(s.logo)}" alt="${label} logo" loading="lazy" decoding="async" style="width:100%;height:100%;object-fit:cover;border-radius:14px" />`
        : `<div aria-hidden="true" style="width:100%;height:100%;display:grid;place-items:center;font-weight:900;font-size:18px">${escapeHTML(badge)}</div>`;

      const inner = `
        <div class="ff-mini" style="padding:10px;display:grid;gap:8px;align-content:start">
          <div style="aspect-ratio:1/1;border-radius:14px;border:1px solid var(--ff-border);
                      background:color-mix(in oklab,var(--ff-control-bg) 80%,transparent);overflow:hidden">${body}</div>
          <div class="ff-help" style="white-space:nowrap;overflow:hidden;text-overflow:ellipsis">${label}</div>
        </div>
      `;
      return s.url
        ? `<a href="${escapeHTML(s.url)}" target="_blank" rel="noopener noreferrer" style="text-decoration:none;color:inherit">${inner}</a>`
        : `<div>${inner}</div>`;
    });

    D.sponsorWall.innerHTML = `<div class="ff-grid ff-grid--3" style="gap:12px">${tiles.join("")}</div>`;
  };

  const renderSponsorBoards = () => {
    const sponsors = normalizeSponsors();
    const sort = S.ui.sponsorSort;

    const byRank = sponsors.slice().sort((a, b) => b.amountCents - a.amountCents);
    const byRecent = sponsors.slice().sort((a, b) => (b.ts || 0) - (a.ts || 0) || b.amountCents - a.amountCents);
    const list = sort === "recent" ? byRecent : byRank;

    if (D.sponsorPodium) {
      const top3 = byRank.slice(0, 3);
      D.sponsorPodium.innerHTML = top3.length
        ? top3
            .map((s, i) => {
              const amt = formatCurrency(s.amountCents, currency, locale);
              const badge = sponsorBadge(s.name);
              return `
                <li style="list-style:none">
                  <div class="ff-mini" role="listitem" aria-label="Top sponsor ${escapeHTML(s.name)}">
                    <div class="ff-row ff-row--between ff-ais">
                      <div style="min-width:0">
                        <div class="ff-kicker">Top ${i + 1}</div>
                        <div class="ff-card__title" style="white-space:nowrap;overflow:hidden;text-overflow:ellipsis">${escapeHTML(s.name)}</div>
                        <p class="ff-help" style="margin-top:6px">VIP recognition • proof kit ready</p>
                      </div>
                      <div aria-hidden="true" style="width:44px;height:44px;border-radius:12px;display:grid;place-items:center;border:1px solid var(--ff-border);
                          background:color-mix(in oklab,var(--ff-control-bg) 80%,transparent);font-weight:800">${escapeHTML(badge)}</div>
                    </div>
                    <div class="ff-row ff-wrap" style="margin-top:10px"><span class="ff-pill ff-pill--accent">${escapeHTML(amt)}</span></div>
                  </div>
                </li>
              `;
            })
            .join("")
        : `<li style="list-style:none"><div class="ff-mini"><div class="ff-help">Be the first sponsor.</div></div></li>`;
    }

    if (D.sponsorList) {
      D.sponsorList.innerHTML = list.length
        ? list.map((s, i) => sponsorItem(s, i, true)).join("")
        : `<li class="ff-mini"><div class="ff-help">Sponsors appear here after successful payments.</div></li>`;
    }

    renderSponsorWall(byRank);
  };

  const bindSponsorPrefills = (root) => {
    qsa("[data-ff-sponsor-cta]", root).forEach((btn) => {
      if (btn.__ff_bound) return;
      btn.__ff_bound = true;
      on(btn, "click", () => {
        const amt = toInt(btn.getAttribute("data-ff-prefill-amount"), 0);
        if (amt <= 0) return;
        setPrefill({ amountCents: amt * 100, purpose: "sponsorship", sku: "sponsor" });
        scrollToDonate();
        toast("Sponsor amount prefilled.", "success");
      });
    });
  };

  const bindSponsorControls = () => {
    for (const btn of D.sponsorSortBtns) {
      if (btn.__ff_bound) continue;
      btn.__ff_bound = true;
      on(btn, "click", () => {
        S.ui.sponsorSort = btn.getAttribute("data-ff-sort") || "rank";
        for (const b of D.sponsorSortBtns) b.classList.toggle("is-selected", b === btn);
        for (const b of D.sponsorSortBtns) setAriaPressed(b, b === btn);
        renderSponsorBoards();
      });
    }

    for (const btn of D.sponsorWallViewBtns) {
      if (btn.__ff_bound) continue;
      btn.__ff_bound = true;
      on(btn, "click", () => {
        for (const b of D.sponsorWallViewBtns) b.classList.toggle("is-selected", b === btn);
        for (const b of D.sponsorWallViewBtns) setAriaPressed(b, b === btn);
        renderSponsorBoards();
      });
    }

    if (D.refreshSponsorsBtn && !D.refreshSponsorsBtn.__ff_bound) {
      D.refreshSponsorsBtn.__ff_bound = true;
      on(D.refreshSponsorsBtn, "click", () => {
        renderSponsorBoards();
        toast("Sponsor list refreshed.", "info");
        track("refresh", { kind: "sponsors" });
      });
    }

    bindSponsorPrefills(document);
  };

  /* =========================================================
   * 14) Teams
   * =======================================================*/
  const normalizeTeams = () => {
    const list = Array.isArray(S.teams) ? S.teams : [];
    return list
      .filter((t) => t && t.id && t.name)
      .map((t) => ({
        id: safeText(t.id),
        name: safeText(t.name),
        meta: safeText(t.meta || ""),
        goalCents: toInt(t.goal, 0) * 100,
        raisedCents: toInt(t.raised, 0) * 100,
        featured: !!t.featured,
        photo: safeText(t.photo || ""),
      }));
  };

  const teamProgressPct = (t) => (t.goalCents <= 0 ? 0 : clamp(Math.round((t.raisedCents / t.goalCents) * 100), 0, 999));

  const renderTeams = () => {
    if (!D.teamsGrid) return;

    const teams = normalizeTeams();
    const q = safeText(S.ui.teamQuery).trim().toLowerCase();
    const sort = S.ui.teamSort;

    let filtered = teams.filter((t) => (!q ? true : (t.name + " " + t.meta).toLowerCase().includes(q)));

    if (sort === "featured") filtered = filtered.sort((a, b) => Number(b.featured) - Number(a.featured) || teamProgressPct(b) - teamProgressPct(a));
    else if (sort === "goal") filtered = filtered.sort((a, b) => teamProgressPct(b) - teamProgressPct(a) || b.raisedCents - a.raisedCents);
    else if (sort === "recent") filtered = filtered.sort((a, b) => b.raisedCents - a.raisedCents);

    if (!filtered.length) {
      D.teamsGrid.innerHTML = `<div class="ff-mini"><div class="ff-kicker">No matches</div><div class="ff-card__title">Try a different search</div><p class="ff-help" style="margin-top:6px">Example: “7th”, “Gold”, “Black”.</p></div>`;
      if (D.teamsStatus) D.teamsStatus.textContent = "No teams match your search.";
      return;
    }

    const card = (t) => {
      const pct = teamProgressPct(t);
      const goal = formatCurrency(t.goalCents, currency, locale);
      const raised = formatCurrency(t.raisedCents, currency, locale);

      const media = t.photo
        ? `<img src="${escapeHTML(t.photo)}" alt="" loading="lazy" decoding="async" style="width:100%;height:100%;object-fit:cover;border-radius:14px" />`
        : `<div aria-hidden="true" style="width:100%;height:100%;display:grid;place-items:center;border-radius:14px;font-weight:900;font-size:18px;background:color-mix(in oklab,var(--ff-control-bg) 80%,transparent)">${escapeHTML(
            sponsorBadge(t.name)
          )}</div>`;

      const selected = S.ui.selectedTeamId === t.id;

      return `
        <article class="ff-mini" role="listitem" tabindex="0" data-ff-team-card data-team-id="${escapeHTML(t.id)}" aria-label="${escapeHTML(t.name)}">
          <div class="ff-grid ff-grid--2" style="grid-template-columns: 72px 1fr; gap:12px; align-items:start">
            <div style="width:72px;height:72px;border-radius:14px;overflow:hidden;border:1px solid var(--ff-border)">${media}</div>
            <div style="min-width:0">
              <div class="ff-row ff-row--between ff-ais" style="gap:12px">
                <div style="min-width:0">
                  <div class="ff-kicker">${escapeHTML(selected ? "Selected" : t.featured ? "Featured" : "Team")}</div>
                  <div class="ff-card__title" style="white-space:nowrap;overflow:hidden;text-overflow:ellipsis">${escapeHTML(t.name)}</div>
                  <p class="ff-help" style="margin-top:6px">${escapeHTML(t.meta)}</p>
                </div>
                <span class="ff-pill ${selected ? "ff-pill--accent" : ""}">${escapeHTML(pct)}%</span>
              </div>

              <div class="ff-meter" role="progressbar" aria-label="Team progress" aria-valuemin="0" aria-valuemax="100"
                   aria-valuenow="${escapeHTML(String(clamp(pct, 0, 100)))}"
                   aria-valuetext="${escapeHTML(String(clamp(pct, 0, 100)))}% funded" style="margin-top:10px">
                <span style="width:${escapeHTML(String(clamp((t.goalCents > 0 ? (t.raisedCents / t.goalCents) * 100 : 0), 0, 100).toFixed(2)))}%"></span>
              </div>

              <div class="ff-row ff-row--between ff-wrap" style="margin-top:8px">
                <span class="ff-help">Raised: <span class="ff-num">${escapeHTML(raised)}</span></span>
                <span class="ff-help">Goal: <span class="ff-num">${escapeHTML(goal)}</span></span>
              </div>

              <div class="ff-row ff-wrap" role="group" aria-label="Actions" style="margin-top:10px">
                <button class="ff-btn ff-btn--primary ff-btn--sm" type="button" data-ff-team-select data-team-id="${escapeHTML(t.id)}">
                  ${selected ? "Selected" : "Support this team"}
                </button>
                <button class="ff-btn ff-btn--ghost ff-btn--sm" type="button" data-ff-team-share data-team-id="${escapeHTML(t.id)}">
                  Share link
                </button>
              </div>
            </div>
          </div>
        </article>
      `;
    };

    D.teamsGrid.innerHTML = filtered.map(card).join("");

    qsa("[data-ff-team-card]", D.teamsGrid).forEach((el) => {
      if (el.__ff_bound) return;
      el.__ff_bound = true;
      on(el, "keydown", (e) => {
        if (e.key !== "Enter" && e.key !== " ") return;
        e.preventDefault();
        const id = el.getAttribute("data-team-id") || "";
        setSelectedTeam(id);
        scrollToDonate();
        toast("Team selected.", "success");
      });
    });

    qsa("[data-ff-team-select]", D.teamsGrid).forEach((btn) => {
      if (btn.__ff_bound) return;
      btn.__ff_bound = true;
      on(btn, "click", () => {
        const id = btn.getAttribute("data-team-id") || "";
        setSelectedTeam(id);
        scrollToDonate();
        toast("Team selected.", "success");
      });
    });

    qsa("[data-ff-team-share]", D.teamsGrid).forEach((btn) => {
      if (btn.__ff_bound) return;
      btn.__ff_bound = true;
      on(btn, "click", async () => {
        const id = btn.getAttribute("data-team-id") || "";
        setSelectedTeam(id, { silent: true });
        const url = buildShareUrl();
        try {
          if (navigator.share) {
            await navigator.share({ title: document.title, text: "Support this team.", url });
            toast("Shared.", "success");
            track("share", { kind: "team", id });
            return;
          }
        } catch {}
        try {
          await navigator.clipboard.writeText(url);
          toast("Team link copied.", "success");
          track("share_copy", { kind: "team", id });
        } catch {
          toast("Copy failed. Use Share dialog.", "error");
        }
      });
    });

    if (D.teamsStatus) D.teamsStatus.textContent = `${filtered.length} teams available.`;
  };

  const setSelectedTeam = (id, opt = {}) => {
    const teams = normalizeTeams();
    const found = teams.find((t) => t.id === id);
    if (!found) return;

    S.ui.selectedTeamId = found.id;
    S.ui.selectedTeamName = found.name;

    if (D.selectedTeamPill) D.selectedTeamPill.hidden = false;
    if (D.attribBox) D.attribBox.hidden = false;
    if (D.summaryTeamRow) D.summaryTeamRow.hidden = false;

    if (D.attribTitle) D.attribTitle.textContent = "Supporting a team";
    if (D.attribHelp) D.attribHelp.textContent = "This donation will credit the selected group.";
    if (D.summaryTeam) D.summaryTeam.textContent = found.name;

    // persist attribution (team)
    try {
      const saved = parseJSON(localStorage.getItem(attribKey()) || "null", null) || { utm: {} };
      saved.utm = saved.utm || {};
      saved.utm.team = found.id;
      localStorage.setItem(attribKey(), JSON.stringify({ ...saved, ts: new Date().toISOString() }));
    } catch {}

    setShareFields();
    renderTeams();

    if (!opt.silent) {
      track("team_selected", { team_id: found.id, team_name: found.name });
    }
  };

  const clearTeam = () => {
    S.ui.selectedTeamId = null;
    S.ui.selectedTeamName = "";

    if (D.selectedTeamPill) D.selectedTeamPill.hidden = true;
    if (D.attribBox) D.attribBox.hidden = true;
    if (D.summaryTeamRow) D.summaryTeamRow.hidden = true;

    setShareFields();
    renderTeams();
    track("team_cleared", {});
  };

  const bindTeamControls = () => {
    if (D.teamSearch && !D.teamSearch.__ff_bound) {
      D.teamSearch.__ff_bound = true;
      on(
        D.teamSearch,
        "input",
        debounce(() => {
          S.ui.teamQuery = D.teamSearch.value || "";
          renderTeams();
        }, 120)
      );
    }

    for (const btn of D.teamSortBtns) {
      if (btn.__ff_bound) continue;
      btn.__ff_bound = true;
      on(btn, "click", () => {
        S.ui.teamSort = btn.getAttribute("data-ff-sort") || "featured";
        for (const b of D.teamSortBtns) b.classList.toggle("is-selected", b === btn);
        for (const b of D.teamSortBtns) setAriaPressed(b, b === btn);
        renderTeams();
      });
    }

    for (const btn of D.attribClearBtns) {
      if (btn.__ff_bound) continue;
      btn.__ff_bound = true;
      on(btn, "click", () => {
        clearTeam();
        toast("Team cleared.", "info");
      });
    }
  };

  /* =========================================================
   * 15) Gallery v2 (elite lightbox + deep-link + filters)
   * =======================================================*/
  const normalizeGalleryItems = () => {
    const raw = Array.isArray(S.gallery.items) ? S.gallery.items : [];

    // Also support legacy shapes if they exist (safe fallback)
    const legacy = pick(C, "fundraiser.gallery", null) || pick(C, "org.gallery", null);
    const legacyItems = Array.isArray(legacy?.items) ? legacy.items : Array.isArray(legacy?.images) ? legacy.images : [];
    const merged = raw.length ? raw : legacyItems;

    const items = merged
      .map((x, idx) => {
        const id = safeText(x.id || x.key || `g${idx + 1}`);
        const src = safeText(x.src || x.url || "");
        const thumb = safeText(x.thumb || x.thumbnail || x.src || x.url || "");
        if (!src) return null;
        return {
          id,
          src,
          thumb,
          alt: safeText(x.alt || x.title || "Gallery image"),
          caption: safeText(x.caption || x.desc || ""),
          tag: safeText(x.tag || x.category || "").trim() || "highlights",
          featured: !!x.featured,
          ts: parseISO(x.tsISO || x.timestamp || "")?.getTime() || 0,
        };
      })
      .filter(Boolean);

    if (S.gallery.featuredFirst) {
      items.sort((a, b) => Number(b.featured) - Number(a.featured) || (b.ts || 0) - (a.ts || 0));
    } else {
      items.sort((a, b) => (b.ts || 0) - (a.ts || 0));
    }
    return items;
  };

  const ensureGallerySectionVisibility = (hasItems) => {
    if (!D.gallerySection) return;
    if (!S.gallery.enabled) return setHidden(D.gallerySection, true);
    setHidden(D.gallerySection, !hasItems);
  };

  const galleryFiltersFromItems = (items) => {
    const set = new Set(items.map((x) => x.tag).filter(Boolean));
    return ["all", ...Array.from(set).sort((a, b) => a.localeCompare(b))];
  };

  const renderGalleryFilters = (filters) => {
    // If filter buttons exist in DOM, we just wire them.
    // If none exist, we don't auto-inject markup to avoid breaking layouts.
    if (!D.galleryFilterBtns || !D.galleryFilterBtns.length) return;

    // optional: if buttons are present but don't match, still works (we just read attributes on click)
    for (const btn of D.galleryFilterBtns) {
      if (btn.__ff_bound) continue;
      btn.__ff_bound = true;
      on(btn, "click", () => {
        const f = btn.getAttribute("data-ff-gallery-filter") || "all";
        S.gallery.filter = f;
        for (const b of D.galleryFilterBtns) b.classList.toggle("is-selected", b === btn);
        for (const b of D.galleryFilterBtns) setAriaPressed(b, b === btn);
        renderGallery();
      });
    }

    // If a matching button exists, select it; otherwise keep current.
    const match = D.galleryFilterBtns.find((b) => (b.getAttribute("data-ff-gallery-filter") || "all") === S.gallery.filter);
    if (match) {
      for (const b of D.galleryFilterBtns) b.classList.toggle("is-selected", b === match);
      for (const b of D.galleryFilterBtns) setAriaPressed(b, b === match);
    } else {
      S.gallery.filter = "all";
    }
  };

  const galleryLightbox = (() => {
    let modal = null;
    let img = null;
    let cap = null;
    let prevBtn = null;
    let nextBtn = null;
    let closeBtn = null;
    let copyBtn = null;
    let dlBtn = null;
    let lastFocus = null;
    let items = [];
    let index = -1;

    const createModalIfMissing = () => {
      if (modal) return;

      modal = qs("[data-ff-gallery-lightbox]") || qs("#ffGalleryLightbox");
      if (modal) {
        img = qs("[data-ff-gallery-lightbox-img]", modal) || qs("img", modal);
        cap = qs("[data-ff-gallery-lightbox-caption]", modal);
        prevBtn = qs("[data-ff-gallery-prev]", modal);
        nextBtn = qs("[data-ff-gallery-next]", modal);
        closeBtn = qs("[data-ff-gallery-close]", modal);
        copyBtn = qs("[data-ff-gallery-copy]", modal);
        dlBtn = qs("[data-ff-gallery-download]", modal);
        return;
      }

      // Ultra-safe fallback modal (only if no markup exists)
      modal = document.createElement("div");
      modal.setAttribute("data-ff-gallery-lightbox", "true");
      modal.hidden = true;
      modal.setAttribute("aria-hidden", "true");
      modal.setAttribute("role", "dialog");
      modal.setAttribute("aria-modal", "true");
      modal.style.position = "fixed";
      modal.style.inset = "0";
      modal.style.zIndex = "9999";
      modal.style.background = "rgba(0,0,0,.72)";
      modal.style.display = "grid";
      modal.style.placeItems = "center";
      modal.style.padding = "18px";

      modal.innerHTML = `
        <div class="ff-mini" style="max-width:980px;width:100%;padding:14px;display:grid;gap:10px">
          <div class="ff-row ff-row--between ff-ais">
            <strong class="ff-help">Gallery</strong>
            <div class="ff-row ff-wrap" style="gap:8px;justify-content:flex-end">
              <button class="ff-btn ff-btn--ghost ff-btn--sm" type="button" data-ff-gallery-copy>Copy link</button>
              <button class="ff-btn ff-btn--ghost ff-btn--sm" type="button" data-ff-gallery-download>Download</button>
              <button class="ff-btn ff-btn--primary ff-btn--sm" type="button" data-ff-gallery-close>Close</button>
            </div>
          </div>
          <div style="display:grid;place-items:center;border-radius:14px;overflow:hidden;border:1px solid rgba(255,255,255,.12)">
            <img data-ff-gallery-lightbox-img alt="" style="max-width:100%;max-height:72vh;object-fit:contain" />
          </div>
          <div class="ff-row ff-row--between ff-ais ff-wrap">
            <button class="ff-btn ff-btn--ghost ff-btn--sm" type="button" data-ff-gallery-prev>Prev</button>
            <div class="ff-help" data-ff-gallery-lightbox-caption style="min-width:0;text-align:center"></div>
            <button class="ff-btn ff-btn--ghost ff-btn--sm" type="button" data-ff-gallery-next>Next</button>
          </div>
        </div>
      `;
      document.body.appendChild(modal);

      img = qs("[data-ff-gallery-lightbox-img]", modal);
      cap = qs("[data-ff-gallery-lightbox-caption]", modal);
      prevBtn = qs("[data-ff-gallery-prev]", modal);
      nextBtn = qs("[data-ff-gallery-next]", modal);
      closeBtn = qs("[data-ff-gallery-close]", modal);
      copyBtn = qs("[data-ff-gallery-copy]", modal);
      dlBtn = qs("[data-ff-gallery-download]", modal);
    };

    const setOpen = (v) => {
      if (!modal) return;
      modal.hidden = !v;
      modal.setAttribute("aria-hidden", v ? "false" : "true");
    };

    const preloadNeighbor = (idx) => {
      const it = items[idx];
      if (!it?.src) return;
      try {
        const link = document.createElement("link");
        link.rel = "preload";
        link.as = "image";
        link.href = it.src;
        document.head.appendChild(link);
        setTimeout(() => {
          try {
            document.head.removeChild(link);
          } catch {}
        }, 2500);
      } catch {}
    };

    const render = () => {
      const it = items[index];
      if (!it || !img) return;

      img.src = it.src;
      img.alt = it.alt || "Gallery image";
      if (cap) cap.textContent = it.caption || it.tag || "";

      S.gallery.openId = it.id;
      setShareFields();

      preloadNeighbor((index + 1) % items.length);
      preloadNeighbor((index - 1 + items.length) % items.length);

      track("gallery_open", { id: it.id, tag: it.tag || "" });
    };

    const go = (delta) => {
      if (!items.length) return;
      index = (index + delta + items.length) % items.length;
      render();
    };

    const close = () => {
      setOpen(false);
      S.gallery.openId = "";
      setShareFields();

      // focus restore
      if (pick(C, "flagship.accessibility.focusRestore", true) && lastFocus && typeof lastFocus.focus === "function") {
        try {
          lastFocus.focus();
        } catch {}
      }
      lastFocus = null;

      // remove deep-link param without reload
      try {
        const u = new URL(window.location.href);
        u.searchParams.delete(S.gallery.shareParam);
        history.replaceState({}, document.title, u.toString());
      } catch {}
    };

    const copyLink = async () => {
      try {
        const url = buildShareUrl();
        await navigator.clipboard.writeText(url);
        toast("Gallery link copied.", "success");
        track("share_copy", { kind: "gallery", id: S.gallery.openId || "" });
      } catch {
        toast("Copy failed.", "error");
      }
    };

    const download = async () => {
      const it = items[index];
      if (!it?.src) return;
      try {
        const res = await fetch(it.src, { method: "GET" });
        const blob = await res.blob();
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = `${(S.org.name || "fundraiser").toLowerCase().replace(/\s+/g, "-")}-${it.id}.jpg`;
        document.body.appendChild(a);
        a.click();
        setTimeout(() => {
          URL.revokeObjectURL(a.href);
          a.remove();
        }, 250);
        toast("Downloaded.", "success");
        track("gallery_download", { id: it.id });
      } catch {
        toast("Download failed.", "error");
      }
    };

    const bind = () => {
      if (!modal || modal.__ff_bound) return;
      modal.__ff_bound = true;

      on(closeBtn, "click", close);
      on(prevBtn, "click", () => go(-1));
      on(nextBtn, "click", () => go(1));
      on(copyBtn, "click", copyLink);
      on(dlBtn, "click", download);

      // click outside closes (safe)
      on(modal, "click", (e) => {
        if (e.target === modal) close();
      });

      // keyboard
      on(window, "keydown", (e) => {
        if (!modal || modal.hidden) return;
        if (e.key === "Escape") return close();
        if (e.key === "ArrowLeft") return go(-1);
        if (e.key === "ArrowRight") return go(1);
      });
    };

    const openById = (id, list, focusEl = null) => {
      createModalIfMissing();
      bind();
      items = Array.isArray(list) ? list : [];
      if (!items.length) return;

      const idx = items.findIndex((x) => x.id === id);
      index = idx >= 0 ? idx : 0;

      lastFocus = focusEl || document.activeElement;
      setOpen(true);
      render();

      // focus first actionable
      try {
        (closeBtn || modal).focus?.();
      } catch {}
    };

    return { openById, close };
  })();

  const renderGallery = () => {
    if (!S.gallery.enabled) return ensureGallerySectionVisibility(false);

    const items = normalizeGalleryItems();
    ensureGallerySectionVisibility(items.length);

    if (D.galleryTitle) D.galleryTitle.textContent = S.gallery.title || "Gallery";
    if (!D.galleryGrid) return;

    renderGalleryFilters(galleryFiltersFromItems(items));

    const q = safeText(S.gallery.query).trim().toLowerCase();
    const filtered = items.filter((x) => {
      if (S.gallery.filter !== "all" && x.tag !== S.gallery.filter) return false;
      if (!q) return true;
      return (x.alt + " " + x.caption + " " + x.tag).toLowerCase().includes(q);
    });

    if (!filtered.length) {
      if (D.galleryEmpty) setHidden(D.galleryEmpty, false);
      D.galleryGrid.innerHTML = "";
      return;
    }
    if (D.galleryEmpty) setHidden(D.galleryEmpty, true);

    // premium grid cards (non-destructive; uses existing CSS utilities)
    D.galleryGrid.innerHTML = filtered
      .map((x) => {
        return `
          <button type="button" class="ff-mini" data-ff-gallery-item data-gid="${escapeHTML(x.id)}"
            style="padding:10px;text-align:left;display:grid;gap:8px;border-radius:16px"
            aria-label="${escapeHTML(x.alt)}">
            <div style="aspect-ratio:1/1;border-radius:14px;overflow:hidden;border:1px solid var(--ff-border);
                        background:color-mix(in oklab,var(--ff-control-bg) 80%,transparent)">
              <img src="${escapeHTML(x.thumb)}" alt="${escapeHTML(x.alt)}" loading="lazy" decoding="async"
                   style="width:100%;height:100%;object-fit:cover" />
            </div>
            <div class="ff-row ff-row--between ff-ais" style="gap:10px">
              <div style="min-width:0">
                <div class="ff-kicker">${escapeHTML((x.tag || "HIGHLIGHTS").toUpperCase())}</div>
                <div class="ff-help" style="white-space:nowrap;overflow:hidden;text-overflow:ellipsis">${escapeHTML(x.caption || x.alt)}</div>
              </div>
              ${x.featured ? `<span class="ff-pill ff-pill--accent">Featured</span>` : `<span class="ff-pill">View</span>`}
            </div>
          </button>
        `;
      })
      .join("");

    qsa("[data-ff-gallery-item]", D.galleryGrid).forEach((btn) => {
      if (btn.__ff_bound) return;
      btn.__ff_bound = true;
      on(btn, "click", () => {
        const id = btn.getAttribute("data-gid") || "";
        galleryLightbox.openById(id, items, btn);
      });
      on(btn, "keydown", (e) => {
        if (e.key !== "Enter" && e.key !== " ") return;
        e.preventDefault();
        const id = btn.getAttribute("data-gid") || "";
        galleryLightbox.openById(id, items, btn);
      });
    });
  };

  const bindGalleryControls = () => {
    if (D.gallerySearch && !D.gallerySearch.__ff_bound) {
      D.gallerySearch.__ff_bound = true;
      on(
        D.gallerySearch,
        "input",
        debounce(() => {
          S.gallery.query = D.gallerySearch.value || "";
          renderGallery();
        }, 120)
      );
    }
  };

  const openGalleryFromUrlIfPresent = () => {
    if (!S.gallery.enabled) return;
    try {
      const u = new URL(window.location.href);
      const id = u.searchParams.get(S.gallery.shareParam);
      if (!id) return;

      // render first so items exist
      const items = normalizeGalleryItems();
      if (!items.length) return;

      // delay until after paint so layout is stable
      setTimeout(() => galleryLightbox.openById(id, items, null), 0);
    } catch {}
  };

  /* =========================================================
   * 16) Donate: prefills + recognition + autosave + summary
   * =======================================================*/
  const autosaveKey = () => `ff_form_${shellEnv.orgId}_${shellEnv.campaignId}`;

  const formAutosaveRead = () => {
    if (!pick(C, "flagship.features.formAutosave", true)) return;
    try {
      const data = parseJSON(sessionStorage.getItem(autosaveKey()) || "null", null);
      if (!data) return;

      if (D.email && !D.email.value) D.email.value = data.email || "";
      if (D.fullName && !D.fullName.value) D.fullName.value = data.name || "";
      if (D.message && !D.message.value) D.message.value = data.message || "";
      if (D.anonymous) D.anonymous.checked = !!data.anonymous;
      if (D.coverFees) D.coverFees.checked = !!data.coverFees;
      if (D.amount && !D.amount.value) D.amount.value = data.amount || "";
    } catch {}
  };

  const formAutosaveWrite = () => {
    if (!pick(C, "flagship.features.formAutosave", true)) return;
    try {
      const payload = {
        email: safeText(D.email?.value || "").trim(),
        name: safeText(D.fullName?.value || "").trim(),
        message: safeText(D.message?.value || "").trim(),
        anonymous: !!D.anonymous?.checked,
        coverFees: !!D.coverFees?.checked,
        amount: safeText(D.amount?.value || "").trim(),
        ts: new Date().toISOString(),
      };
      sessionStorage.setItem(autosaveKey(), JSON.stringify(payload));
    } catch {}
  };

  const bindPrefillButtons = () => {
    for (const btn of D.quickAmountBtns) {
      if (btn.__ff_bound) continue;
      btn.__ff_bound = true;
      on(btn, "click", () => {
        const raw = btn.getAttribute("data-ff-quick-amount") || btn.getAttribute("data-quick-amount") || "";
        const dollars = toInt(raw, 0);
        if (dollars <= 0) return;
        setPrefill({ amountCents: dollars * 100, purpose: S.ui.purpose || "donation" });
        scrollToDonate();
      });
    }

    for (const btn of D.prefills) {
      if (btn.__ff_bound) continue;
      btn.__ff_bound = true;
      on(btn, "click", () => {
        const amt = toInt(btn.getAttribute("data-ff-prefill-amount"), 0);
        const purpose = btn.getAttribute("data-ff-prefill-purpose") || "membership";
        const sku = btn.getAttribute("data-ff-prefill-sku") || "";
        if (amt <= 0) return;
        setPrefill({ amountCents: amt * 100, purpose, sku });
        scrollToDonate();
      });
    }

    if (D.clearAmountBtn && !D.clearAmountBtn.__ff_bound) {
      D.clearAmountBtn.__ff_bound = true;
      on(D.clearAmountBtn, "click", () => {
        if (D.amount) D.amount.value = "";
        updateDonateSummary();
        formAutosaveWrite();
      });
    }

    if (D.popularAmountPill && D.popularAmountText) {
      D.popularAmountText.textContent = formatCurrency(S.fundraiser.popularAmountCents, currency, locale);
      D.popularAmountPill.hidden = false;
    }

    for (const btn of D.giftTypeBtns) {
      if (btn.__ff_bound) continue;
      btn.__ff_bound = true;
      on(btn, "click", () => {
        S.ui.giftType = btn.getAttribute("data-ff-gift-type") || "one-time";
        for (const b of D.giftTypeBtns) b.classList.toggle("is-selected", b === btn);
        for (const b of D.giftTypeBtns) setAriaPressed(b, b === btn);
        toast(S.ui.giftType === "monthly" ? "Monthly giving coming soon." : "One-time gift selected.", "info");
        track("gift_type", { gift_type: S.ui.giftType });
      });
    }
  };

  const applyRecognition = () => {
    const anon = !!D.anonymous?.checked;
    const name = safeText(D.fullName?.value || "").trim();

    if (anon || S.ui.recognition === "anonymous" || !name) {
      if (D.recognitionPreviewText) D.recognitionPreviewText.textContent = "Anonymous";
      if (D.proofDonorName) D.proofDonorName.textContent = "Anonymous";
      return;
    }
    if (D.recognitionPreviewText) D.recognitionPreviewText.textContent = name;
    if (D.proofDonorName) D.proofDonorName.textContent = name;
  };

  const bindRecognitionControls = () => {
    for (const btn of D.recognitionBtns) {
      if (btn.__ff_bound) continue;
      btn.__ff_bound = true;
      on(btn, "click", () => {
        S.ui.recognition = btn.getAttribute("data-ff-recognition") || "public";
        for (const b of D.recognitionBtns) b.classList.toggle("is-selected", b === btn);
        for (const b of D.recognitionBtns) setAriaPressed(b, b === btn);

        if (D.anonymous) {
          if (S.ui.recognition === "anonymous") D.anonymous.checked = true;
          if (S.ui.recognition === "public") D.anonymous.checked = false;
        }
        applyRecognition();
        formAutosaveWrite();
      });
    }

    if (D.anonymous && !D.anonymous.__ff_bound) {
      D.anonymous.__ff_bound = true;
      on(D.anonymous, "change", () => {
        if (D.anonymous.checked) S.ui.recognition = "anonymous";
        else S.ui.recognition = "public";
        for (const b of D.recognitionBtns) b.classList.toggle("is-selected", b.getAttribute("data-ff-recognition") === S.ui.recognition);
        applyRecognition();
        formAutosaveWrite();
      });
    }

    on(D.fullName, "input", debounce(() => (applyRecognition(), formAutosaveWrite()), 90));
  };

  const estimateStripeFeesCents = (donationCents) => {
    const pct = 0.029;
    const fixed = 30;
    return Math.round(donationCents * pct) + fixed;
  };

  const updateDonateSummary = () => {
    const donationCents = parseMoneyToCents(D.amount?.value || "");
    const cover = !!D.coverFees?.checked;
    const feesCents = donationCents > 0 ? estimateStripeFeesCents(donationCents) : 0;
    const totalCents = donationCents + (cover ? feesCents : 0);

    if (D.summaryAmount) D.summaryAmount.textContent = formatCurrencyExact(donationCents, currency, locale);
    if (D.summaryFees) D.summaryFees.textContent = donationCents > 0 ? (cover ? formatCurrencyExact(feesCents, currency, locale) : "—") : "—";
    if (D.summaryTotal) D.summaryTotal.textContent = donationCents > 0 ? formatCurrencyExact(totalCents, currency, locale) : "—";

    if (D.receiptEmail) D.receiptEmail.textContent = safeText(D.email?.value || "").trim() || "your email";
    if (D.proofAmount) D.proofAmount.textContent = formatCurrency(donationCents || 0, currency, locale);

    if (D.clearAmountBtn) D.clearAmountBtn.hidden = donationCents <= 0;

    const ok = donationCents >= 100 && emailOk(D.email?.value || "");
    if (D.payBtn) D.payBtn.disabled = !ok;
    if (D.checkoutStatusText) D.checkoutStatusText.textContent = ok ? "Ready" : "Needs amount + email";
  };

  const bindDonateInputs = () => {
    const sync = debounce(() => {
      updateDonateSummary();
      applyRecognition();
      maybeLazyInitStripe();
      formAutosaveWrite();
    }, 90);

    on(D.amount, "input", sync);
    on(D.email, "input", sync);
    on(D.coverFees, "change", sync);
    on(D.fullName, "input", sync);
    on(D.message, "input", sync);

    updateDonateSummary();
    applyRecognition();
  };

  /* =========================================================
   * 17) Payments: Stripe + PayPal (unchanged behavior, hardened)
   * =======================================================*/
  const fetchJSON = async (url, body) => {
    const headers = { "Content-Type": "application/json", Accept: "application/json" };
    if (csrfToken) headers["X-CSRFToken"] = csrfToken;

    const res = await fetch(url, { method: "POST", headers, credentials: "same-origin", body: JSON.stringify(body || {}) });
    const text = await res.text();
    const data = parseJSON(text, null);

    if (!res.ok) {
      const msg = (data && (data.error || data.message)) || text || `HTTP ${res.status}`;
      throw new Error(msg);
    }
    return data ?? {};
  };

  const stripeIntentKey = () => {
    const donationCents = parseMoneyToCents(D.amount?.value || "");
    const cover = !!D.coverFees?.checked;
    const totalCents = donationCents + (cover ? estimateStripeFeesCents(donationCents) : 0);
    const email = safeText(D.email?.value || "").trim().toLowerCase();
    const team = S.ui.selectedTeamId || "";
    const purpose = S.ui.purpose || "donation";
    const sku = S.ui.sku || "";
    const impact = S.ui.impactId || "";
    return [totalCents, email, cover ? 1 : 0, team, purpose, sku, impact].join("|");
  };

  const ensureStripe = async () => {
    if (S.ui.stripeReady) return true;
    if (!stripePk || !window.Stripe) return false;
    S.ui.stripe = window.Stripe(stripePk);
    S.ui.stripeReady = true;
    return true;
  };

  const ensureClientSecret = async () => {
    const donationCents = parseMoneyToCents(D.amount?.value || "");
    const email = safeText(D.email?.value || "").trim();
    const cover = !!D.coverFees?.checked;

    if (donationCents < 100) throw new Error("Enter a valid amount.");
    if (!emailOk(email)) throw new Error("Enter a valid email.");

    const feesCents = estimateStripeFeesCents(donationCents);
    const totalCents = donationCents + (cover ? feesCents : 0);

    const key = stripeIntentKey();
    if (S.ui.clientSecret && S.ui.lastIntentKey === key) return S.ui.clientSecret;

    const payload = {
      org_id: shellEnv.orgId,
      campaign_id: shellEnv.campaignId,
      currency,
      amount_cents: totalCents,
      donation_cents: donationCents,
      cover_fees: cover,
      donor: {
        email,
        name: safeText(D.fullName?.value || "").trim(),
        message: safeText(D.message?.value || "").trim(),
        anonymous: !!D.anonymous?.checked || S.ui.recognition === "anonymous",
        recognition: S.ui.recognition,
      },
      attribution: {
        team_id: S.ui.selectedTeamId || null,
        team_name: S.ui.selectedTeamName || null,
        impact_id: S.ui.impactId || null,
      },
      intent: {
        purpose: S.ui.purpose || "donation",
        sku: S.ui.sku || null,
        gift_type: S.ui.giftType || "one-time",
      },
      utm: S.utm || {},
      meta: { tier: shellEnv.tier, version: shellEnv.version, whiteLabel: shellEnv.whiteLabel },
    };

    S.ui.stripeBusy = true;
    setBusy(D.donationForm, true);
    if (D.checkoutStatusText) D.checkoutStatusText.textContent = "Creating secure session…";

    let data;
    try {
      data = await fetchJSON(checkoutEndpoint, payload);
    } finally {
      S.ui.stripeBusy = false;
      setBusy(D.donationForm, false);
    }

    const cs = data.client_secret || data.clientSecret || data.payment_intent_client_secret;
    if (!cs) throw new Error("Payment session unavailable.");

    S.ui.clientSecret = cs;
    S.ui.lastIntentKey = key;
    if (D.checkoutStatusText) D.checkoutStatusText.textContent = "Ready";
    return cs;
  };

  const showPayError = (msg) => {
    if (D.payErrorText) D.payErrorText.textContent = safeText(msg || "Something went wrong. Please try again.");
    if (D.payError) {
      D.payError.hidden = false;
      D.payError.focus?.();
    }
    if (D.paySuccess) D.paySuccess.hidden = true;
    toast(safeText(msg || "Payment error."), "error");
    track("payment_error", { message: safeText(msg || "") });
  };

  const showPaySuccess = (msg) => {
    if (D.paySuccessText) D.paySuccessText.textContent = safeText(msg || "Thank you! Your receipt has been emailed.");
    if (D.paySuccess) {
      D.paySuccess.hidden = false;
      D.paySuccess.focus?.();
    }
    if (D.payError) D.payError.hidden = true;
    toast("Payment successful.", "success");
    track("payment_success", {});
  };

  const mountPaymentElement = async () => {
    if (S.ui.payMounted) return;

    const ok = await ensureStripe();
    if (!ok) {
      if (D.checkoutStatusText) D.checkoutStatusText.textContent = stripePk ? "Stripe unavailable" : "Stripe not configured";
      return;
    }

    const cs = await ensureClientSecret();
    const appearance = { theme: document.documentElement.getAttribute("data-theme") === "light" ? "stripe" : "night" };

    S.ui.elements = S.ui.stripe.elements({ clientSecret: cs, appearance });
    S.ui.paymentElement = S.ui.elements.create("payment", { layout: "tabs" });

    if (D.paymentElementHost) {
      D.paymentElementHost.innerHTML = "";
      S.ui.paymentElement.mount(D.paymentElementHost);
      S.ui.payMounted = true;
      if (D.checkoutMethodPill && D.checkoutMethodText) {
        D.checkoutMethodPill.hidden = false;
        D.checkoutMethodText.textContent = "Card / Wallet";
      }
    }

    if (S.ui.paymentElement) {
      S.ui.paymentElement.on("change", (e) => {
        const msg = e?.complete ? "Payment details complete." : e?.error?.message || "";
        if (D.paymentLive) D.paymentLive.textContent = msg;
      });
    }
  };

  const maybeLazyInitStripe = debounce(async () => {
    const donationCents = parseMoneyToCents(D.amount?.value || "");
    const email = safeText(D.email?.value || "").trim();
    const ok = donationCents >= 100 && emailOk(email);
    if (!ok) return;

    const donate = qs("#donate");
    if (!donate || S.ui.payMounted) return;

    const rect = donate.getBoundingClientRect();
    const inView = rect.top < window.innerHeight * 1.2 && rect.bottom > 0;
    if (!inView) return;

    try {
      await mountPaymentElement();
    } catch (e) {
      showPayError(e?.message || "Unable to initialize payment.");
    }
  }, 250);

  const clearStripeRedirectParams = () => {
    try {
      const url = new URL(window.location.href);
      const hasAny = url.searchParams.has("payment_intent") || url.searchParams.has("payment_intent_client_secret") || url.searchParams.has("redirect_status");
      if (!hasAny) return;
      url.searchParams.delete("payment_intent");
      url.searchParams.delete("payment_intent_client_secret");
      url.searchParams.delete("redirect_status");
      history.replaceState({}, document.title, url.toString());
    } catch {}
  };

  const handleStripeReturn = () => {
    const url = new URL(window.location.href);
    const status = url.searchParams.get("redirect_status");
    if (!status) return;

    if (status === "succeeded") showPaySuccess("Thank you! Your receipt has been emailed.");
    else if (status === "failed") showPayError("Payment failed. Please try again.");
    else showPayError("Payment needs attention. Please try again.");

    clearStripeRedirectParams();
  };

  const bindDonateSubmit = () => {
    if (!D.donationForm || D.donationForm.__ff_bound) return;
    D.donationForm.__ff_bound = true;

    on(D.donationForm, "submit", async (e) => {
      e.preventDefault();

      if (D.payError) D.payError.hidden = true;
      if (D.paySuccess) D.paySuccess.hidden = true;

      const donationCents = parseMoneyToCents(D.amount?.value || "");
      const email = safeText(D.email?.value || "").trim();
      if (donationCents < 100) return showPayError("Enter a valid amount.");
      if (!emailOk(email)) return showPayError("Enter a valid email for the receipt.");
      if (!stripePk) return showPayError("Stripe is not configured for this fundraiser.");
      if (!window.Stripe) return showPayError("Stripe failed to load. Check your connection.");

      track("donate_submit", { amount_cents: donationCents, purpose: S.ui.purpose || "donation" });

      if (D.checkoutStatusText) D.checkoutStatusText.textContent = "Preparing secure checkout…";
      if (D.payBtn) {
        D.payBtn.disabled = true;
        D.payBtn.textContent = "Processing…";
      }

      try {
        await mountPaymentElement();

        const returnUrl = (() => {
          const u = new URL(window.location.href);
          u.hash = "#donate";
          return u.toString();
        })();

        const { error } = await S.ui.stripe.confirmPayment({
          elements: S.ui.elements,
          confirmParams: { return_url: returnUrl, receipt_email: email },
          redirect: "if_required",
        });

        if (error) throw new Error(error.message || "Payment could not be completed.");
        showPaySuccess("Thank you! Your receipt has been emailed.");
      } catch (err) {
        showPayError(err?.message || "Payment error. Please try again.");
      } finally {
        if (D.checkoutStatusText) D.checkoutStatusText.textContent = "Ready";
        if (D.payBtn) {
          D.payBtn.disabled = false;
          D.payBtn.textContent = "Continue";
        }
      }
    });
  };

  const maybeEnablePayPal = async () => {
    if (!paypalClientId || !D.paypalMount || !D.paypalButtonsHost) return;

    try {
      const ok = await (window.ffLoadPayPal ? window.ffLoadPayPal() : Promise.resolve(false));
      if (!ok || !window.paypal) return;

      S.ui.paypalReady = true;
      S.ui.paypalVisible = true;
      D.paypalMount.hidden = false;

      if (D.paypalButtonsHost.__ff_rendered) return;
      D.paypalButtonsHost.__ff_rendered = true;

      window.paypal
        .Buttons({
          style: { layout: "vertical" },
          createOrder: async () => {
            const donationCents = parseMoneyToCents(D.amount?.value || "");
            const email = safeText(D.email?.value || "").trim();
            if (donationCents < 100) throw new Error("Enter a valid amount.");
            if (!emailOk(email)) throw new Error("Enter a valid email.");

            const cover = !!D.coverFees?.checked;
            const feesCents = estimateStripeFeesCents(donationCents);
            const totalCents = donationCents + (cover ? feesCents : 0);

            const payload = {
              org_id: shellEnv.orgId,
              campaign_id: shellEnv.campaignId,
              currency: paypalCurrency,
              intent: paypalIntent,
              amount_cents: totalCents,
              donation_cents: donationCents,
              cover_fees: cover,
              donor: {
                email,
                name: safeText(D.fullName?.value || "").trim(),
                message: safeText(D.message?.value || "").trim(),
                anonymous: !!D.anonymous?.checked || S.ui.recognition === "anonymous",
                recognition: S.ui.recognition,
              },
              attribution: {
                team_id: S.ui.selectedTeamId || null,
                team_name: S.ui.selectedTeamName || null,
                impact_id: S.ui.impactId || null,
              },
              meta: { version: shellEnv.version, tier: shellEnv.tier },
            };

            const data = await fetchJSON(paypalCreateEndpoint, payload);
            const orderId = data.order_id || data.id;
            if (!orderId) throw new Error("PayPal order unavailable.");

            if (D.checkoutMethodPill && D.checkoutMethodText) {
              D.checkoutMethodPill.hidden = false;
              D.checkoutMethodText.textContent = "PayPal";
            }
            track("paypal_create", { amount_cents: totalCents });
            return orderId;
          },
          onApprove: async (data) => {
            const orderId = data?.orderID;
            if (!orderId) throw new Error("PayPal approval missing.");
            if (D.checkoutStatusText) D.checkoutStatusText.textContent = "Finalizing…";

            const payload = { order_id: orderId, org_id: shellEnv.orgId, campaign_id: shellEnv.campaignId };
            const res = await fetchJSON(paypalCaptureEndpoint, payload);
            if (res.status && String(res.status).toLowerCase() !== "completed") throw new Error("PayPal capture incomplete.");

            showPaySuccess("Thank you! Your receipt has been emailed.");
          },
          onError: (err) => showPayError(err?.message || "PayPal error. Please try again."),
        })
        .render(D.paypalButtonsHost);

      toast("PayPal enabled.", "info");
    } catch {
      // keep silent; PayPal remains hidden
    }
  };

  /* =========================================================
   * 18) QR downloads (blob-safe)
   * =======================================================*/
  const downloadQr = async () => {
    try {
      const url = buildQrSrc(buildShareUrl(), 512);
      const res = await fetch(url, { method: "GET", mode: "cors" });
      const blob = await res.blob();
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = `${(S.org.name || "fundraiser").toLowerCase().replace(/\s+/g, "-")}-qr.png`;
      document.body.appendChild(a);
      a.click();
      setTimeout(() => {
        URL.revokeObjectURL(a.href);
        a.remove();
      }, 250);
      toast("QR downloaded.", "success");
      track("qr_download", {});
    } catch {
      toast("QR download failed.", "error");
    }
  };

  const bindQrDownloads = () => {
    for (const btn of D.downloadQrBtns) {
      if (btn.__ff_bound) continue;
      btn.__ff_bound = true;
      on(btn, "click", downloadQr);
    }
  };

  /* =========================================================
   * 19) Recent gifts (config render + refresh hook)
   * =======================================================*/
  const normalizeGifts = () => {
    const raw = Array.isArray(S.fundraiser.recentGifts) ? S.fundraiser.recentGifts : [];
    return raw
      .map((g) => ({
        name: safeText(g.name || ""),
        amountCents: toInt(g.amountCents ?? (toInt(g.amount, 0) * 100), 0),
        anon: !!g.anon || !!g.anonymous,
        ts: parseISO(g.tsISO || "")?.getTime() || 0,
      }))
      .filter((x) => x.amountCents > 0)
      .sort((a, b) => (b.ts || 0) - (a.ts || 0));
  };

  const renderRecentGifts = () => {
    if (!D.recentGiftsHost) return;
    const gifts = normalizeGifts().slice(0, 5);
    if (!gifts.length) {
      D.recentGiftsHost.innerHTML = `<div class="ff-help" style="color:var(--ff-text-3)">No public gifts yet.</div>`;
      return;
    }
    D.recentGiftsHost.innerHTML = gifts
      .map((g) => {
        const name = g.anon ? "Anonymous" : g.name || "Supporter";
        const amt = formatCurrency(g.amountCents, currency, locale);
        return `<div class="ff-slimitem"><span class="ff-help">${escapeHTML(name)}</span><strong class="ff-help ff-num">${escapeHTML(amt)}</strong></div>`;
      })
      .join("");
  };

  const bindRefresh = () => {
    for (const btn of D.refreshBtns) {
      if (btn.__ff_bound) continue;
      btn.__ff_bound = true;
      on(btn, "click", () => {
        renderRecentGifts();
        applyUpdated();
        toast("Updated.", "info");
        track("refresh", { kind: "summary" });
      });
    }
  };

  /* =========================================================
   * 20) Proof caption copy (elite social flywheel)
   * =======================================================*/
  const bindCopyCaption = () => {
    if (!D.copyCaptionBtn || D.copyCaptionBtn.__ff_bound) return;
    D.copyCaptionBtn.__ff_bound = true;

    on(D.copyCaptionBtn, "click", async () => {
      const caption = safeText(D.proofCaption?.value || D.proofCaption?.textContent || "").trim();
      const url = buildShareUrl();
      const out = caption ? `${caption}\n\n${url}` : url;
      try {
        await navigator.clipboard.writeText(out);
        toast("Caption copied.", "success");
        track("share_copy", { kind: "caption" });
      } catch {
        toast("Copy failed.", "error");
      }
    });
  };

  /* =========================================================
   * 21) Premium micro-polish
   * =======================================================*/
  const pulseTrust = () => {
    if (captureMode || prefersReducedMotion()) return;
    const chips = D.trustChips || [];
    if (!chips.length) return;

    let i = 0;
    setInterval(() => {
      const el = chips[i % chips.length];
      i++;
      if (!el) return;
      el.style.transform = "translateZ(0) scale(1.02)";
      setTimeout(() => (el.style.transform = ""), 160);
    }, 4200);
  };

  /* =========================================================
   * 22) PWA (optional)
   * =======================================================*/
  const registerSW = async () => {
    const enabled = !!pick(C, "flagship.features.pwa", false);
    if (!enabled || !("serviceWorker" in navigator)) return;
    try {
      await navigator.serviceWorker.register("/service-worker.js", { scope: "/" });
      track("pwa_registered", {});
    } catch {}
  };

  /* =========================================================
   * 23) Boot sequence (ordered, resilient)
   * =======================================================*/
  const init = async () => {
    track("page_view", { org_id: shellEnv.orgId, campaign_id: shellEnv.campaignId, tier: shellEnv.tier, version: shellEnv.version });

    readUtm();
    applyBrand();
    applyAnnouncement();

    // restore form draft before first summary render
    formAutosaveRead();

    // compute raised
    S.fundraiser.raisedCents = deriveRaisedCents();

    // core render
    setProgressUI();
    applyUpdated();
    applyMatch();
    startDeadlineLoop();

    // allocation/impact/sponsors/teams
    idle(() => {
      renderAllocation();
      bindImpactControls();
      renderImpact();

      renderSponsorTiers();
      bindSponsorControls();
      renderSponsorBoards();

      bindTeamControls();
      renderTeams();
    });

    // share + QR
    setShareFields();
    bindQrDownloads();

    // donate wiring
    bindPrefillButtons();
    bindRecognitionControls();
    bindDonateInputs();
    bindDonateSubmit();

    // gifts + refresh hooks
    renderRecentGifts();
    bindRefresh();

    // proof copy
    bindCopyCaption();

    // stripe return
    handleStripeReturn();

    // PayPal opt-in (quiet)
    maybeEnablePayPal();

    // Gallery (optional)
    if (S.gallery.enabled) {
      bindGalleryControls();
      idle(() => renderGallery(), 900);
      openGalleryFromUrlIfPresent();
    } else {
      ensureGallerySectionVisibility(false);
    }

    // lazy init Stripe when donate in view
    const donate = qs("#donate");
    if (donate && "IntersectionObserver" in window) {
      const io = new IntersectionObserver(
        (entries) => {
          const e = entries[0];
          if (e && e.isIntersecting) maybeLazyInitStripe();
        },
        { root: null, threshold: 0.15 }
      );
      io.observe(donate);
    }

    // keep share fields up to date
    on(window, "hashchange", () => setShareFields());

    // premium polish
    pulseTrust();

    // pwa
    registerSW();
  };

  try {
    init();
  } catch {
    // fail-silent: never block donation flow due to UI extras
  }
})();

